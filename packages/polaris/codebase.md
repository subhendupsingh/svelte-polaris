# components/account-connection/account-connection.module.css

```css

```

# components/account-connection/account-connection.svelte

```svelte
<script lang="ts">
	import { UseBreakpoints, useBreakpoints } from '$lib/use/use-breakpoints.svelte.js';
	import Avatar from '../avatar/avatar.svelte';
	import type { AccountConnectionProps } from './types.js';
	import Text from '../text/text.svelte';
	import Box from '../box/box.svelte';
	import Card from '../card/card.svelte';
	import SettingAction from '../setting-action/setting-action.svelte';
	import InlineStack from '../inline-stack/inline-stack.svelte';
	import BlockStack from '../block-stack/block-stack.svelte';
	import ButtonFrom from '../button/button-from.svelte';

	let {
		connected = false,
		action: settingAction,
		avatarUrl,
		accountName = '',
		title,
		details,
		termsOfService
	}: AccountConnectionProps = $props();

	const bp = new UseBreakpoints();
	const breakpoints = $derived(bp.getCurrentBreakpoints());

	const initials = $derived(
		accountName
			? accountName
					.split(/\s+/)
					.map((name) => name[0])
					.join('')
			: undefined
	);

	const titleContent = $derived(title ? title : accountName);
</script>

{#snippet avatarMarkup()}
	{#if connected}
		<span>
			<Avatar accessibilityLabel="" name={accountName} {initials} source={avatarUrl} />
		</span>
	{/if}
{/snippet}

{#snippet titleMarkup()}
	<Text as="h2" variant="headingSm">
		{titleContent}
	</Text>
{/snippet}

{#snippet detailsMarkup()}
	{#if details}
		<Text as="span" variant="bodyMd" tone="subdued">
			{details}
		</Text>
	{/if}
{/snippet}

{#snippet termsOfServiceMarkup()}
	{#if termsOfService}
		<Box paddingBlockStart={breakpoints?.mdUp ? '400' : '500'}>
			{#if typeof termsOfService === 'string'}
				<Text as="span" variant="bodyMd">
					{termsOfService}
				</Text>
			{:else}
				{@render termsOfService()}
			{/if}
		</Box>
	{/if}
{/snippet}

<Card>
	<SettingAction>
		{#snippet action()}
			{#if settingAction}
				<ButtonFrom
					action={settingAction}
					overrides={{ variant: connected ? undefined : 'primary' }}
				/>
			{/if}
		{/snippet}
		<InlineStack gap="400">
			{@render avatarMarkup()}
			<BlockStack gap="100">
				{@render titleMarkup()}
				{@render detailsMarkup()}
			</BlockStack>
		</InlineStack>
	</SettingAction>
	{@render termsOfServiceMarkup()}
</Card>

```

# components/account-connection/types.ts

```ts
import type { Action } from "$utilities/types.js";
import type { Snippet } from "svelte";

export interface AccountConnectionProps {
    /** Content to display as title */
    title?: string;
    /** Content to display as additional details */
    details?: string;
    /** Content to display as terms of service */
    termsOfService?: string |  Snippet;
    /** The name of the service */
    accountName?: string;
    /** URL for the userâ€™s avatar image */
    avatarUrl?: string;
    /** Set if the account is connected */
    connected?: boolean;
    /** Action for account connection */
    action?: Action;
  }
```

# components/action-list/action-list.module.css

```css
.Item {
    /* stylelint-disable-next-line -- generated by polaris-migrator DO NOT COPY */
    @mixin unstyled-button;
    /* stylelint-disable-next-line -- generated by polaris-migrator DO NOT COPY */
    @mixin focus-ring wide;
    /* stylelint-disable -- Polaris component custom properties */
    --pc-action-list-item-min-height: var(--p-space-800);
    --pc-action-list-indented-item-margin: calc(var(--p-space-500) + var(--p-space-050));
    --pc-action-list-indented-item-width: calc(100% - var(--pc-action-list-indented-item-margin));

    &.default {
        --pc-action-list-image-size: 20px;
    }

    --pc-action-list-item-vertical-padding: calc((var(--pc-action-list-item-min-height) - var(--p-font-line-height-500)) / 2);
    /* stylelint-enable */
    display: flex;
    align-items: center;
    width: 100%;
    /* stylelint-disable-next-line -- generated by polaris-migrator DO NOT COPY */
    min-height: var(--pc-action-list-item-min-height);
    text-align: left;
    text-decoration: none;
    cursor: pointer;
    padding: var(--p-space-100) var(--p-space-150);
    border-radius: var(--p-border-radius-200);
    border-top: var(--p-border-width-025) solid transparent;
    color: inherit;

    @media (forced-colors: active) {
        border: var(--p-border-width-025) solid transparent;
    }

    &:hover {
        background-color: var(--p-color-bg-surface-secondary-hover);
        text-decoration: none;
        outline: var(--p-border-width-050) solid transparent;
    }

    &:active {
        background-color: var(--p-color-bg-surface-secondary-active);

        svg {
            fill: var(--p-color-icon);
        }
    }

    &:focus-visible:not(:active) {
        /* stylelint-disable-next-line -- generated by polaris-migrator DO NOT COPY */
        @mixin no-focus-ring;
        background-color: var(--p-color-bg-surface);
        outline: var(--p-border-width-050) solid var(--p-color-border-focus);
    }

    &:visited {
        color: inherit;
    }

    &.active {
        background-color: var(--p-color-bg-surface-secondary-selected);
        font-weight: var(--p-font-weight-semibold);

        svg {
            fill: var(--p-color-icon-active);
        }

        &::before {
            /* stylelint-disable-next-line -- alignment for left tab style https://github.com/Shopify/polaris/pull/3619 */
            @mixin list-selected-indicator;
            display: none;
        }
    }

    &.destructive {
        color: var(--p-color-text-critical);

        svg {
            fill: var(--p-color-text-critical);
        }

        &:hover {
            background-color: var(--p-color-bg-surface-critical-hover);
        }

        /* stylelint-disable-next-line selector-max-class -- generated by polaris-migrator DO NOT COPY */
        &:active,
        &.active {
            background-color: var(--p-color-bg-surface-critical-active);
        }
    }

    &.disabled {
        background-image: none;
        color: var(--p-color-text-disabled);
        cursor: default;

        &:hover {
            background-color: unset;
        }

        /* stylelint-disable-next-line selector-max-class, selector-max-combinators, selector-max-specificity -- generated by polaris-migrator DO NOT COPY */
        .Prefix svg,
        .Suffix svg {
            fill: var(--p-color-icon-disabled);
        }
    }

    &.indented {
        /* stylelint-disable -- reset custom properties */
        --pc-action-list-image-size: 24px;
        position: relative;
        margin-left: var(--pc-action-list-indented-item-margin);
        max-width: var(--pc-action-list-indented-item-width);
        /* stylelint-enable */

        &::before {
            content: '';
            position: absolute;
            top: calc(var(--p-space-300) * -1);
            bottom: 0;
            left: 0;
            border-left: var(--p-border-width-025) solid var(--p-color-border);
            margin-left: calc(var(--p-space-150) * -1);
        }
    }

    &.menu {
        /* stylelint-disable -- reset custom properties */
        --pc-action-list-image-size: 24px;
        /* stylelint-enable */
    }
}

.Prefix {
    display: flex;
    flex: 0 0 auto;
    justify-content: center;
    align-items: center;
    /* stylelint-disable-next-line -- generated by polaris-migrator DO NOT COPY */
    height: var(--pc-action-list-image-size);
    /* stylelint-disable-next-line -- generated by polaris-migrator DO NOT COPY */
    width: var(--pc-action-list-image-size);
    border-radius: var(--p-border-radius-100);

    /* We need the negative margin to ensure that the image does not set
       the minimum height of the action item. */
    /* stylelint-disable -- generated by polaris-migrator DO NOT COPY */
    margin: calc(-0.5 * var(--pc-action-list-image-size)) 0 calc(-0.5 * var(--pc-action-list-image-size)) 0;
    /* stylelint-enable */
    background-size: cover;
    background-position: center center;

    svg {
        fill: var(--p-color-icon);
    }
}

.Suffix svg {
    fill: var(--p-color-icon);
}

.Text {
    min-width: 0;
    max-width: 100%;
    flex: 1 1 auto;
}
```

# components/action-list/action-list.svelte

```svelte
<script lang="ts">
	import type { ActionListSection } from '$utilities/types.js';
	import Box from '../box/box.svelte';
	import Section from './components/action-list-section/action-list-section.svelte';
	import { FILTER_ACTIONS_THRESHOLD, type ActionListProps } from './types.js';

	let {
		items,
		sections = [],
		actionRole,
		allowFiltering,
		onActionAnyItem,
		filterLabel
	}: ActionListProps = $props();

	//@ts-ignore
	let finalSections: readonly ActionListSection[] = $derived.by(() => {
		if (items) {
			return [{ items }, ...sections];
		} else if (sections) {
			return sections;
		}
		return [];
	});

	const isFilterable = $derived(
		finalSections?.some((section) => section.items.some((item) => typeof item.content === 'string'))
	);

	const hasMultipleSections = $derived(finalSections.length > 1);
	const elementRole = $derived(
		hasMultipleSections && actionRole === 'menuitem' ? 'menu' : undefined
	);
	const elementTabIndex = $derived(
		hasMultipleSections && actionRole === 'menuitem' ? -1 : undefined
	);

	let searchText = $state('');
	const filteredSections = $derived(
		finalSections?.map((section) => ({
			...section,
			items: section.items.filter(({ content }) =>
				typeof content === 'string'
					? content?.toLowerCase().includes(searchText.toLowerCase())
					: content
			)
		}))
	);

	const totalActions = $derived(
		finalSections?.reduce((acc: number, section) => acc + section.items.length, 0) || 0
	);

	const hasManyActions = $derived(totalActions >= FILTER_ACTIONS_THRESHOLD);
	const totalFilteredActions = $derived.by(() => {
		const totalSectionItems =
			filteredSections?.reduce((acc: number, section) => acc + section.items.length, 0) || 0;

		return totalSectionItems;
	});
</script>

{#snippet sectionMarkup()}
	{#each filteredSections as section, index}
		{#if section.items.length > 0}
			<Section
				{section}
				{hasMultipleSections}
				{actionRole}
				{onActionAnyItem}
				isFirst={index === 0}
			/>
		{/if}
	{/each}
{/snippet}

{#if allowFiltering && hasManyActions && isFilterable}
	<Box padding="200" paddingBlockEnd={totalFilteredActions > 0 ? '0' : '200'}>
		<!-- <TextField
			clearButton
			labelHidden
			label={filterLabel
				? filterLabel
				: i18n.translate('Polaris.ActionList.SearchField.placeholder')}
			placeholder={filterLabel
				? filterLabel
				: i18n.translate('Polaris.ActionList.SearchField.placeholder')}
			autoComplete="off"
			value={searchText}
			onChange={(value) => setSearchText(value)}
			onClearButtonClick={() => setSearchText('')}
		/> -->

		Implement TextField
	</Box>
{/if}

<Box as={hasMultipleSections ? 'ul' : 'div'} role={elementRole} tabIndex={elementTabIndex}>
	{@render sectionMarkup()}
</Box>

```

# components/action-list/components/action-list-item/action-list-item.svelte

```svelte
<script lang="ts">
	import type { ItemProps } from '../../types.ts';
	import styles from '../../action-list.module.css';
	import { classNames } from '$utilities/css.js';
	import Box from '$lib/components/box/box.svelte';
	import InlineStack from '$lib/components/inline-stack/inline-stack.svelte';
	import Icon from '$lib/components/icon/icon.svelte';
	import Text from '$lib/components/text/text.svelte';
	import Badge from '$lib/components/badge/badge.svelte';
	import UnstyledLink from '$lib/components/button/unstyled-link.svelte';

	let {
		id,
		badge,
		content,
		accessibilityLabel,
		helpText,
		url,
		onAction,
		onMouseEnter,
		icon,
		image,
		prefix,
		suffix,
		disabled,
		external,
		destructive,
		ellipsis,
		truncate,
		active,
		role,
		variant = 'default'
	}: ItemProps = $props();

	const className = $derived(
		classNames(
			styles.Item,
			disabled && styles.disabled,
			destructive && styles.destructive,
			active && styles.active,
			variant === 'default' && styles.default,
			variant === 'indented' && styles.indented,
			variant === 'menu' && styles.menu
		)
	);
</script>

{#snippet contentWrapper()}
	<UnstyledLink url={disabled ? undefined : url} {external}>
		<Box width="100%">
			<InlineStack blockAlign="center" gap="150" wrap={false}>
				{#if prefix}
					<span class={styles.Prefix}>{prefix}</span>
				{:else if icon}
					<span class={styles.Prefix}>
						<Icon source={icon} />
					</span>
				{:else if image}
					<span role="presentation" class={styles.Prefix} style="background-image: url({image})"
					></span>
				{/if}
				{#if content}
					{#if truncate}
						<Text as="span" truncate>
							{content}
						</Text>
					{:else if ellipsis}
						<Text as="span" truncate>
							{content}â€¦
						</Text>
					{:else}
						{content}
					{/if}
				{/if}
				{#if badge}
					<span class={styles.Suffix}>
						<Badge children={badge.content} tone={badge.tone} />
					</span>
				{/if}
				{#if suffix}
					<Box>
						<span class={styles.Suffix}>{suffix}</span>
					</Box>
				{/if}
			</InlineStack>
		</Box>
	</UnstyledLink>
{/snippet}

{#if url}
	{@render contentWrapper()}
{:else}
	<button
		{id}
		type="button"
		class={className}
		{disabled}
		aria-label={accessibilityLabel}
		onclick={onAction}
		{role}
		onmouseenter={onMouseEnter}
	>
		{@render contentWrapper()}
	</button>
{/if}

```

# components/action-list/components/action-list-section/action-list-section.svelte

```svelte
<script lang="ts">
	import Box from '$lib/components/box/box.svelte';
	import type { ActionListItemDescriptor } from '$utilities/types.js';
	import type { SectionProps } from '../../types.js';
	import Text from '$lib/components/text/text.svelte';
	import ActionListItem from '../action-list-item/action-list-item.svelte';
	import InlineStack from '$lib/components/inline-stack/inline-stack.svelte';
	import BlockStack from '$lib/components/block-stack/block-stack.svelte';

	let { section, hasMultipleSections, isFirst, actionRole, onActionAnyItem }: SectionProps =
		$props();

	const handleAction = (itemOnAction: ActionListItemDescriptor['onAction']) => {
		return () => {
			if (itemOnAction) {
				itemOnAction();
			}
			if (onActionAnyItem) {
				onActionAnyItem();
			}
		};
	};

	let sectionRole = $derived(() => {
		switch (actionRole) {
			case 'option':
				return 'presentation';
			case 'menuitem':
				return !hasMultipleSections ? 'menu' : 'presentation';
			default:
				return undefined;
		}
	});
</script>

{#snippet titleMarkup()}
	{#if section.title}
		<Box
			paddingBlockStart="300"
			paddingBlockEnd="100"
			paddingInlineStart="300"
			paddingInlineEnd="300"
		>
			<Text as="p" variant="headingSm">
				{section.title}
			</Text>
		</Box>
	{/if}
{/snippet}

{#snippet actionItemMarkup(item: ActionListItemDescriptor)}
	<ActionListItem
		content={item.content}
		onAction={handleAction(item.onAction)}
		role={actionRole}
		helpText={item.helpText}
		{...item}
	/>
{/snippet}

{#snippet actionMarkup(items: ActionListItemDescriptor[])}
	{#each items as item, index}
		<Box as="li" role={actionRole === 'menuitem' ? 'presentation' : undefined}>
			<InlineStack wrap={false}>{@render actionItemMarkup(item)}</InlineStack>
		</Box>
	{/each}
{/snippet}

{#snippet sectionMarkup()}
	{@render titleMarkup()}
	<Box
		as="div"
		padding="150"
		{...hasMultipleSections && { paddingBlockStart: '0' }}
		tabIndex={!hasMultipleSections ? -1 : undefined}
	>
		<BlockStack gap="050" as="ul" {...sectionRole() && { role: sectionRole() }}>
			{@render actionMarkup(section.items)}
		</BlockStack>
	</Box>
{/snippet}

{#if hasMultipleSections}
	<Box
		as="li"
		role="presentation"
		borderColor="border-secondary"
		{...!isFirst && { borderBlockStartWidth: '025' }}
		{...!section.title && {
			paddingBlockStart: '150'
		}}
	>
		{@render sectionMarkup()}
	</Box>
{:else}
	{@render sectionMarkup()}
{/if}

```

# components/action-list/index.ts

```ts
import ActionListComponent from "./action-list.svelte";
import ActionListItemComponent from "./components/action-list-item/action-list-item.svelte";
import ActionListSectionComponent from "./components/action-list-section/action-list-section.svelte";

type ActionListCompoundType = typeof ActionListComponent & {
	Item: typeof ActionListItemComponent;
	Section: typeof ActionListSectionComponent;
};

const ActionList = ActionListComponent as ActionListCompoundType;

ActionList.Item = ActionListItemComponent;
ActionList.Section = ActionListSectionComponent;

export default ActionList;


```

# components/action-list/types.ts

```ts
import type { ActionListItemDescriptor, ActionListSection } from "$utilities/types.js";

export interface ActionListProps {
    /** Collection of actions for list */
    items?: readonly ActionListItemDescriptor[];
    /** Collection of sectioned action items */
    sections?: readonly ActionListSection[];
    /** Defines a specific role attribute for each action in the list */
    actionRole?: 'menuitem' | string;
    /** Allow users to filter items in the list. Will only show if more than 8 items in the list. The item content of every items must be a string for this to work */
    allowFiltering?: boolean;
    /** Filter label used as a placeholder in the search field */
    filterLabel?: string;
    /** Callback when any item is clicked or keypressed */
    onActionAnyItem?: ActionListItemDescriptor['onAction'];
}

export type ItemProps = ActionListItemDescriptor;

export interface SectionProps {
    /** Section of action items */
    section: ActionListSection;
    /** Should there be multiple sections */
    hasMultipleSections: boolean;
    /** Defines a specific role attribute for each action in the list */
    actionRole?: 'option' | 'menuitem' | string;
    /** Callback when any item is clicked or keypressed */
    onActionAnyItem?: ActionListItemDescriptor['onAction'];
    /** Whether it is the first in a group of sections */
    isFirst?: boolean;
}

export const FILTER_ACTIONS_THRESHOLD = 8;
```

# components/action-menu/action-menu.module.css

```css
.ActionMenu {
    width: 100%;
    display: flex;
    justify-content: flex-end;

    @media print {
        /* stylelint-disable-next-line declaration-no-important -- Enforce print styles */
        display: none !important;
    }
}
```

# components/action-menu/action-menu.svelte

```svelte
<script lang="ts">
	import { classNames } from '$utilities/css.js';
	import type { ActionListSection, MenuGroupDescriptor } from '$utilities/types.js';
	import styles from './action-menu.module.css';
	import Actions from './components/actions/actions.svelte';
	import RollupActions from './components/rollup-actions/rollup-actions.svelte';
	import type { ActionMenuProps } from './types.js';
	let {
		actions = [],
		groups = [],
		rollup,
		rollupActionsLabel,
		onActionRollup
	}: ActionMenuProps = $props();

	function convertGroupToSection({
		title,
		actions,
		disabled
	}: MenuGroupDescriptor): ActionListSection {
		return {
			title,
			items: actions.map((action) => ({
				...action,
				disabled: disabled || action.disabled
			}))
		};
	}

	const actionMenuClassNames = $derived(classNames(styles.ActionMenu, rollup && styles.rollup));
	const rollupSections = $derived(groups.map((group) => convertGroupToSection(group)));
</script>

{#if actions.length > 0 || groups.length > 0}
	<div class={actionMenuClassNames}>
		{#if rollup}
			<RollupActions
				accessibilityLabel={rollupActionsLabel}
				items={actions}
				sections={rollupSections}
			/>
		{:else}
			<Actions {actions} {groups} {onActionRollup} />
		{/if}
	</div>
{/if}

```

# components/action-menu/components/actions/actions.module.css

```css
.ActionsLayoutOuter {
    position: relative;
    width: 100%;
}

.ActionsLayout {
    display: flex;
    flex-wrap: wrap;
    align-items: center;
    justify-content: flex-end;
    flex: 1 1 auto;
    gap: var(--p-space-200);

    >* {
        flex: 0 0 auto;
    }
}

.ActionsLayout--measuring {
    visibility: hidden;
    height: 0;
}

.ActionsLayoutMeasurer {
    position: absolute;
    display: flex;
    flex-wrap: wrap;
    align-items: center;
    justify-content: flex-end;
    flex: 1 1 auto;
    gap: 0;
    padding: 0;
    visibility: hidden;
    height: 0;

    >* {
        flex: 0 0 auto;
    }
}
```

# components/action-menu/components/actions/actions.svelte

```svelte
<script lang="ts">
	import { classNames } from '$utilities/css.js';
	import type {
		ActionListItemDescriptor,
		ActionListSection,
		MenuActionDescriptor,
		MenuGroupDescriptor
	} from '$utilities/types.js';
	import MenuGroup from '../menu-group/menu-group.svelte';
	import SecondaryAction from '../secondary-action/secondary-action.svelte';
	import styles from './actions.module.css';
	import ActionsMeasurer from './components/actions-measurer/actions-measurer.svelte';
	import type { ActionsMeasurements } from './components/actions-measurer/types.js';
	import type { ActionsState, Props } from './types.js';
	import { getVisibleAndHiddenActionsIndices } from './utilities.js';
	let { actions, groups, onActionRollup }: Props = $props();
	let rollupActiveRef = $state<boolean | null>(null);
	let activeMenuGroup = $state<string | undefined>();
	const initialState: ActionsState = {
		disclosureWidth: 0,
		containerWidth: Infinity,
		actionsWidths: [],
		visibleActions: [],
		hiddenActions: [],
		visibleGroups: [],
		hiddenGroups: [],
		hasMeasured: false
	};

	let actionState = $state<ActionsState>(initialState);

	const defaultRollupGroup: MenuGroupDescriptor = {
		title: 'More Actions',
		actions: []
	};

	const handleMenuGroupToggle = (group: string) => {
		activeMenuGroup = activeMenuGroup ? undefined : group;
	};

	const handleMenuGroupClose = () => {
		activeMenuGroup = undefined;
	};

	const actionsOrDefault = $derived(actions ?? []);
	const groupsOrDefault = $derived(groups ?? []);

	$effect(() => {
		if (actionState.containerWidth === 0) {
			return;
		}

		const { visibleActions, visibleGroups, hiddenActions, hiddenGroups } =
			getVisibleAndHiddenActionsIndices(
				actionsOrDefault,
				groupsOrDefault,
				actionState.disclosureWidth,
				actionState.actionsWidths,
				actionState.containerWidth
			);

		actionState.visibleActions = visibleActions;
		actionState.hiddenActions = hiddenActions;
		actionState.visibleGroups = visibleGroups;
		actionState.hiddenGroups = hiddenGroups;
		actionState.hasMeasured = actionState.containerWidth !== Infinity;
	});

	const groupsToFilter = $derived.by(() => {
		return actionState.hiddenGroups.length > 0 || actionState.hiddenActions.length > 0
			? [...groupsOrDefault, defaultRollupGroup]
			: [...groupsOrDefault];
	});

	const filteredGroups = $derived.by(() => {
		return groupsToFilter.filter((group, index) => {
			const hasNoGroupsProp = groupsOrDefault.length === 0;
			const isVisibleGroup = actionState.visibleGroups.includes(index);
			const isDefaultGroup = group === defaultRollupGroup;

			if (hasNoGroupsProp) {
				return actionState.hiddenActions.length > 0;
			}

			if (isDefaultGroup) {
				return true;
			}

			return isVisibleGroup;
		});
	});

	const hiddenActionObjects = $derived.by(() => {
		return actionState.hiddenActions
			.map((index) => actionsOrDefault[index])
			.filter((action) => action != null);
	});

	const hiddenGroupObjects = $derived.by(() => {
		return actionState.hiddenGroups
			.map((index) => groupsOrDefault[index])
			.filter((group) => group != null);
	});


	function isMenuGroup(
		actionOrMenuGroup: MenuGroupDescriptor | MenuActionDescriptor
	): actionOrMenuGroup is MenuGroupDescriptor {
		return 'title' in actionOrMenuGroup;
	}

	const handleMeasurement = (measurements: ActionsMeasurements) => {
		const { hiddenActionsWidths: actionsWidths, containerWidth, disclosureWidth } = measurements;

		const { visibleActions, hiddenActions, visibleGroups, hiddenGroups } =
			getVisibleAndHiddenActionsIndices(
				actionsOrDefault,
				groupsOrDefault,
				disclosureWidth,
				actionsWidths,
				containerWidth
			);

		if (onActionRollup) {
			const isRollupActive = hiddenActions.length > 0 || hiddenGroups.length > 0;
			if (rollupActiveRef !== isRollupActive) {
				onActionRollup(isRollupActive);
				rollupActiveRef = isRollupActive;
			}
		}

		actionState = {
			visibleActions,
			hiddenActions,
			visibleGroups,
			hiddenGroups,
			actionsWidths,
			containerWidth,
			disclosureWidth,
			hasMeasured: true
		};
	};
</script>

{#snippet actionsMarkup()}
	{@const filteredActions = actionsOrDefault.filter((_, index) => {
		if (!actionState.visibleActions.includes(index)) {
			return false;
		}

		return true;
	})}

	{#each filteredActions as action}
		{@const { content, onAction, ...rest } = action}

		<SecondaryAction onClick={onAction} {...rest}>
			{content}
		</SecondaryAction>
	{/each}
{/snippet}

{#snippet groupsMarkup()}
	{#each filteredGroups as group}
		{@const isDefaultGroup = group === defaultRollupGroup}
		{@const { title, actions: groupActions, ...rest } = group}

		{#if !isDefaultGroup}
			{#if groupActions && groupActions.length > 0}
				<MenuGroup
					{title}
					active={title === activeMenuGroup}
					actions={groupActions}
					{...rest}
					onOpen={() => handleMenuGroupToggle(title)}
					onClose={handleMenuGroupClose}
				/>
			{/if}
		{:else}
			{@const allHiddenItems = [...hiddenActionObjects, ...hiddenGroupObjects]}
			{@const [finalRolledUpActions, finalRolledUpSectionGroups] = allHiddenItems.reduce(
				([actions, sections]: [MenuActionDescriptor[], ActionListSection[]], action) => {
					if (isMenuGroup(action)) {
						sections.push({
							title: action.title,
							items: action.actions.map((sectionAction) => ({
								...sectionAction,
								disabled: action.disabled || sectionAction.disabled
							}))
						});
					} else {
						actions.push(action);
					}

					return [actions, sections];
				},
				[[], []]
			)}

			{#if finalRolledUpActions.length > 0 || finalRolledUpSectionGroups.length > 0}
				<MenuGroup
					{title}
					active={title === activeMenuGroup}
					actions={[...finalRolledUpActions, ...groupActions]}
					sections={finalRolledUpSectionGroups}
					{...rest}
					onOpen={handleMenuGroupToggle}
					onClose={handleMenuGroupClose}
				/>
			{/if}
		{/if}
	{/each}
{/snippet}

{#snippet actionsMeasurer()}
	<ActionsMeasurer {actions} {groups} {handleMeasurement} />
{/snippet}

<div class={styles.ActionsLayoutOuter}>
	{@render actionsMeasurer()}
	<div
		class={classNames(
			styles.ActionsLayout,
			!actionState.hasMeasured && styles['ActionsLayout--measuring']
		)}
	>
		{@render actionsMarkup()}
		{@render groupsMarkup()}
	</div>
</div>

```

# components/action-menu/components/actions/components/actions-measurer/actions-measurer.svelte

```svelte
<script lang="ts">
	import type { MenuGroupDescriptor } from '$utilities/types.js';
	import { onDestroy, onMount } from 'svelte';
	import SecondaryAction from '../../../secondary-action/secondary-action.svelte';
	import styles from '../../actions.module.css';
	import { ACTION_SPACING, type ActionsMeasurerProps } from './types.js';
	import { browser } from '$app/environment';

	let {
		actions = [],
		groups = [],
		handleMeasurement: handleMeasurementProp
	}: ActionsMeasurerProps = $props();

	let defaultRollupGroup: MenuGroupDescriptor = {
		title: 'More actions',
		actions: []
	};

	const handleMeasurement = (containerNode: HTMLDivElement) => {
		const performMeasurement = () => {
			if (!containerNode) {
				return;
			}

			const containerWidth = containerNode.offsetWidth;
			const hiddenActionNodes = containerNode.children;
			const hiddenActionNodesArray = Array.from(hiddenActionNodes);
			const hiddenActionsWidths = hiddenActionNodesArray.map((node) => {
				const buttonWidth = Math.ceil(node.getBoundingClientRect().width);
				return buttonWidth + ACTION_SPACING;
			});
			const disclosureWidth = hiddenActionsWidths.pop() || 0;
			handleMeasurementProp({
				containerWidth,
				disclosureWidth,
				hiddenActionsWidths
			});
		};

		performMeasurement();

		const observer = new ResizeObserver((entries) => {
			// We are observing containerNode, so entries[0] should be it.
			if (entries && entries[0]) {
				const newWidth = entries[0].contentRect.width;
				performMeasurement();
			}
		});

		observer.observe(containerNode);
		return {
			destroy() {
				observer.disconnect();
			}
		};
	};
</script>

{#snippet activator()}
	<SecondaryAction disclosure>{defaultRollupGroup.title}</SecondaryAction>
{/snippet}

{#snippet actionsMarkup()}
	{#each actions as action}
		{@const { content, onAction, ...rest } = action}

		<SecondaryAction onClick={onAction} {...rest}>
			{content}
		</SecondaryAction>
	{/each}
{/snippet}

{#snippet groupsMarkup()}
	{#each groups as group}
		{@const { title, icon } = group}

		<SecondaryAction disclosure {icon}>
			{title}
		</SecondaryAction>
	{/each}
{/snippet}

<div class={styles.ActionsLayoutMeasurer} use:handleMeasurement>
	{@render actionsMarkup()}
	{@render groupsMarkup()}
	{@render activator()}
</div>

```

# components/action-menu/components/actions/components/actions-measurer/types.ts

```ts
import type { MenuActionDescriptor, MenuGroupDescriptor } from "$utilities/types.js";

export interface ActionsMeasurements {
    containerWidth: number;
    disclosureWidth: number;
    hiddenActionsWidths: number[];
}

export interface ActionsMeasurerProps {
    /** Collection of page-level secondary actions */
    actions?: MenuActionDescriptor[];
    /** Collection of page-level action groups */
    groups?: MenuGroupDescriptor[];
    handleMeasurement(measurements: ActionsMeasurements): void;
}

export const ACTION_SPACING = 8;
```

# components/action-menu/components/actions/types.ts

```ts
import type { MenuActionDescriptor, MenuGroupDescriptor } from "$utilities/types.js";

export interface Props {
    /** Collection of page-level secondary actions */
    actions?: MenuActionDescriptor[];
    /** Collection of page-level action groups */
    groups?: MenuGroupDescriptor[];
    /** Callback that returns true when secondary actions are rolled up into action groups, and false when not */
    onActionRollup?(hasRolledUp: boolean): void;
}

export interface ActionsState {
    visibleActions: number[];
    hiddenActions: number[];
    visibleGroups: number[];
    hiddenGroups: number[];
    actionsWidths: number[];
    containerWidth: number;
    disclosureWidth: number;
    hasMeasured: boolean;
}
```

# components/action-menu/components/actions/utilities.ts

```ts
export function getVisibleAndHiddenActionsIndices(
    actions: any[] = [],
    groups: any[] = [],
    disclosureWidth: number,
    actionsWidths: number[],
    containerWidth: number,
) {
    const sumTabWidths = actionsWidths.reduce((sum, width) => sum + width, 0);
    const arrayOfActionsIndices = actions.map((_, index) => {
        return index;
    });
    const arrayOfGroupsIndices = groups.map((_, index) => {
        return index;
    });

    const visibleActions: number[] = [];
    const hiddenActions: number[] = [];
    const visibleGroups: number[] = [];
    const hiddenGroups: number[] = [];

    if (containerWidth > sumTabWidths) {
        visibleActions.push(...arrayOfActionsIndices);
        visibleGroups.push(...arrayOfGroupsIndices);
    } else {
        let accumulatedWidth = 0;

        arrayOfActionsIndices.forEach((currentActionsIndex) => {
            const currentActionsWidth = actionsWidths[currentActionsIndex];

            if (
                accumulatedWidth + currentActionsWidth >=
                containerWidth - disclosureWidth
            ) {
                hiddenActions.push(currentActionsIndex);
                return;
            }

            visibleActions.push(currentActionsIndex);
            accumulatedWidth += currentActionsWidth;
        });

        arrayOfGroupsIndices.forEach((currentGroupsIndex) => {
            const currentActionsWidth =
                actionsWidths[currentGroupsIndex + actions.length];

            if (
                accumulatedWidth + currentActionsWidth >=
                containerWidth - disclosureWidth
            ) {
                hiddenGroups.push(currentGroupsIndex);
                return;
            }

            visibleGroups.push(currentGroupsIndex);
            accumulatedWidth += currentActionsWidth;
        });
    }

    return {
        visibleActions,
        hiddenActions,
        visibleGroups,
        hiddenGroups,
    };
}
```

# components/action-menu/components/menu-group/menu-group.module.css

```css
.Details {
    margin-top: calc(-1 * var(--p-space-400));
    padding: var(--p-space-400);
}
```

# components/action-menu/components/menu-group/menu-group.svelte

```svelte
<script lang="ts">
	import ActionList from '$lib/components/action-list/action-list.svelte';
	import Popover from '$lib/components/popover/index.js';
	import SecondaryAction from '../secondary-action/secondary-action.svelte';
	import styles from './menu-group.module.css';
	import type { MenuGroupProps } from './types.js';
	let {
		accessibilityLabel,
		active,
		actions,
		details,
		title,
		icon,
		disabled,
		onClick,
		onClose,
		onOpen,
		sections
	}: MenuGroupProps = $props();

	const handleClose = () => {
		onClose?.(title);
	};

	const handleOpen = () => {
		onOpen?.(title);
	};

	const handleClick = () => {
		if (onClick) {
			onClick(handleOpen);
		} else {
			handleOpen();
		}
	};
</script>

{#snippet popoverActivator()}
	<SecondaryAction disclosure {disabled} {icon} {accessibilityLabel} onClick={handleClick}>
		{title}
	</SecondaryAction>
{/snippet}

<Popover
	active={Boolean(active)}
	preferredAlignment="left"
	onClose={handleClose}
	hideOnPrint>
	{#snippet trigger()}
		{@render popoverActivator()}
	{/snippet}

	<ActionList items={actions} {sections} onActionAnyItem={handleClose} />
	
    {#if details}
        <div class={styles.Details}>{details}</div>
    {/if}
</Popover>

```

# components/action-menu/components/menu-group/types.ts

```ts
import type { ActionListSection, MenuGroupDescriptor } from "$utilities/types.js";

export interface MenuGroupProps extends MenuGroupDescriptor {
    /** Visually hidden menu description for screen readers */
    accessibilityLabel?: string;
    /** Whether or not the menu is open */
    active?: boolean;
    /** Callback when the menu is clicked */
    onClick?(openActions: () => void): void;
    /** Callback for opening the MenuGroup by title */
    onOpen(title: string): void;
    /** Callback for closing the MenuGroup by title */
    onClose(title: string): void;
    /** Collection of sectioned action items */
    sections?: readonly ActionListSection[];
}
```

# components/action-menu/components/rollup-actions/rollup-actions.module.css

```css
.RollupActivator {
    text-align: right;

    /* stylelint-disable-next-line selector-no-qualifying-type -- override `.iconOnly` negative margins */
    button[type='button'] {
        background: var(--p-color-bg-fill-tertiary);
        border-radius: var(--p-border-radius-200);
        border: none;
        box-shadow: none;
        margin: 0;

        /* stylelint-disable-next-line selector-max-specificity -- apply active styles */
        &:active {
            background: var(--p-color-bg-fill-tertiary-active);
        }

        /* stylelint-disable-next-line selector-max-specificity -- apply focus styles */
        &:focus:not(:active) {
            /* stylelint-disable-next-line polaris/border/polaris/at-rule-disallowed-list -- button overrides */
            @mixin no-focus-ring;
            outline: var(--p-border-width-050) solid var(--p-color-border-focus);
            outline-offset: var(--p-space-050);
            background: var(--p-color-bg-fill-tertiary-active);
        }

        /* stylelint-disable-next-line selector-max-specificity -- apply hover styles */
        &:hover {
            background: var(--p-color-bg-fill-tertiary-hover);
        }
    }
}
```

# components/action-menu/components/rollup-actions/rollup-actions.svelte

```svelte
<script lang="ts">
	import ActionList from '$lib/components/action-list/action-list.svelte';
	import Button from '$lib/components/button/button.svelte';
	import Popover from '$lib/components/popover/index.js';
	import { UseToggle } from '$lib/use/use-toggle.svelte.js';
	import styles from './rollup-actions.module.css';
	import type { RollupActionsProps } from './types.js';
	import MenuHorizontalIcon from '@shopify/polaris-icons/dist/svg/MenuHorizontalIcon.svg?component';

	let { accessibilityLabel, items = [], sections = [] }: RollupActionsProps = $props();
	const rollupOpen = new UseToggle(false);
	const toggleRollupOpen = rollupOpen.toggle;
</script>

{#if items.length > 0 || sections.length > 0}
	{#snippet activatorMarkup()}
		<div class={styles.RollupActivator}>
			<Button
				icon={MenuHorizontalIcon}
				accessibilityLabel="View actions"
				onClick={toggleRollupOpen}
			/>
		</div>
	{/snippet}

	<Popover
		active={rollupOpen.value}
		preferredAlignment="right"
		onClose={toggleRollupOpen}
		hideOnPrint>
		{#snippet trigger()}
			{@render activatorMarkup()}
		{/snippet}
		<ActionList {items} {sections} onActionAnyItem={toggleRollupOpen} />
	</Popover>
{/if}

```

# components/action-menu/components/rollup-actions/types.ts

```ts
import type { ActionListItemDescriptor, ActionListSection } from "$utilities/types.js";

export interface RollupActionsProps {
    /** Accessibilty label */
    accessibilityLabel?: string;
    /** Collection of actions for the list */
    items?: ActionListItemDescriptor[];
    /** Collection of sectioned action items */
    sections?: ActionListSection[];
}
```

# components/action-menu/components/secondary-action/secondary-action.module.css

```css
.SecondaryAction {
    /* stylelint-disable-next-line -- Polaris component custom properties */
    --pc-secondary-action-button-spacing: var(--p-space-300);

    /* stylelint-disable declaration-no-important -- generated by polaris-migrator DO NOT COPY */
    a,
    button {
        /* stylelint-disable -- generated by polaris-migrator DO NOT COPY */
        @mixin focus-ring base, 1px;
        --pc-button-padding-block: var(--p-space-100);
        --pc-button-padding-inline: var(--p-space-300);
        /* stylelint-enable */
        background: var(--p-color-bg-fill-tertiary) !important;
        box-shadow: none !important;
        border: none;
        border-radius: var(--p-border-radius-200) !important;
        min-height: 28px;

        &:is(:hover, :focus) {
            background-color: var(--p-color-bg-fill-tertiary-hover) !important;
        }

        /* stylelint-disable-next-line selector-no-qualifying-type -- add expanded styling */
        &:active,
        &[aria-expanded='true'] {
            background-color: var(--p-color-bg-fill-tertiary-active) !important;
            box-shadow: var(--p-shadow-inset-200) !important;
        }

        &:focus-visible {
            /* stylelint-disable-next-line polaris/border/polaris/at-rule-disallowed-list -- focus styles */
            @mixin no-focus-ring;
            outline: var(--p-border-width-050) solid var(--p-color-border-focus);
            outline-offset: var(--p-space-050);
        }

        /* stylelint-disable-next-line selector-no-qualifying-type -- apply disabled styles */
        &[aria-disabled='true'] {
            background-color: var(--p-color-bg-fill-disabled) !important;
        }

        @media (--p-breakpoints-md-up) {
            border: none !important;
            /* stylelint-disable-next-line -- generated by polaris-migrator DO NOT COPY */
            @mixin focus-ring base, 0;
        }
    }

    &.critical {

        a,
        button {
            color: var(--p-color-text-critical) !important;

            /* stylelint-disable-next-line selector-max-combinators, selector-max-type -- override svg fill */
            svg {
                fill: var(--p-color-text-critical);
            }

            /* stylelint-disable-next-line selector-max-specificity -- apply hover styles */
            &:is(:hover, :focus) {
                background-color: var(--p-color-bg-fill-tertiary-hover) !important;
            }

            /* stylelint-disable-next-line selector-max-specificity -- apply focus/active styles */
            &:active {
                background-color: var(--p-color-bg-fill-tertiary-active) !important;
            }
        }
    }
}
```

# components/action-menu/components/secondary-action/secondary-action.svelte

```svelte
<script lang="ts">
	import Button from '$lib/components/button/button.svelte';
	import Tooltip from '$lib/components/tooltip/tooltip.svelte';
	import { classNames } from '$utilities/css.js';
	import styles from './secondary-action.module.css';
	import type { SecondaryAction } from './types.js';
	let { children, tone, helpText, onAction, destructive, ...rest }: SecondaryAction = $props();
</script>

{#snippet buttonMarkup()}
	<Button onClick={onAction} tone={destructive ? 'critical' : undefined} {...rest}>
		{@render children?.()}
	</Button>
{/snippet}

{#snippet actionMarkup()}
	{#if helpText}
		<Tooltip preferredPosition="bottom" content={helpText}>
			{#snippet trigger()}
				{@render buttonMarkup()}
			{/snippet}
		</Tooltip>
	{:else}
		{@render buttonMarkup()}
	{/if}
{/snippet}

<div class={classNames(styles.SecondaryAction, tone === 'critical' && styles.critical)}>
	{@render actionMarkup()}
</div>

```

# components/action-menu/components/secondary-action/types.ts

```ts
import type { ButtonProps } from "$lib/components/button/button.types.js";
import type { VueNode } from "$utilities/types.js";

export interface SecondaryAction extends ButtonProps {
    helpText?: VueNode;
    destructive?: boolean;
    onAction?(): void;
}
```

# components/action-menu/index.ts

```ts
import ActionMenu from "./action-menu.svelte";

export default ActionMenu;
```

# components/action-menu/types.ts

```ts
import type { MenuActionDescriptor, MenuGroupDescriptor } from "$utilities/types.js";

// Type definitions for action-menu
export interface ActionMenuProps {
    /** Collection of page-level secondary actions */
    actions?: MenuActionDescriptor[];
    /** Collection of page-level action groups */
    groups?: MenuGroupDescriptor[];
    /** Roll up all actions into a Popover > ActionList */
    rollup?: boolean;
    /** Label for rolled up actions activator */
    rollupActionsLabel?: string;
    /** Callback that returns true when secondary actions are rolled up into action groups, and false when not */
    onActionRollup?(hasRolledUp: boolean): void;
}

export function hasGroupsWithActions(groups: ActionMenuProps['groups'] = []) {
    return groups.length === 0
        ? false
        : groups.some((group) => group.actions.length > 0);
}
```

# components/after-initial-mount/after-initial-mount.module.css

```css
.container {
  /* Add your styles for after-initial-mount here */
}
```

# components/after-initial-mount/after-initial-mount.svelte

```svelte
<script lang="ts">
  import styles from './after-initial-mount.module.css';
</script>

<div class={styles.container}>
  </div>

```

# components/after-initial-mount/types.ts

```ts
// Type definitions for after-initial-mount component
```

# components/app-provider/action-context-provider.svelte

```svelte
<script lang='ts'>
	import { ACTION_CONTEXT_KEY } from "$utilities/listbox/types.js";
	import { setContext } from "svelte";
	import { type Snippet } from "svelte";

    let { children, value }: { children?: Snippet, value?: boolean } = $props();
    
    setContext(ACTION_CONTEXT_KEY, () => value || false);
</script>

{@render children?.()}
```

# components/app-provider/app-provider.svelte

```svelte
<script lang="ts">
	import { setContext, onMount } from 'svelte';
	import { MEDIA_QUERY_CONTEXT_KEY, type MediaQueryState } from './types.js';

	let mediaQueryState = $state<MediaQueryState>({ 
		isNavigationCollapsed: false, 
		// isMobile: false,
	});

	setContext(MEDIA_QUERY_CONTEXT_KEY, () => mediaQueryState);

	onMount(() => { 
		if (typeof window !== 'undefined' && window.matchMedia) {
			// Example: Define the media query for when navigation should be considered collapsed
			// This is just an example, adjust the query to your needs.
			const navigationQuery = window.matchMedia('(max-width: 768px)');

			// Function to update the state
			const updateNavigationState = () => {
				mediaQueryState.isNavigationCollapsed = navigationQuery.matches;
			};

			// Listen for changes
			navigationQuery.addEventListener('change', updateNavigationState);

			// Set initial state
			updateNavigationState();

			// Cleanup listener when the component is destroyed
			return () => {
				navigationQuery.removeEventListener('change', updateNavigationState);
			};
		}
	});

	// Get the children slot prop to render content wrapped by this provider
	let { children } = $props(); // [Source 470, 485, 560]
</script>

{@render children()} 
```

# components/app-provider/combobox-list-box-context-provider.svelte

```svelte
<script lang='ts'>
    import { setContext, type Snippet } from 'svelte';
    import { COMBOBOX_LIST_BOX_CONTEXT_KEY, type ComboboxListboxType } from '$utilities/combobox/types.js';
    let { children, value }: { children?: Snippet, value: ComboboxListboxType } = $props();
    setContext(COMBOBOX_LIST_BOX_CONTEXT_KEY, () => value);
</script>

{@render children?.()}

```

# components/app-provider/combobox-list-box-option-context-provider.svelte

```svelte
<script lang='ts'>
    import { setContext, type Snippet } from 'svelte';
    import { COMBOBOX_LIST_BOX_OPTION_CONTEXT_KEY, type ComboboxListboxOptionType } from '$utilities/combobox/types.js';
    let { children, value }: { children?: Snippet, value: ComboboxListboxOptionType } = $props();
    setContext(COMBOBOX_LIST_BOX_OPTION_CONTEXT_KEY, () => value);
</script>
{@render children?.()}
```

# components/app-provider/combobox-text-filed-context-provider.svelte

```svelte
<script lang='ts'>
    import { setContext, type Snippet } from 'svelte';
    import { COMBOBOX_TEXT_FIELD_CONTEXT_KEY, type ComboboxTextFieldType } from '$utilities/combobox/types.js';
    let { children, value }: { children?: Snippet, value?: ComboboxTextFieldType } = $props();
    setContext(COMBOBOX_TEXT_FIELD_CONTEXT_KEY, () => value);
</script>
{@render children?.()}
```

# components/app-provider/ephemeral-presence-manager.svelte

```svelte
<script lang="ts">
	import { setContext } from 'svelte';
	import type { EphemeralPresenceKey, EphemeralPresenceManagerContextType } from './types.js';
	import { EPHEMERAL_PRESENCE_MANAGER_CONTEXT_KEY } from './types.js';
	import type { Snippet } from 'svelte';

	interface EphemeralPresenceManagerProps {
		children?: Snippet;
	}

	let { children }: EphemeralPresenceManagerProps = $props();

	type PresenceList = {
		[key in EphemeralPresenceKey]: boolean;
	};

	type PresenceCounter = {
		[key in EphemeralPresenceKey]: number;
	};

	const defaultState = {
		tooltip: 0,
		hovercard: 0
	};

	let presenceCounter = $state<PresenceCounter>(defaultState);

	const addPresence: EphemeralPresenceManagerContextType['addPresence'] = (key) => {
		presenceCounter = {
			...presenceCounter,
			[key]: presenceCounter[key] + 1
		};
	};

	const removePresence: EphemeralPresenceManagerContextType['removePresence'] = (key) => {
		presenceCounter = {
			...presenceCounter,
			[key]: presenceCounter[key] - 1
		};
	};

	const value = $derived.by(() => {
		const presenceList = Object.keys(presenceCounter).reduce((previousValue, currentValue) => {
			const [key, value] = currentValue;
			return {
				...previousValue,
				[key]: Number(value) >= 1
			};
		}, {} as PresenceList);

		return {
			presenceList,
			presenceCounter,
			addPresence,
			removePresence
		};
	});

	setContext(
		EPHEMERAL_PRESENCE_MANAGER_CONTEXT_KEY,
		() => value
	);

	$effect(() => {
		//console.log('Setting ephemeral presence manager context', value);
		setContext(
			EPHEMERAL_PRESENCE_MANAGER_CONTEXT_KEY,
			() => value
		);
	});
</script>

{@render children?.()}

```

# components/app-provider/filteraction-provider.svelte

```svelte
<script lang="ts">
	import { setContext } from 'svelte'; // [cite: 199]
	import type { Snippet } from 'svelte'; // For typing the children snippet [cite: 560]
	import { FILTER_ACTIONS_CONTEXT_KEY } from './types.js';

	// Define the props for this provider component
	interface Props {
		filterActions: boolean;
		children: Snippet; // In Svelte 5, children/slots are passed as snippets [cite: 560, 561]
	}

	const { filterActions, children }: Props = $props(); // [cite: 449, 470, 485]

	// Provide the 'filterActions' value using the defined context key.
	// The 'filterActions' prop itself is reactive if passed from a reactive source.
	setContext(FILTER_ACTIONS_CONTEXT_KEY, () => filterActions); // [cite: 200]
</script>

{@render children()}
```

# components/app-provider/i18n-provider.svelte

```svelte
<script lang='ts'>
    
</script>
```

# components/app-provider/index-context-provider.svelte

```svelte
<script lang='ts'>
	import { INDEX_CONTEXT_KEY } from "$utilities/index-provider/hooks.js";
	import { setContext, type Snippet } from "svelte";
    import type { IndexContextType } from "$utilities/index-provider/context.js";

    let { children, value }: { children?: Snippet, value: IndexContextType } = $props();

    setContext(INDEX_CONTEXT_KEY, () => value)
</script>

{@render children?.()}
```

# components/app-provider/index-row-context-provider.svelte

```svelte
<script lang='ts'>
	import { setContext, type Snippet } from 'svelte';
    import { INDEX_ROW_CONTEXT_KEY } from '$utilities/index-provider/hooks.js';
    import type { IndexRowContextType } from '$utilities/index-provider/context.js';

    let { children, value }: { children?: Snippet, value: IndexRowContextType } = $props();

    setContext(INDEX_ROW_CONTEXT_KEY, () => value)
</script>

{@render children?.()}
```

# components/app-provider/index-selection-change-context-provider.svelte

```svelte
<script lang='ts'>
    import { setContext, type Snippet } from 'svelte';
    import { INDEX_SELECTION_CHANGE_CONTEXT_KEY } from '$utilities/index-provider/hooks.js';
    import type { HandleSelectionChange } from '$utilities/index-provider/types.js';

    let { children, value }: { children?: Snippet, value: HandleSelectionChange } = $props();

    setContext(INDEX_SELECTION_CHANGE_CONTEXT_KEY, () => value)
</script>

{@render children?.()}
```

# components/app-provider/list-box-content-provider.svelte

```svelte
<script lang='ts'>
    import { LISTBOX_CONTEXT_KEY, type ListboxContextType } from '$utilities/listbox/types.js';
    import { setContext } from 'svelte';
    import { type Snippet } from 'svelte';
    
    let { children, value }: { children?: Snippet, value?: ListboxContextType } = $props();
    setContext(LISTBOX_CONTEXT_KEY, () => value);
</script>

{@render children?.()}
```

# components/app-provider/mappedaction-context-provider.svelte

```svelte
<script lang='ts'>
	import { MAPPED_ACTION_CONTEXT_KEY, type MappedActionContextType } from '$utilities/listbox/types.js';
	import { setContext, type Snippet } from 'svelte';

    let { value, children }: { value: MappedActionContextType; children?: Snippet } = $props();
    
    setContext(MAPPED_ACTION_CONTEXT_KEY, () => value);
</script>

{@render children?.()}
```

# components/app-provider/portals-context-provider.svelte

```svelte
<script lang="ts">
	import { PORTALS_MANAGER_CONTEXT_KEY } from '$lib/utilities/portals/types.js';
	import { setContext } from 'svelte';
	import { type Snippet } from 'svelte';
	import type { PortalsContainerElement } from '../popover/components/popover-overlay/types.js';

	let { container, children }: { container?: PortalsContainerElement; children: Snippet } =
		$props();

	setContext(PORTALS_MANAGER_CONTEXT_KEY, () => ({ container }));
</script>

{@render children?.()}

```

# components/app-provider/resourcelist-context-provider.svelte

```svelte
<script lang='ts'>
	import type { ResourceListContextType } from "$utilities/types.js";
	import { setContext, type Snippet } from "svelte";
	import { RESOURCE_LIST_CONTEXT_KEY } from "./types.js";

    let { children, value }: { children?: Snippet, value: ResourceListContextType } = $props();

    setContext(RESOURCE_LIST_CONTEXT_KEY, () => value);
</script>

{@render children?.()}
```

# components/app-provider/row-context-provider.svelte

```svelte
<script lang='ts'>
    import { setContext, type Snippet } from 'svelte';
    import { ROW_CONTEXT_KEY } from '$utilities/index-table/context.js';
    import type { RowContextType } from '$utilities/index-table/context.js';

    let { children, value }: { children?: Snippet, value: RowContextType } = $props();

    setContext(ROW_CONTEXT_KEY, () => value)
</script>

{@render children?.()}

```

# components/app-provider/row-hovered-context-provider.svelte

```svelte
<script lang='ts'>
    import { setContext, type Snippet } from 'svelte';
    import { ROW_HOVERED_CONTEXT_KEY } from '$utilities/index-table/context.js';

    let { children, value }: { children?: Snippet, value: boolean } = $props();

    setContext(ROW_HOVERED_CONTEXT_KEY, () => value)
</script>

{@render children?.()}
```

# components/app-provider/scroll-context-provider.svelte

```svelte
<script lang='ts'>
    import { setContext, type Snippet } from 'svelte';
    import { SCROLL_CONTEXT_KEY } from '$utilities/index-table/context.js';
    import type { ScrollContextType } from '$utilities/index-table/context.js';

    let { children, value }: { children?: Snippet, value: ScrollContextType } = $props();

    setContext(SCROLL_CONTEXT_KEY, () => value)
</script>

{@render children?.()}
```

# components/app-provider/scrollable-provider.svelte

```svelte
<script lang="ts">
	import { setContext } from 'svelte';
	import { SCROLLABLE_CONTEXT_KEY, type ScrollToPositionFn } from '$lib/utilities/contexts.js'; // Assuming you put the key in lib
	import { type Snippet } from 'svelte';
	import { prefersReducedMotion } from '../scrollable/types.js';

	let { children }: { children?: Snippet } = $props();

	let scrollElement: HTMLElement | undefined;

	const scrollTo = (scrollY: number, options: ScrollToOptions = {}) => {
		const optionsBehavior = options.behavior || 'smooth';
		const behavior = prefersReducedMotion() ? 'auto' : optionsBehavior;
		scrollElement?.scrollTo({ top: scrollY, behavior });
	};

	// This makes the `scrollTo` function available to all descendant components
	setContext<ScrollToPositionFn>(SCROLLABLE_CONTEXT_KEY, scrollTo);
</script>

<div bind:this={scrollElement}>
	{#if children}
		{@render children()}
	{/if}
</div>

```

# components/app-provider/stickymanager-provider.svelte

```svelte
<script lang="ts">
	import { setContext } from 'svelte';
	import { STICKY_MANAGER_CONTEXT_KEY } from '$lib/utilities/sticky-manager/context.js';
	import { type Snippet } from 'svelte';
	import type { StickyManager } from '$utilities/sticky-manager/sticky-manager.js';

	let { children, value }: { children?: Snippet, value: StickyManager } = $props();

	setContext(STICKY_MANAGER_CONTEXT_KEY, () => value);
</script>

{#if children}
	{@render children()}
{/if}
```

# components/app-provider/theme-context-provider.svelte

```svelte
<script lang='ts'>
	import { THEME_CONTEXT_KEY } from "$utilities/use-theme.js";
	import type { Theme } from "@shopify/polaris-tokens";
	import { setContext, type Snippet } from "svelte";

    let { value, children }: { value: Theme, children?: Snippet } = $props();
    
    setContext(THEME_CONTEXT_KEY, () => value);
</script>

{@render children?.()}
```

# components/app-provider/theme-name-context-provider.svelte

```svelte
<script lang='ts'>
    import { THEME_NAME_CONTEXT_KEY } from "$utilities/use-theme.js";
	import type { ThemeName } from "@shopify/polaris-tokens";
    import { setContext, type Snippet } from "svelte";

    let { children, value }: { children?: Snippet, value: ThemeName } = $props();

    setContext(THEME_NAME_CONTEXT_KEY, () => value);
</script>

{@render children?.()}
```

# components/app-provider/types.ts

```ts
export interface MediaQueryState {
    isNavigationCollapsed: boolean;
    // Add other media query states you might need, e.g., isMobile, isTablet, etc.
    // isMobile: boolean;
}

// Unique key for the Svelte context
export const MEDIA_QUERY_CONTEXT_KEY = 'MediaQueryContext';
export const FILTER_ACTIONS_CONTEXT_KEY = 'FilterActionsContext';
export const EPHEMERAL_PRESENCE_MANAGER_CONTEXT_KEY = 'EphemeralPresenceManagerContext';
export const RESOURCE_LIST_CONTEXT_KEY = 'ResourceListContext';

export type EphemeralPresenceKey = 'tooltip';

export interface EphemeralPresenceManagerContextType {
  presenceList: {
    [key in EphemeralPresenceKey]: boolean;
  };
  presenceCounter: {
    [key in EphemeralPresenceKey]: number;
  };
  addPresence: (key: EphemeralPresenceKey) => void;
  removePresence: (key: EphemeralPresenceKey) => void;
}
```

# components/app-provider/within-list-box-context-provider.svelte

```svelte
<script lang='ts'>
    import { setContext, type Snippet } from 'svelte';
    import { WITHIN_LISTBOX_CONTEXT_KEY } from '$utilities/listbox/types.js';
    
    let { children, value }: { children?: Snippet, value: boolean } = $props();
    setContext(WITHIN_LISTBOX_CONTEXT_KEY, () => value);
</script>
{@render children?.()}
```

# components/autocomplete/autocomplete.module.css

```css
.Loading {
    display: flex;
    justify-content: center;
    align-items: center;
    width: 100%;
    padding: var(--p-space-200) var(--p-space-400);
}

.SectionWrapper {
    >*:not(:first-child) {
        margin-top: var(--p-space-200);
    }
}
```

# components/autocomplete/autocomplete.svelte

```svelte
<script lang="ts">
	import type { OptionDescriptor } from '$utilities/types.js';
	import Combobox from '../combobox/index.js';
	import Listbox from '../listbox/index.js';
	import { AutoSelection } from '../listbox/types.js';
	import styles from './autocomplete.module.css';
	import MappedAction from './components/mapped-action/mapped-action.svelte';
	import MappedOption from './components/mapped-option/mapped-option.svelte';
	import { isSection, type AutocompleteProps } from './types.js';
	let {
		options,
		selected,
		textField,
		preferredPosition,
		listTitle,
		allowMultiple,
		loading,
		actionBefore,
		willLoadMoreResults,
		emptyState,
		onSelect,
		onLoadMoreResults
	}: AutocompleteProps = $props();

	const updateSelection = (newSelection: string) => {
		if (actionBefore && newSelection === actionBefore.content) {
			actionBefore.onAction && actionBefore.onAction();
			return;
		}

		if (allowMultiple) {
			if (selected.includes(newSelection)) {
				onSelect(selected.filter((option) => option !== newSelection));
			} else {
				onSelect([...selected, newSelection]);
			}
		} else {
			onSelect([newSelection]);
		}
	};

	const autoSelection = actionBefore ? AutoSelection.First : undefined;
</script>

{#snippet buildMappedOptionFromOption(options: OptionDescriptor[])}
	{#if options.length > 0}
		{#each options as option}
			<MappedOption
				{...option}
				selected={selected.includes(option.value)}
				singleSelection={!allowMultiple}
			/>
		{/each}
	{/if}
{/snippet}

{#snippet optionsMarkup()}
	{@const conditionalOptions = loading && !willLoadMoreResults ? [] : options}

	{#if isSection(conditionalOptions)}
		{@const noOptionsAvailable = conditionalOptions.every(({ options }) => options.length === 0)}

		{#if !noOptionsAvailable}
			<div class={styles.SectionWrapper}>
				{#each conditionalOptions as { options, title: sectionTitle }}
					<Listbox.Section divider={false}>
						{#snippet title()}
							<Listbox.Header>{sectionTitle}</Listbox.Header>
						{/snippet}
						{@render buildMappedOptionFromOption(options)}
					</Listbox.Section>
				{/each}
			</div>
		{/if}
	{:else if listTitle}
		<Listbox.Section divider={false}>
			{#snippet title()}
				<Listbox.Header>{listTitle}</Listbox.Header>
			{/snippet}
			{@render buildMappedOptionFromOption(conditionalOptions)}
		</Listbox.Section>
	{:else}
		{@render buildMappedOptionFromOption(conditionalOptions)}
	{/if}
{/snippet}

{#snippet loadingMarkup()}
	{#if loading}
		<Listbox.Loading accessibilityLabel={'Loading'} />
	{/if}
{/snippet}

{#snippet actionMarkup()}
	{#if actionBefore}
		<MappedAction {...actionBefore} />
	{/if}
{/snippet}

{#snippet emptyStateMarkup()}
	{#if options.length < 1 && !loading}
		{@render emptyState?.()}
	{/if}
{/snippet}

<Combobox
	activator={textField}
	{allowMultiple}
	onScrolledToBottom={onLoadMoreResults}
	{preferredPosition}
	willLoadMoreOptions={willLoadMoreResults}
>
	<Listbox {autoSelection} onSelect={updateSelection}>
		{@render actionMarkup()}
		{#if !loading || willLoadMoreResults}
			{@render optionsMarkup()}
		{/if}
		{@render loadingMarkup()}
		{@render emptyStateMarkup()}
	</Listbox>
</Combobox>

```

# components/autocomplete/components/mapped-action/mapped-action.module.css

```css
.ActionContainer {
    /* stylelint-disable -- Polaris component custom properties */
    --pc-mapped-actions-image-size: 20px;
    --pc-mapped-actions-item-min-height: var(--p-space-1000);
    --pc-mapped-actions-item-vertical-padding: calc((var(--pc-mapped-actions-item-min-height) - var(--p-font-line-height-500)) / 2);
    /* stylelint-enable */
    margin-bottom: var(--p-space-300);
}

[data-focused] {
    .Action {

        /* stylelint-disable-next-line -- generated by polaris-migrator DO NOT COPY */
        svg {
            fill: var(--p-color-icon);
        }

        &.destructive {
            background-color: var(--p-color-bg-surface-critical-active);
        }

        &:hover {
            background-color: transparent;
        }
    }
}

.Action {
    /* stylelint-disable-next-line -- generated by polaris-migrator DO NOT COPY */
    @mixin focus-ring base, 0, base;
    display: block;
    flex: 1;
    /* stylelint-disable-next-line -- generated by polaris-migrator DO NOT COPY */
    min-height: var(--pc-mapped-actions-item-min-height);
    text-align: left;
    cursor: pointer;
    /* stylelint-disable-next-line -- generated by polaris-migrator DO NOT COPY */
    padding: var(--pc-mapped-actions-item-vertical-padding) var(--p-space-200);
    /* stylelint-disable-next-line -- using pre-existing private pc token */
    margin: calc(-1 * var(--pc-mapped-actions-item-vertical-padding)) calc(-1 * var(--p-space-300));
    border-radius: var(--p-border-radius-200);

    &:hover {
        background-color: var(--p-color-bg-surface-hover);
        text-decoration: none;

        @media (-ms-high-contrast: active) {
            outline: var(--p-border-width-025) solid windowText;
        }
    }

    &.selected {
        background-color: var(--p-color-bg-surface-brand-selected);

        svg {
            fill: var(--p-color-icon-emphasis);
        }
    }

    &:active {
        background-color: var(--p-color-bg-surface-active);

        svg {
            fill: var(--p-color-icon-emphasis);
        }
    }

    &:focus-visible:not(:active) {
        /* stylelint-disable-next-line -- generated by polaris-migrator DO NOT COPY */
        @mixin focus-ring base, 0, focused;
    }

    &.destructive {
        color: var(--p-color-text-critical);

        svg {
            fill: var(--p-color-icon-critical);
        }

        &:hover {
            background-color: var(--p-color-bg-surface-critical-hover);
        }

        /* stylelint-disable-next-line selector-max-class -- generated by polaris-migrator DO NOT COPY */
        &:active,
        &.selected {
            background-color: var(--p-color-bg-surface-critical-active);
        }
    }

    &.disabled {
        background-image: none;
        color: var(--p-color-text-disabled);

        /* stylelint-disable-next-line selector-max-class, selector-max-specificity, selector-max-combinators -- generated by polaris-migrator DO NOT COPY */
        .Prefix svg,
        .Suffix svg {
            fill: var(--p-color-icon-disabled);
        }
    }
}

.Content {
    display: flex;
    align-items: center;
}

.Prefix {
    display: flex;
    flex: 0 0 auto;
    justify-content: center;
    align-items: center;
    /* stylelint-disable-next-line -- generated by polaris-migrator DO NOT COPY */
    height: var(--pc-mapped-actions-image-size);
    /* stylelint-disable-next-line -- generated by polaris-migrator DO NOT COPY */
    width: var(--pc-mapped-actions-image-size);
    border-radius: var(--p-border-radius-100);

    /* We need the negative margin to ensure that the image does not set
       the minimum height of the action item. */
    /* stylelint-disable -- generated by polaris-migrator DO NOT COPY */
    margin: calc(-0.5 * var(--pc-mapped-actions-image-size)) var(--p-space-400) calc(-0.5 * var(--pc-mapped-actions-image-size)) 0;
    margin-right: var(--p-space-200);
    /* stylelint-enable */
    background-size: cover;
    background-position: center center;

    svg {
        fill: var(--p-color-icon);
    }
}

.Suffix {
    margin-left: var(--p-space-400);

    svg {
        fill: var(--p-color-icon);
    }
}

.Text {
    min-width: 0;
    max-width: 100%;
    flex: 1 1 auto;
}
```

# components/autocomplete/components/mapped-action/mapped-action.svelte

```svelte
<script lang="ts">
	import MappedactionContextProvider from '$lib/components/app-provider/mappedaction-context-provider.svelte';
	import Badge from '$lib/components/badge/badge.svelte';
	import Icon from '$lib/components/icon/icon.svelte';
	import Listbox from '$lib/components/listbox/index.js';
	import Text from '$lib/components/text/text.svelte';
	import { applyStyles, classNames } from '$utilities/css.js';
	import type { ActionListItemDescriptor } from '$utilities/types.js';
	import styles from './mapped-action.module.css';

	interface MappedAction extends ActionListItemDescriptor {
		wrapOverflow?: boolean;
	}

	let {
		active,
		content,
		disabled,
		icon,
		image,
		prefix,
		suffix,
		ellipsis,
		role,
		url,
		external,
		onAction,
		destructive,
		badge,
		helpText,
		wrapOverflow = false
	}: MappedAction = $props();

	let context = $derived({
		role,
		url,
		external,
		onAction,
		destructive
	});

	const actionClassNames = $derived(
		classNames(
			styles.Action,
			disabled && styles.disabled,
			destructive && styles.destructive,
			active && styles.selected
		)
	);

	$inspect("context in mapped-action", context);
</script>

{#snippet prefixMarkup()}
	{#if prefix}
		<div class={styles.Prefix}>{prefix}</div>
	{:else if icon}
		<div class={styles.Prefix}>
			<Icon source={icon} />
		</div>
	{:else if image}
		<div
			role="presentation"
			class={styles.Prefix}
			style={applyStyles({ backgroundImage: `url(${image}` })}
		></div>
	{/if}
{/snippet}

{#snippet badgeMarkup()}
	{#if badge}
		<span class={styles.Suffix}>
			<Badge tone={badge.tone}>{badge.content}</Badge>
		</span>
	{/if}
{/snippet}

{#snippet suffixMarkup()}
	{#if suffix}
		<span class={styles.Suffix}>{suffix}</span>
	{/if}
{/snippet}

{#snippet contentText()}
	{#if ellipsis && content}
		{content}...
	{:else}
		{content}
	{/if}
{/snippet}

{#snippet contentMarkup()}
	<div class={styles.Text}>
		<Text as="p" variant="bodyMd" breakWord={wrapOverflow}>
			{@render contentText()}
		</Text>
		{#if helpText}
			<Text as="p" variant="bodyMd" tone="subdued">
				{helpText}
			</Text>
		{/if}
	</div>
{/snippet}

<MappedactionContextProvider value={context}>
	<div class={styles.ActionContainer}>
		<Listbox.Action selected={active} {disabled} value={content || ''}>
			<div class={actionClassNames}>
				<div class={styles.Content}>
					{@render prefixMarkup()}
					{@render contentMarkup()}
					{@render badgeMarkup()}
					{@render suffixMarkup()}
				</div>
			</div>
		</Listbox.Action>
	</div>
</MappedactionContextProvider>

```

# components/autocomplete/components/mapped-action/types.ts

```ts

```

# components/autocomplete/components/mapped-option/mapped-option.module.css

```css
.Content {
    display: flex;
    flex: 1;

    /* stylelint-disable-next-line -- generated by polaris-migrator DO NOT COPY */
    @mixin text-breakword;
}

.Media {
    padding: 0 var(--p-space-200);

    svg {
        fill: var(--p-color-icon);
    }
}

.singleSelectionMedia {
    padding: 0 var(--p-space-200) 0 0;
}

.disabledMedia svg {
    fill: var(--p-color-icon-disabled);
}
```

# components/autocomplete/components/mapped-option/mapped-option.svelte

```svelte
<script lang="ts">
	import { classNames } from '$utilities/css.js';
	import type { OptionDescriptor } from '$utilities/types.js';
	import type { Snippet } from 'svelte';
	import styles from './mapped-option.module.css';
	import Listbox from '$lib/components/listbox/index.js';

	type MappedOption = OptionDescriptor & {
		selected: boolean;
		singleSelection: boolean;
	};

	let { label, value, disabled, media, selected, singleSelection }: MappedOption = $props();

	const mediaClassNames = $derived(
		classNames(
			styles.Media,
			disabled && styles.disabledMedia,
			singleSelection && styles.singleSelectionMedia
		)
	);

	const isSnippet = (media: any): media is Snippet => {
		return typeof media === 'function';
	};

	const accessibilityLabel = typeof label === 'string' ? label : undefined;
</script>

{#snippet mediaMarkup()}
	{#if media}
		<div class={mediaClassNames}>
			{#if isSnippet(media)}
				{@render media()}
			{:else}
				{media}
			{/if}
		</div>
	{/if}
{/snippet}

<Listbox.Option {accessibilityLabel} {selected} {value} {disabled}>
	<Listbox.TextOption {selected} {disabled}>
		<div class={styles.Content}>
			{@render mediaMarkup()}
			{label}
		</div>
	</Listbox.TextOption>
</Listbox.Option>

```

# components/autocomplete/index.ts

```ts
import Combobox from "../combobox/index.js";
import AutocompleteComponent from "./autocomplete.svelte";

type AutoCompleteCompoundComponent = typeof AutocompleteComponent & {
    TextField: typeof Combobox.TextField;
};

const AutoComplete = AutocompleteComponent as AutoCompleteCompoundComponent;
AutoComplete.TextField = Combobox.TextField;

export default AutoComplete;
```

# components/autocomplete/types.ts

```ts
import type { ActionListItemDescriptor, Descriptor, OptionDescriptor, SectionDescriptor } from "$utilities/types.js";
import type { Snippet } from "svelte";
import type { PopoverProps } from "../popover/types.js";

export interface AutocompleteProps {
    /** A unique identifier for the Autocomplete */
    id?: string;
    /** Collection of options to be listed */
    options: SectionDescriptor[] | OptionDescriptor[];
    /** The selected options */
    selected: string[];
    /** The text field component attached to the list of options */
    textField: Snippet;
    /** The preferred direction to open the popover */
    preferredPosition?: PopoverProps['preferredPosition'];
    /** Title of the list of options */
    listTitle?: string;
    /** Allow more than one option to be selected */
    allowMultiple?: boolean;
    /** An action to render above the list of options */
    actionBefore?: ActionListItemDescriptor & {
        /** Specifies that if the label is too long it will wrap instead of being hidden  */
        wrapOverflow?: boolean;
    };
    /** Display loading state */
    loading?: boolean;
    /** Indicates if more results will load dynamically */
    willLoadMoreResults?: boolean;
    /** Is rendered when there are no options */
    emptyState?: Snippet;
    /** Callback when the selection of options is changed */
    onSelect(selected: string[]): void;
    /** Callback when the end of the list is reached */
    onLoadMoreResults?(): void;
}

export function isSection(arr: Descriptor[]): arr is SectionDescriptor[] {
    return (
        typeof arr[0] === 'object' &&
        Object.prototype.hasOwnProperty.call(arr[0], 'options')
    );
}
```

# components/avatar/avatar.module.css

```css
.Avatar {
    /* stylelint-disable -- Polaris component custom properties */
    --pc-avatar-xs-size: 20px;
    --pc-avatar-sm-size: 24px;
    --pc-avatar-md-size: 28px;
    --pc-avatar-lg-size: 32px;
    --pc-avatar-xl-size: 40px;
    /* stylelint-enable */
    position: relative;
    display: block;
    overflow: hidden;
    /* stylelint-disable-next-line -- generated by polaris-migrator DO NOT COPY */
    min-width: var(--pc-avatar-xs-size);
    max-width: 100%;
    background: var(--p-color-avatar-bg-fill);
    color: var(--p-color-avatar-text-on-bg-fill);
    user-select: none;

    &.imageHasLoaded {
        background: transparent;
    }

    @media (forced-colors: active) {
        border: var(--p-border-width-025) solid transparent;
    }

    &::after {
        content: '';
        display: block;
        /* stylelint-disable-next-line -- generated by polaris-migrator DO NOT COPY */
        padding-bottom: 100%;
    }
}

.Text {
    font-size: var(--p-font-size-400);
    font-weight: var(--p-font-weight-regular);

    &.long {
        font-size: var(--p-font-size-300);
    }
}

.hidden {
    visibility: hidden;
}

.sizeXs {
    /* stylelint-disable-next-line -- generated by polaris-migrator DO NOT COPY */
    width: var(--pc-avatar-xs-size);
    /* stylelint-disable-next-line -- custom overrides */
    border-radius: 4px;
}

.sizeSm {
    /* stylelint-disable-next-line -- generated by polaris-migrator DO NOT COPY */
    width: var(--pc-avatar-sm-size);
    /* stylelint-disable-next-line -- custom overrides */
    border-radius: 6px;
}

.sizeMd {
    /* stylelint-disable-next-line -- generated by polaris-migrator DO NOT COPY */
    width: var(--pc-avatar-md-size);
    /* stylelint-disable-next-line -- custom overrides */
    border-radius: 6px;
}

.sizeLg {
    /* stylelint-disable-next-line -- generated by polaris-migrator DO NOT COPY */
    width: var(--pc-avatar-lg-size);
    /* stylelint-disable-next-line -- custom overrides */
    border-radius: 8px;
}

.sizeXl {
    /* stylelint-disable-next-line -- custom overrides */
    width: var(--pc-avatar-xl-size);
    /* stylelint-disable-next-line -- custom overrides */
    border-radius: 8px;
}

.styleOne {
    background: var(--p-color-avatar-one-bg-fill);
    color: var(--p-color-avatar-one-text-on-bg-fill);

    svg,
    text {
        color: var(--p-color-avatar-one-text-on-bg-fill);
    }
}

.styleTwo {
    background: var(--p-color-avatar-two-bg-fill);
    color: var(--p-color-avatar-two-text-on-bg-fill);

    svg,
    text {
        color: var(--p-color-avatar-two-text-on-bg-fill);
    }
}

.styleThree {
    background: var(--p-color-avatar-three-bg-fill);
    color: var(--p-color-avatar-three-text-on-bg-fill);

    svg,
    text {
        color: var(--p-color-avatar-three-text-on-bg-fill);
    }
}

.styleFour {
    background: var(--p-color-avatar-four-bg-fill);
    color: var(--p-color-avatar-four-text-on-bg-fill);

    svg,
    text {
        color: var(--p-color-avatar-four-text-on-bg-fill);
    }
}

.styleFive {
    background: var(--p-color-avatar-five-bg-fill);
    color: var(--p-color-avatar-five-text-on-bg-fill);

    svg,
    text {
        color: var(--p-color-avatar-five-text-on-bg-fill);
    }
}

.styleSix {
    background: var(--p-color-avatar-six-bg-fill);
    color: var(--p-color-avatar-six-text-on-bg-fill);

    svg,
    text {
        color: var(--p-color-avatar-six-text-on-bg-fill);
    }
}

.styleSeven {
    background: var(--p-color-avatar-seven-bg-fill);
    color: var(--p-color-avatar-seven-text-on-bg-fill);

    svg,
    text {
        color: var(--p-color-avatar-seven-text-on-bg-fill);
    }
}

.imageHasLoaded {
    background: transparent;
}

.Image {
    position: absolute;
    top: 50%;
    left: 50%;
    width: 100%;
    height: 100%;
    border-radius: inherit;
    transform: translate(-50%, -50%);
    object-fit: cover;
}

.Initials {
    position: absolute;
    top: 0;
    right: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    width: 100%;
    height: 100%;
}

.Svg {
    width: 100%;
    height: 100%;
}
```

# components/avatar/avatar.svelte

```svelte
<script lang="ts">
	import { classNames } from '$utilities/css.js';
	import {
		avatarStrokeWidth,
		Status,
		STYLE_CLASSES,
		styleClass,
		xorHash,
		type AvatarProps
	} from './types.js';
	import styles from './avatar.module.css';
	import { variationName } from '$utilities/css.js';
	import { browser } from '$app/environment';
	import Image from '../image/image.svelte';

	let {
		name,
		source,
		onError,
		initials,
		customer,
		size = 'md',
		accessibilityLabel
	}: AvatarProps = $props();

	let status = $state();

	$effect(() => {
		if (source) {
			status = Status.Pending;
		}

		if (accessibilityLabel) {
			label = accessibilityLabel;
		} else if (name) {
			label = name;
		} else if (initials) {
			const splitInitials = initials.split('').join(' ');
			label = `Avatar with initials ${splitInitials}`;
		}
	});

	const handleError = () => {
		status = Status.Errored;
		if (onError) {
			onError();
		}
	};

	const handleLoad = () => {
		status = Status.Loaded;
	};

	const hasImage = $derived(source && status !== Status.Errored);
	const nameString = name || initials;
	let label: string | undefined = $state();

	const className = $derived(
		classNames(
			styles.Avatar,
			size && styles[variationName('size', size)],
			hasImage && status === Status.Loaded && styles.imageHasLoaded,
			!customer && !hasImage && styles[variationName('style', styleClass(nameString))]
		)
	);

	const textClassName = $derived(
		classNames(styles.Text, (initials?.length || 0) > 2 && styles.long)
	);

	const imageClassName = $derived(
		classNames(styles.Image, status !== Status.Loaded && styles.hidden)
	);

	// Use `dominant-baseline: central` instead of `dy` when Edge supports it.
	const verticalOffset = '0.35em';
</script>

{#snippet imageMarkUp()}
	{#if source && browser && status !== Status.Errored}
		<Image
			className={imageClassName}
			{source}
			alt=""
			role="presentation"
			onLoad={handleLoad}
			onError={handleError}
		/>
	{/if}
{/snippet}

{#snippet avatarPath()}
	<path
		fill="none"
		d="M25.5 13.5C25.5 16.5376 23.0376 19 20 19C16.9624 19 14.5 16.5376 14.5 13.5C14.5 10.4624 16.9624 8 20 8C23.0376 8 25.5 10.4624 25.5 13.5Z"
		stroke="currentColor"
		stroke-width={avatarStrokeWidth[size]}
	/>
	<path
		fill="none"
		d="M10.3433 29.682L9.47 31.254C9.03481 32.0373 9.60125 33 10.4974 33H29.5026C30.3988 33 30.9652 32.0373 30.53 31.254L29.6567 29.682C27.7084 26.175 24.0119 24 20 24C15.9882 24 12.2916 26.175 10.3433 29.682Z"
		stroke="currentColor"
		stroke-width={avatarStrokeWidth[size]}
		stroke-linecap="round"
		stroke-linejoin="round"
	/>
{/snippet}

{#snippet avatarBody()}
	{#if customer || !initials}
		{@render avatarPath()}
	{:else}
		<text
			class={textClassName}
			x="50%"
			y="50%"
			dy={verticalOffset}
			fill="currentColor"
			text-anchor="middle"
		>
			{initials}
		</text>
	{/if}
{/snippet}

{#snippet svgMarkUp()}
	{#if !hasImage}
		<span class={styles.Initials}>
			<svg class={styles.Svg} viewBox="0 0 40 40">
				{@render avatarBody()}
			</svg>
		</span>
	{/if}
{/snippet}

<span aria-label={label} role={label ? 'img' : 'presentation'} class={className}>
	{@render svgMarkUp()}
	{@render imageMarkUp()}
</span>

```

# components/avatar/types.ts

```ts
export type Size = 'xs' | 'sm' | 'md' | 'lg' | 'xl';

export enum Status {
    Pending = 'PENDING',
    Loaded = 'LOADED',
    Errored = 'ERRORED',
}

export const STYLE_CLASSES = [
    'one',
    'two',
    'three',
    'four',
    'five',
    'six',
    'seven',
] as const;

export const avatarStrokeWidth: { [S in Size]: string } = {
    xs: '3',
    sm: '2.5',
    md: '2.5',
    lg: '2.5',
    xl: '2',
};

/**
 * Computes a rudimentary hash from a string by xoring the character codes
 * of all characters
 */
export function xorHash(str: string) {
    let hash = 0;

    for (const char of str) {
        hash ^= char.charCodeAt(0);
    }

    return hash;
}

export function styleClass(name?: string) {
    return name
        ? STYLE_CLASSES[xorHash(name) % STYLE_CLASSES.length]
        : STYLE_CLASSES[0];
}

export interface AvatarProps {
    /**
     * Size of avatar
     * @default 'medium'
     */
    size?: Size;
    /** The name of the person */
    name?: string;
    /** Initials of person to display */
    initials?: string;
    /** Whether the avatar is for a customer */
    customer?: boolean;
    /** URL of the avatar image which falls back to initials if the image fails to load */
    source?: string;
    /** Callback fired when the image fails to load  */
    onError?(): void;
    /** Accessible label for the avatar image */
    accessibilityLabel?: string;
}
```

# components/badge/badge.module.css

```css
.Badge {
    /* stylelint-disable -- Polaris component custom properties */
    --pc-badge-horizontal-padding: var(--p-space-200);
    --pc-badge-vertical-padding: var(--p-space-050);
    /* stylelint-enable */
    display: inline-flex;
    align-items: center;
    /* stylelint-disable-next-line -- generated by polaris-migrator DO NOT COPY */
    padding: var(--pc-badge-vertical-padding) var(--pc-badge-horizontal-padding);
    background-color: var(--p-color-bg-fill-transparent-secondary);
    border-radius: var(--p-border-radius-200);
    color: var(--p-color-text-secondary);
    font-weight: var(--p-font-weight-medium);

    svg {
        fill: var(--p-color-text-secondary);
    }

    @media print {
        border: solid var(--p-border-width-025) var(--p-color-border);
    }
}

.toneSuccess {
    background-color: var(--p-color-bg-fill-success-secondary);
    color: var(--p-color-text-success);

    svg {
        fill: var(--p-color-icon-success);
    }
}

.toneSuccess-strong {
    color: var(--p-color-text-success-on-bg-fill);
    background-color: var(--p-color-bg-fill-success);

    svg {
        fill: var(--p-color-text-success-on-bg-fill);
    }
}

.toneInfo {
    background-color: var(--p-color-bg-fill-info-secondary);
    color: var(--p-color-text-info);

    svg {
        fill: var(--p-color-icon-info);
    }
}

.toneInfo-strong {
    color: var(--p-color-text-info-on-bg-fill);
    background-color: var(--p-color-bg-fill-info);

    svg {
        fill: var(--p-color-text-info-on-bg-fill);
    }
}

.toneAttention {
    background-color: var(--p-color-bg-fill-caution-secondary);
    color: var(--p-color-text-caution);

    svg {
        fill: var(--p-color-icon-caution);
    }
}

.toneAttention-strong {
    color: var(--p-color-text-caution-on-bg-fill);
    background-color: var(--p-color-bg-fill-caution);

    svg {
        fill: var(--p-color-text-caution-on-bg-fill);
    }
}

.toneWarning {
    background-color: var(--p-color-bg-fill-warning-secondary);
    color: var(--p-color-text-warning);

    svg {
        fill: var(--p-color-icon-warning);
    }
}

.toneWarning-strong {
    color: var(--p-color-text-warning-on-bg-fill);
    background-color: var(--p-color-bg-fill-warning);

    svg {
        fill: var(--p-color-text-warning-on-bg-fill);
    }
}

.toneCritical {
    background-color: var(--p-color-bg-fill-critical-secondary);
    color: var(--p-color-text-critical);

    svg {
        fill: var(--p-color-icon-critical);
    }
}

.toneCritical-strong {
    color: var(--p-color-text-critical-on-bg-fill);
    background-color: var(--p-color-bg-fill-critical);

    svg {
        fill: var(--p-color-text-critical-on-bg-fill);
    }
}

.toneNew {
    border: none;
    background-color: var(--p-color-bg-fill-transparent-secondary);
    color: var(--p-color-text-secondary);
    font-weight: var(--p-font-weight-bold);
    border-radius: var(--p-border-radius-200);

    svg {
        fill: var(--p-color-text-secondary);
    }
}

.toneMagic {
    background-color: var(--p-color-bg-fill-magic-secondary);
    color: var(--p-color-text-magic);

    svg {
        fill: var(--p-color-text-magic);
    }
}

.toneRead-only {
    color: var(--p-color-text-secondary);
    background-color: transparent;

    svg {
        fill: var(--p-color-icon-secondary);
    }
}

.toneEnabled {
    color: var(--p-color-text);

    svg {
        fill: var(--p-color-icon-success);
    }
}

.sizeLarge {
    padding: var(--p-space-100) var(--p-space-200);
}

.withinFilter {
    border-radius: var(--p-border-radius-100);
}

.Icon {
    margin: calc(-1 * var(--p-space-050)) 0 calc(-1 * var(--p-space-050)) calc(-1 * var(--p-space-200));

    svg {
        /* Corrects conflicting alignment with ancestor elements */
        display: inline-block;
        vertical-align: top;
    }

    .sizeLarge & {
        margin: 0 var(--p-space-100) 0 calc(-1 * var(--p-space-050));
    }

    +* {
        margin-left: 0;
    }
}

.PipContainer {
    display: grid;
    align-items: center;
    margin-left: calc(-1 * var(--p-space-050));
    margin-right: var(--p-space-100);
}
```

# components/badge/badge.svelte

```svelte
<script lang="ts">
	import { classNames } from '$utilities/css.js';
	import { DEFAULT_SIZE, progressIconMap, type BadgeProps } from './types.js';
	import styles from './badge.module.css';
	import { variationName } from '$utilities/css.js';
	import Icon from '$lib/components/icon/icon.svelte';
	import Text from '$lib/components/text/text.svelte';

	let {
		children,
		tone,
		progress,
		icon,
		size = DEFAULT_SIZE,
		toneAndProgressLabelOverride
	}: BadgeProps = $props();

	const className = $derived(
		classNames(
			styles.Badge,
			tone && styles[variationName('tone', tone)],
			size && size !== DEFAULT_SIZE && styles[variationName('size', size)]
		)
	);
</script>

<span class={className}>
	{#if progress && !icon}
		<span class={styles.Icon}>
			<Icon accessibilityLabel={toneAndProgressLabelOverride} source={progressIconMap[progress]} />
		</span>
	{:else if toneAndProgressLabelOverride}
		<Text as="span" visuallyHidden>
			{toneAndProgressLabelOverride}
		</Text>
	{/if}

	{#if icon}
		<span class={styles.Icon}>
			<Icon source={icon} />
		</span>
	{/if}
	
	{#if children}
		{#if typeof children === 'string'}
			<Text as="span" variant="bodySm" fontWeight={tone === 'new' ? 'medium' : undefined}>
				{children}
			</Text>
		{:else}
			{@render children()}
		{/if}
	{/if}
</span>

```

# components/badge/types.ts

```ts
import CompleteIcon from "$lib/icons/complete-icon.svelte";
import PartiallyCompleteIcon from "$lib/icons/partially-complete-icon.svelte";
import IncompleteIcon from "$lib/icons/incomplete-icon.svelte";
import type { IconSource } from "$utilities/types.js";
import type { Snippet } from "svelte";

export type Tone =
  | 'info'
  | 'success'
  | 'warning'
  | 'critical'
  | 'attention'
  | 'new'
  | 'magic'
  | 'info-strong'
  | 'success-strong'
  | 'warning-strong'
  | 'critical-strong'
  | 'attention-strong'
  | 'read-only'
  | 'enabled';

export enum ToneValue {
  Info = 'info',
  Success = 'success',
  Warning = 'warning',
  Critical = 'critical',
  Attention = 'attention',
  New = 'new',
  Magic = 'magic',
  InfoStrong = 'info-strong',
  SuccessStrong = 'success-strong',
  WarningStrong = 'warning-strong',
  CriticalStrong = 'critical-strong',
  AttentionStrong = 'attention-strong',
  ReadOnly = 'read-only',
  Enabled = 'enabled',
}

export type Progress = 'incomplete' | 'partiallyComplete' | 'complete';

export enum ProgressValue {
  Incomplete = 'incomplete',
  PartiallyComplete = 'partiallyComplete',
  Complete = 'complete',
}

export type Size = 'small' | 'medium' | 'large';

export const DEFAULT_SIZE: Size = 'medium';

interface NonMutuallyExclusiveProps {
  /** The content to display inside the badge. */
  children?: string|Snippet;
  /** Colors and labels the badge with the given tone. */
  tone?: Tone;
  /** Render a pip showing the progress of a given task. */
  progress?: Progress;
  /** Icon to display to the left of the badgeâ€™s content. */
  icon?: IconSource;
  /**
   * @default 'medium'
   */
  size?: Size;
  /** Pass a custom accessibilityLabel */
  toneAndProgressLabelOverride?: string;
}

export type BadgeProps = NonMutuallyExclusiveProps &
  (
    | { progress?: Progress; icon?: undefined }
    | { icon?: IconSource; progress?: undefined }
  );

export const progressIconMap: { [P in Progress]: IconSource } = {
  complete: CompleteIcon,
  partiallyComplete: PartiallyCompleteIcon,
  incomplete: IncompleteIcon,
};
```

# components/badge/utils.ts

```ts
import {ProgressValue, ToneValue} from './types.js';
import type {Progress, Tone} from './types.js';

export function getDefaultAccessibilityLabel(
  progress?: Progress,
  tone?: Tone,
): string {
  let progressLabel = '';
  let toneLabel = '';

  if (!progress && !tone) {
    return '';
  }

  switch (progress) {
    case ProgressValue.Incomplete:
      progressLabel = 'Incomplete';
      break;
    case ProgressValue.PartiallyComplete:
      progressLabel = 'Partially complete';
      break;
    case ProgressValue.Complete:
      progressLabel = 'Complete';
      break;
  }

  switch (tone) {
    case ToneValue.Info:
    case ToneValue.InfoStrong:
      toneLabel = 'Info';
      break;
    case ToneValue.Success:
    case ToneValue.SuccessStrong:
      toneLabel = 'Success';
      break;
    case ToneValue.Warning:
    case ToneValue.WarningStrong:
      toneLabel = 'Warning';
      break;
    case ToneValue.Critical:
    case ToneValue.CriticalStrong:
      toneLabel = 'Critical';
      break;
    case ToneValue.Attention:
    case ToneValue.AttentionStrong:
      toneLabel = 'Attention';
      break;
    case ToneValue.New:
      toneLabel = 'New';
      break;
    case ToneValue.ReadOnly:
      toneLabel = 'Read-only';
      break;
    case ToneValue.Enabled:
      toneLabel = 'Enabled';
      break;
  }

  if (!tone && progress) {
    return progressLabel;
  } else if (tone && !progress) {
    return toneLabel;
  } else {
    return `${toneLabel} ${progressLabel}`;
  }
}
```

# components/bleed/bleed.module.css

```css
.Bleed {
    /* stylelint-disable -- Polaris component custom properties */
    --pc-bleed-margin-block-start-xs: initial;
    --pc-bleed-margin-block-start-sm: var(--pc-bleed-margin-block-start-xs);
    --pc-bleed-margin-block-start-md: var(--pc-bleed-margin-block-start-sm);
    --pc-bleed-margin-block-start-lg: var(--pc-bleed-margin-block-start-md);
    --pc-bleed-margin-block-start-xl: var(--pc-bleed-margin-block-start-lg);
    --pc-bleed-margin-block-end-xs: initial;
    --pc-bleed-margin-block-end-sm: var(--pc-bleed-margin-block-end-xs);
    --pc-bleed-margin-block-end-md: var(--pc-bleed-margin-block-end-sm);
    --pc-bleed-margin-block-end-lg: var(--pc-bleed-margin-block-end-md);
    --pc-bleed-margin-block-end-xl: var(--pc-bleed-margin-block-end-lg);
    --pc-bleed-margin-inline-start-xs: initial;
    --pc-bleed-margin-inline-start-sm: var(--pc-bleed-margin-inline-start-xs);
    --pc-bleed-margin-inline-start-md: var(--pc-bleed-margin-inline-start-sm);
    --pc-bleed-margin-inline-start-lg: var(--pc-bleed-margin-inline-start-md);
    --pc-bleed-margin-inline-start-xl: var(--pc-bleed-margin-inline-start-lg);
    --pc-bleed-margin-inline-end-xs: initial;
    --pc-bleed-margin-inline-end-sm: var(--pc-bleed-margin-inline-end-xs);
    --pc-bleed-margin-inline-end-md: var(--pc-bleed-margin-inline-end-sm);
    --pc-bleed-margin-inline-end-lg: var(--pc-bleed-margin-inline-end-md);
    --pc-bleed-margin-inline-end-xl: var(--pc-bleed-margin-inline-end-lg);
    /* stylelint-enable */
    /* stylelint-disable-next-line -- generated by polaris-migrator DO NOT COPY */
    margin-block-start: calc(-1 * var(--pc-bleed-margin-block-start-xs));
    /* stylelint-disable-next-line -- generated by polaris-migrator DO NOT COPY */
    margin-block-end: calc(-1 * var(--pc-bleed-margin-block-end-xs));
    /* stylelint-disable-next-line -- generated by polaris-migrator DO NOT COPY */
    margin-inline-start: calc(-1 * var(--pc-bleed-margin-inline-start-xs));
    /* stylelint-disable-next-line -- generated by polaris-migrator DO NOT COPY */
    margin-inline-end: calc(-1 * var(--pc-bleed-margin-inline-end-xs));

    @media (--p-breakpoints-sm-up) {
        /* stylelint-disable-next-line -- generated by polaris-migrator DO NOT COPY */
        margin-block-start: calc(-1 * var(--pc-bleed-margin-block-start-sm));
        /* stylelint-disable-next-line -- generated by polaris-migrator DO NOT COPY */
        margin-block-end: calc(-1 * var(--pc-bleed-margin-block-end-sm));
        /* stylelint-disable-next-line -- generated by polaris-migrator DO NOT COPY */
        margin-inline-start: calc(-1 * var(--pc-bleed-margin-inline-start-sm));
        /* stylelint-disable-next-line -- generated by polaris-migrator DO NOT COPY */
        margin-inline-end: calc(-1 * var(--pc-bleed-margin-inline-end-sm));
    }

    @media (--p-breakpoints-md-up) {
        /* stylelint-disable-next-line -- generated by polaris-migrator DO NOT COPY */
        margin-block-start: calc(-1 * var(--pc-bleed-margin-block-start-md));
        /* stylelint-disable-next-line -- generated by polaris-migrator DO NOT COPY */
        margin-block-end: calc(-1 * var(--pc-bleed-margin-block-end-md));
        /* stylelint-disable-next-line -- generated by polaris-migrator DO NOT COPY */
        margin-inline-start: calc(-1 * var(--pc-bleed-margin-inline-start-md));
        /* stylelint-disable-next-line -- generated by polaris-migrator DO NOT COPY */
        margin-inline-end: calc(-1 * var(--pc-bleed-margin-inline-end-md));
    }

    @media (--p-breakpoints-lg-up) {
        /* stylelint-disable-next-line -- generated by polaris-migrator DO NOT COPY */
        margin-block-start: calc(-1 * var(--pc-bleed-margin-block-start-lg));
        /* stylelint-disable-next-line -- generated by polaris-migrator DO NOT COPY */
        margin-block-end: calc(-1 * var(--pc-bleed-margin-block-end-lg));
        /* stylelint-disable-next-line -- generated by polaris-migrator DO NOT COPY */
        margin-inline-start: calc(-1 * var(--pc-bleed-margin-inline-start-lg));
        /* stylelint-disable-next-line -- generated by polaris-migrator DO NOT COPY */
        margin-inline-end: calc(-1 * var(--pc-bleed-margin-inline-end-lg));
    }

    @media (--p-breakpoints-xl-up) {
        /* stylelint-disable-next-line -- generated by polaris-migrator DO NOT COPY */
        margin-block-start: calc(-1 * var(--pc-bleed-margin-block-start-xl));
        /* stylelint-disable-next-line -- generated by polaris-migrator DO NOT COPY */
        margin-block-end: calc(-1 * var(--pc-bleed-margin-block-end-xl));
        /* stylelint-disable-next-line -- generated by polaris-migrator DO NOT COPY */
        margin-inline-start: calc(-1 * var(--pc-bleed-margin-inline-start-xl));
        /* stylelint-disable-next-line -- generated by polaris-migrator DO NOT COPY */
        margin-inline-end: calc(-1 * var(--pc-bleed-margin-inline-end-xl));
    }
}
```

# components/bleed/bleed.svelte

```svelte
<script lang="ts">
	import type { Snippet } from 'svelte';
	import type { Spacing } from './types.js';
	import { createStyleString, getResponsiveProps, sanitizeCustomProperties } from '$utilities/css.js';
	import styles from './bleed.module.css';

	interface Props {
		/** Negative horizontal space around children */
		marginInline?: Spacing;
		/** Negative vertical space around children */
		marginBlock?: Spacing;
		/** Negative top space around children */
		marginBlockStart?: Spacing;
		/** Negative bottom space around children */
		marginBlockEnd?: Spacing;
		/** Negative left space around children */
		marginInlineStart?: Spacing;
		/** Negative right space around children */
		marginInlineEnd?: Spacing;
		children?: Snippet;
	}

	let {
		marginInline,
		marginBlock,
		marginBlockStart,
		marginBlockEnd,
		marginInlineStart,
		marginInlineEnd,
		children
	}: Props = $props();

	const getNegativeMargins = (direction: string) => {
		const xAxis = ['marginInlineStart', 'marginInlineEnd'];
		const yAxis = ['marginBlockStart', 'marginBlockEnd'];

		const directionValues: { [key: string]: Spacing | undefined } = {
			marginBlockStart,
			marginBlockEnd,
			marginInlineStart,
			marginInlineEnd,
			marginInline,
			marginBlock
		};

		if (directionValues[direction]) {
			return directionValues[direction];
		} else if (xAxis.includes(direction) && marginInline) {
			return directionValues.marginInline;
		} else if (yAxis.includes(direction) && marginBlock) {
			return directionValues.marginBlock;
		}
	};

	const negativeMarginBlockStart = getNegativeMargins('marginBlockStart');
	const negativeMarginBlockEnd = getNegativeMargins('marginBlockEnd');
	const negativeMarginInlineStart = getNegativeMargins('marginInlineStart');
	const negativeMarginInlineEnd = getNegativeMargins('marginInlineEnd');

	const style1 = {
		...getResponsiveProps('bleed', 'margin-block-start', 'space', negativeMarginBlockStart),
		...getResponsiveProps('bleed', 'margin-block-end', 'space', negativeMarginBlockEnd),
		...getResponsiveProps('bleed', 'margin-inline-start', 'space', negativeMarginInlineStart),
		...getResponsiveProps('bleed', 'margin-inline-end', 'space', negativeMarginInlineEnd)
	};

</script>

<div class={styles.Bleed} style={createStyleString(sanitizeCustomProperties(style1))}>
	{@render children?.()}
</div>

```

# components/bleed/types.ts

```ts
import type { ResponsiveProp } from "$utilities/css.js";
import type { SpaceScale } from "@shopify/polaris-tokens";

export type Spacing = ResponsiveProp<SpaceScale>;

```

# components/block-stack/block-stack.module.css

```css
.BlockStack {
    @mixin responsive-props block-stack, gap, gap;
    /* stylelint-disable -- Polaris component custom properties */
    --pc-block-stack-align: initial;
    --pc-block-stack-inline-align: initial;
    --pc-block-stack-order: initial;
    /* stylelint-enable */
    display: flex;
    /* stylelint-disable-next-line -- custom property to set flex direction */
    flex-direction: var(--pc-block-stack-order);
    /* stylelint-disable-next-line -- custom property to set horizontal alignment */
    align-items: var(--pc-block-stack-inline-align);
    /* stylelint-disable-next-line -- custom property to set vertical alignment */
    justify-content: var(--pc-block-stack-align);
}

.listReset {
    list-style-type: none;
    margin-block-start: 0;
    margin-block-end: 0;
    padding-inline-start: 0;
}

.fieldsetReset {
    border: none;
    margin: 0;
    padding: 0;
}
```

# components/block-stack/block-stack.svelte

```svelte
<script lang="ts">
	import {
		classNames,
		createStyleString,
		getResponsiveProps,
		sanitizeCustomProperties
	} from '$utilities/css.js';
	import styles from './block-stack.module.css';
	import type { BlockStackProps } from './types.js';
	let {
		children,
		as = 'div',
		align,
		inlineAlign,
		gap,
		id,
		reverseOrder = false,
		role,
		...restProps
	}: BlockStackProps = $props();

	const className = $derived(
		classNames(
			styles.BlockStack,
			(as === 'ul' || as === 'ol') && styles.listReset,
			as === 'fieldset' && styles.fieldsetReset
		)
	);

	const style = $derived({
		'--pc-block-stack-align': align ? `${align}` : null,
		'--pc-block-stack-inline-align': inlineAlign ? `${inlineAlign}` : null,
		'--pc-block-stack-order': reverseOrder ? 'column-reverse' : 'column',
		...getResponsiveProps('block-stack', 'gap', 'space', gap)
	});
</script>

<svelte:element
	this={as}
	class={className}
	style={createStyleString(sanitizeCustomProperties(style))}
	{...id ? { id } : {}}
	{...restProps}
>
	{@render children?.()}
</svelte:element>

```

# components/block-stack/types.ts

```ts
import type { ResponsiveProp } from "$utilities/css.js";
import type { SpaceScale } from "@shopify/polaris-tokens";
import type { Snippet } from "svelte";

type Align =
    | 'start'
    | 'center'
    | 'end'
    | 'space-around'
    | 'space-between'
    | 'space-evenly';

type InlineAlign = 'start' | 'center' | 'end' | 'baseline' | 'stretch';

type Element = 'div' | 'span' | 'ul' | 'ol' | 'li' | 'fieldset';

type Gap = ResponsiveProp<SpaceScale>;

export interface BlockStackProps {
    children?: Snippet;
    /** HTML Element type
     * @default 'div'
     */
    as?: Element;
    /** Vertical alignment of children */
    align?: Align;
    /** Horizontal alignment of children */
    inlineAlign?: InlineAlign;
    /** The spacing between children */
    gap?: Gap;
    /** HTML id attribute */
    id?: string;
    /** Reverse the render order of child items
     * @default false
     */
    reverseOrder?: boolean;
    /** Aria role */
    role?: 'status' | 'presentation' | 'menu' | 'listbox' | 'combobox' | 'group';
}
```

# components/box/box.module.css

```css
.listReset {
    list-style-type: none;
    margin-block-start: 0;
    margin-block-end: 0;
    outline: none;
    padding-inline-start: 0;
}

.Box {
    @mixin responsive-props box, padding-block-end, padding-block-end;
    @mixin responsive-props box, padding-block-start, padding-block-start;
    @mixin responsive-props box, padding-inline-start, padding-inline-start;
    @mixin responsive-props box, padding-inline-end, padding-inline-end;

    /* stylelint-disable -- Polaris component custom properties */
    --pc-box-shadow: initial;
    --pc-box-background: initial;
    --pc-box-border-radius: initial;
    --pc-box-border-end-start-radius: var(--pc-box-border-radius);
    --pc-box-border-end-end-radius: var(--pc-box-border-radius);
    --pc-box-border-start-start-radius: var(--pc-box-border-radius);
    --pc-box-border-start-end-radius: var(--pc-box-border-radius);
    --pc-box-color: initial;
    --pc-box-min-height: initial;
    --pc-box-min-width: initial;
    --pc-box-max-width: initial;
    --pc-box-outline-color: initial;
    --pc-box-outline-style: initial;
    --pc-box-outline-width: initial;
    --pc-box-overflow-x: initial;
    --pc-box-overflow-y: initial;
    --pc-box-width: initial;
    --pc-box-border-style: initial;
    --pc-box-border-color: initial;
    --pc-box-border-width: 0;
    --pc-box-border-block-start-width: var(--pc-box-border-width);
    --pc-box-border-block-end-width: var(--pc-box-border-width);
    --pc-box-border-inline-start-width: var(--pc-box-border-width);
    --pc-box-border-inline-end-width: var(--pc-box-border-width);
    --pc-box-inset-block-start: initial;
    --pc-box-inset-block-end: initial;
    --pc-box-inset-inline-start: initial;
    --pc-box-inset-inline-end: initial;
    /* stylelint-enable */
    /* stylelint-disable-next-line -- generated by polaris-migrator DO NOT COPY */
    inset-block-start: var(--pc-box-inset-block-start);
    /* stylelint-disable-next-line -- generated by polaris-migrator DO NOT COPY */
    inset-block-end: var(--pc-box-inset-block-end);
    /* stylelint-disable-next-line -- generated by polaris-migrator DO NOT COPY */
    inset-inline-start: var(--pc-box-inset-inline-start);
    /* stylelint-disable-next-line -- generated by polaris-migrator DO NOT COPY */
    inset-inline-end: var(--pc-box-inset-inline-end);
    /* stylelint-disable-next-line -- generated by polaris-migrator DO NOT COPY */
    background-color: var(--pc-box-background);
    /* stylelint-disable-next-line -- generated by polaris-migrator DO NOT COPY */
    box-shadow: var(--pc-box-shadow);
    /* stylelint-disable -- generated by polaris-migrator DO NOT COPY */
    border-end-start-radius: var(--pc-box-border-end-start-radius);
    /* stylelint-enable */
    /* stylelint-disable -- generated by polaris-migrator DO NOT COPY */
    border-end-end-radius: var(--pc-box-border-end-end-radius);
    /* stylelint-enable */
    /* stylelint-disable -- generated by polaris-migrator DO NOT COPY */
    border-start-start-radius: var(--pc-box-border-start-start-radius);
    /* stylelint-enable */
    /* stylelint-disable -- generated by polaris-migrator DO NOT COPY */
    border-start-end-radius: var(--pc-box-border-start-end-radius);
    /* stylelint-enable */
    /* stylelint-disable-next-line -- component custom property that maps to Polaris tokens */
    border-color: var(--pc-box-border-color);
    /* stylelint-disable-next-line -- component custom property that maps to Polaris tokens */
    border-style: var(--pc-box-border-style);
    /* stylelint-disable -- generated by polaris-migrator DO NOT COPY */
    border-block-start-width: var(--pc-box-border-block-start-width);
    /* stylelint-enable */
    /* stylelint-disable -- generated by polaris-migrator DO NOT COPY */
    border-block-end-width: var(--pc-box-border-block-end-width);
    /* stylelint-enable */
    /* stylelint-disable -- generated by polaris-migrator DO NOT COPY */
    border-inline-start-width: var(--pc-box-border-inline-start-width);
    /* stylelint-enable */
    /* stylelint-disable -- generated by polaris-migrator DO NOT COPY */
    border-inline-end-width: var(--pc-box-border-inline-end-width);
    /* stylelint-enable */
    /* stylelint-disable-next-line -- generated by polaris-migrator DO NOT COPY */
    color: var(--pc-box-color);
    /* stylelint-disable-next-line -- generated by polaris-migrator DO NOT COPY */
    min-height: var(--pc-box-min-height);
    /* stylelint-disable-next-line -- generated by polaris-migrator DO NOT COPY */
    min-width: var(--pc-box-min-width);
    /* stylelint-disable-next-line -- generated by polaris-migrator DO NOT COPY */
    max-width: var(--pc-box-max-width);
    /* stylelint-disable-next-line -- component custom property that maps to Polaris tokens */
    outline-color: var(--pc-box-outline-color);
    /* stylelint-disable-next-line -- component custom property that maps to Polaris tokens */
    outline-style: var(--pc-box-outline-style);
    /* stylelint-disable-next-line -- component custom property that maps to Polaris tokens */
    outline-width: var(--pc-box-outline-width);
    /* stylelint-disable-next-line -- generated by polaris-migrator DO NOT COPY */
    overflow-x: var(--pc-box-overflow-x);
    /* stylelint-disable-next-line -- generated by polaris-migrator DO NOT COPY */
    overflow-y: var(--pc-box-overflow-y);
    /* stylelint-disable-next-line -- generated by polaris-migrator DO NOT COPY */
    width: var(--pc-box-width);
    -webkit-overflow-scrolling: touch;
}

.visuallyHidden {
    /* stylelint-disable-next-line -- generated by polaris-migrator DO NOT COPY */
    @mixin visually-hidden;
}

.printHidden {
    @media print {
        /* stylelint-disable-next-line -- necessary display property with !important */
        display: none !important;
    }
}
```

# components/box/box.svelte

```svelte
<script lang="ts">
	import {
		classNames,
		createStyleString,
		getResponsiveProps,
		sanitizeCustomProperties
	} from '$utilities/css.js';
	import type { BoxProps } from './types.js';
	import styles from './box.module.css';

	let ref: Element | null = $state(null);

	let {
		as = 'div',
		background,
		borderColor,
		borderStyle,
		borderWidth,
		borderBlockStartWidth,
		borderBlockEndWidth,
		borderInlineStartWidth,
		borderInlineEndWidth,
		borderRadius,
		borderEndStartRadius,
		borderEndEndRadius,
		borderStartStartRadius,
		borderStartEndRadius,
		children,
		color,
		id,
		minHeight,
		minWidth,
		maxWidth,
		overflowX,
		overflowY,
		outlineColor,
		outlineStyle,
		outlineWidth,
		padding,
		paddingBlock,
		paddingBlockStart,
		paddingBlockEnd,
		paddingInline,
		paddingInlineStart,
		paddingInlineEnd,
		role,
		shadow,
		tabIndex,
		width,
		printHidden,
		visuallyHidden,
		position,
		insetBlockStart,
		insetBlockEnd,
		insetInlineStart,
		insetInlineEnd,
		zIndex,
		opacity,
		...restProps
	}: BoxProps = $props();

	const borderStyleValue = $derived(
		borderStyle
			? borderStyle
			: borderColor ||
				  borderWidth ||
				  borderBlockStartWidth ||
				  borderBlockEndWidth ||
				  borderInlineStartWidth ||
				  borderInlineEndWidth
				? 'solid'
				: undefined
	);

	const outlineStyleValue = $derived(
		outlineStyle ? outlineStyle : outlineColor || outlineWidth ? 'solid' : undefined
	);

	const style = $derived({
		'--pc-box-color': color ? `var(--p-color-${color})` : undefined,
		'--pc-box-background': background ? `var(--p-color-${background})` : undefined,
		// eslint-disable-next-line no-nested-ternary
		'--pc-box-border-color': borderColor
			? borderColor === 'transparent'
				? 'transparent'
				: `var(--p-color-${borderColor})`
			: undefined,
		'--pc-box-border-style': borderStyleValue,
		'--pc-box-border-radius': borderRadius ? `var(--p-border-radius-${borderRadius})` : undefined,
		'--pc-box-border-end-start-radius': borderEndStartRadius
			? `var(--p-border-radius-${borderEndStartRadius})`
			: undefined,
		'--pc-box-border-end-end-radius': borderEndEndRadius
			? `var(--p-border-radius-${borderEndEndRadius})`
			: undefined,
		'--pc-box-border-start-start-radius': borderStartStartRadius
			? `var(--p-border-radius-${borderStartStartRadius})`
			: undefined,
		'--pc-box-border-start-end-radius': borderStartEndRadius
			? `var(--p-border-radius-${borderStartEndRadius})`
			: undefined,
		'--pc-box-border-width': borderWidth ? `var(--p-border-width-${borderWidth})` : undefined,
		'--pc-box-border-block-start-width': borderBlockStartWidth
			? `var(--p-border-width-${borderBlockStartWidth})`
			: undefined,
		'--pc-box-border-block-end-width': borderBlockEndWidth
			? `var(--p-border-width-${borderBlockEndWidth})`
			: undefined,
		'--pc-box-border-inline-start-width': borderInlineStartWidth
			? `var(--p-border-width-${borderInlineStartWidth})`
			: undefined,
		'--pc-box-border-inline-end-width': borderInlineEndWidth
			? `var(--p-border-width-${borderInlineEndWidth})`
			: undefined,
		'--pc-box-min-height': minHeight,
		'--pc-box-min-width': minWidth,
		'--pc-box-max-width': maxWidth,
		'--pc-box-outline-color': outlineColor ? `var(--p-color-${outlineColor})` : undefined,
		'--pc-box-outline-style': outlineStyleValue,
		'--pc-box-outline-width': outlineWidth ? `var(--p-border-width-${outlineWidth})` : undefined,
		'--pc-box-overflow-x': overflowX,
		'--pc-box-overflow-y': overflowY,
		...getResponsiveProps(
			'box',
			'padding-block-start',
			'space',
			paddingBlockStart || paddingBlock || padding
		),
		...getResponsiveProps(
			'box',
			'padding-block-end',
			'space',
			paddingBlockEnd || paddingBlock || padding
		),
		...getResponsiveProps(
			'box',
			'padding-inline-start',
			'space',
			paddingInlineStart || paddingInline || padding
		),
		...getResponsiveProps(
			'box',
			'padding-inline-end',
			'space',
			paddingInlineEnd || paddingInline || padding
		),
		'--pc-box-shadow': shadow ? `var(--p-shadow-${shadow})` : undefined,
		'--pc-box-width': width,
		position,
		'--pc-box-inset-block-start': insetBlockStart ? `var(--p-space-${insetBlockStart})` : undefined,
		'--pc-box-inset-block-end': insetBlockEnd ? `var(--p-space-${insetBlockEnd})` : undefined,
		'--pc-box-inset-inline-start': insetInlineStart
			? `var(--p-space-${insetInlineStart})`
			: undefined,
		'--pc-box-inset-inline-end': insetInlineEnd ? `var(--p-space-${insetInlineEnd})` : undefined,
		zIndex,
		opacity
	});

	const className = $derived(
		classNames(
			styles.Box,
			visuallyHidden && styles.visuallyHidden,
			printHidden && styles.printHidden,
			as === 'ul' && styles.listReset
		)
	);
</script>

<svelte:element
	this={as}
	class={className}
	style={createStyleString(sanitizeCustomProperties(style))}
	bind:this={ref}
	{...id ? { id } : {}}
	{...role ? { role } : {}}
	{...tabIndex ? { tabIndex } : {}}
	{...restProps}
>
	{@render children?.()}
</svelte:element>

```

# components/box/types.ts

```ts
import type { ResponsiveProp } from "$utilities/css.js";
import type { BorderRadiusAliasOrScale, BorderWidthScale, ColorBackgroundAlias, ColorBorderAlias, ColorTextAlias, ShadowAliasOrScale, SpaceScale } from "@shopify/polaris-tokens";
import type { Snippet } from "svelte";

export type Element = 'div' | 'span' | 'section' | 'legend' | 'ul' | 'li';

type LineStyles = 'solid' | 'dashed';
type Overflow = 'hidden' | 'scroll' | 'clip';
type Position = 'relative' | 'absolute' | 'fixed' | 'sticky';

type Spacing = ResponsiveProp<SpaceScale>;

export interface BoxProps {
  children?: Snippet;
  /** HTML Element type
   * @default 'div'
   */
  as?: Element;
  /** Background color */
  ref?: Element;
  background?: ColorBackgroundAlias;
  /** Border color */
  borderColor?: ColorBorderAlias | 'transparent';
  /** Border style */
  borderStyle?: LineStyles;
  /** Border radius */
  borderRadius?: BorderRadiusAliasOrScale;
  /** Vertical end horizontal start border radius */
  borderEndStartRadius?: BorderRadiusAliasOrScale;
  /** Vertical end horizontal end border radius */
  borderEndEndRadius?: BorderRadiusAliasOrScale;
  /** Vertical start horizontal start border radius */
  borderStartStartRadius?: BorderRadiusAliasOrScale;
  /** Vertical start horizontal end border radius */
  borderStartEndRadius?: BorderRadiusAliasOrScale;
  /** Border width */
  borderWidth?: BorderWidthScale;
  /** Vertical start border width */
  borderBlockStartWidth?: BorderWidthScale;
  /** Vertical end border width */
  borderBlockEndWidth?: BorderWidthScale;
  /** Horizontal start border width */
  borderInlineStartWidth?: BorderWidthScale;
  /** Horizontal end border width */
  borderInlineEndWidth?: BorderWidthScale;
  /** Color of children */
  color?: ColorTextAlias;
  /** HTML id attribute */
  id?: string;
  /** Minimum height of container */
  minHeight?: string;
  /** Minimum width of container */
  minWidth?: string;
  /** Maximum width of container */
  maxWidth?: string;
  /** Clip horizontal content of children */
  overflowX?: Overflow;
  /** Clip vertical content of children */
  overflowY?: Overflow;
  /** Spacing around children. Accepts a spacing token or an object of spacing tokens for different screen sizes.
   * @example
   * padding='400'
   * padding={{xs: '200', sm: '300', md: '400', lg: '500', xl: '600'}}
   */
  padding?: Spacing;
  /** Vertical start and end spacing around children. Accepts a spacing token or an object of spacing tokens for different screen sizes.
   * @example
   * paddingBlock='400'
   * paddingBlock={{xs: '200', sm: '300', md: '400', lg: '500', xl: '600'}}
   */
  paddingBlock?: Spacing;
  /** Vertical start spacing around children. Accepts a spacing token or an object of spacing tokens for different screen sizes.
   * @example
   * paddingBlockStart='400'
   * paddingBlockStart={{xs: '200', sm: '300', md: '400', lg: '500', xl: '600'}}
   */
  paddingBlockStart?: Spacing;
  /** Vertical end spacing around children. Accepts a spacing token or an object of spacing tokens for different screen sizes.
   * @example
   * paddingBlockEnd='400'
   * paddingBlockEnd={{xs: '200', sm: '300', md: '400', lg: '500', xl: '600'}}
   */
  paddingBlockEnd?: Spacing;
  /** Horizontal start and end spacing around children. Accepts a spacing token or an object of spacing tokens for different screen sizes.
   * @example
   * paddingInline='400'
   * paddingInline={{xs: '200', sm: '300', md: '400', lg: '500', xl: '600'}}
   */
  paddingInline?: Spacing;
  /** Horizontal start spacing around children. Accepts a spacing token or an object of spacing tokens for different screen sizes.
   * @example
   * paddingInlineStart='400'
   * paddingInlineStart={{xs: '200', sm: '300', md: '400', lg: '500', xl: '600'}}
   */
  paddingInlineStart?: Spacing;
  /** Horizontal end spacing around children. Accepts a spacing token or an object of spacing tokens for different screen sizes.
   * @example
   * paddingInlineEnd='400'
   * paddingInlineEnd={{xs: '200', sm: '300', md: '400', lg: '500', xl: '600'}}
   */
  paddingInlineEnd?: Spacing;
  /** Aria role */
  role?: 'status' | 'presentation' | 'menu' | 'listbox' | 'combobox' | 'group';
  /** Shadow on box */
  shadow?: ShadowAliasOrScale;
  /** Set tab order */
  tabIndex?: number;
  /** Width of container */
  width?: string;
  // These could be moved to new layout component(s) in the future
  /** Position of box */
  position?: Position;
  /** Top position of box */
  insetBlockStart?: Spacing;
  /** Bottom position of box */
  insetBlockEnd?: Spacing;
  /** Left position of box */
  insetInlineStart?: Spacing;
  /** Right position of box */
  insetInlineEnd?: Spacing;
  /** Opacity of box */
  opacity?: string;
  /** Outline color */
  outlineColor?: ColorBorderAlias;
  /** Outline style */
  outlineStyle?: LineStyles;
  /** Outline width */
  outlineWidth?: BorderWidthScale;
  /** Visually hide the contents during print */
  printHidden?: boolean;
  /** Visually hide the contents (still announced by screenreader) */
  visuallyHidden?: boolean;
  /** z-index of box */
  zIndex?: string;
}
```

# components/breadcrumbs/breadcrumbs.module.css

```css

```

# components/breadcrumbs/breadcrumbs.svelte

```svelte
<script lang="ts">
	import { handleMouseUpByBlurring } from '$utilities/focus.js';
	import ArrowLeftIcon from '@shopify/polaris-icons/dist/svg/ArrowLeftIcon.svg?component';
	import Button from '../button/button.svelte';
	import styles from './breadcrumbs.module.css';
	import type { BreadcrumbsProps } from './types.js';
	let { backAction }: BreadcrumbsProps = $props();
	const { content } = backAction;
</script>

<Button
	url={'url' in backAction ? backAction.url : undefined}
	onClick={'onAction' in backAction ? backAction.onAction : undefined}
	onPointerDown={handleMouseUpByBlurring}
	icon={ArrowLeftIcon}
	accessibilityLabel={backAction.accessibilityLabel ?? content}
/>

```

# components/breadcrumbs/types.ts

```ts
// Type definitions for breadcrumbs

import type { CallbackAction, LinkAction } from "$utilities/types.js";

export interface BreadcrumbsProps {
    /**
     * @deprecated Back action link
     * Use `breadcrumbs` prop instead as documented [here](https://shopify.dev/docs/api/app-bridge/previous-versions/actions/titlebar#using-titlebar-with-polaris)
     */
    backAction: CallbackAction | LinkAction;
}
```

# components/bulk-actions/bulk-actions.module.css

```css
.BulkActionsOuterLayout {
  position: relative;
  flex: 1;
  width: 100%;
}

.BulkActionsSelectAllWrapper {
  min-height: 24px;
  display: flex;
  align-items: center;
  gap: var(--p-space-200);
}

.BulkActionsPromotedActionsWrapper {
  flex: 1;
}

.BulkActionsLayout {
  display: flex;
  flex-wrap: wrap;
  align-items: center;
  justify-content: flex-end;
  flex: 1 1 auto;
  gap: var(--p-space-100);

  >* {
    flex: 0 0 auto;
  }
}

.BulkActionsLayout--measuring {
  visibility: hidden;
  height: 0;
}

.BulkActionsMeasurerLayout {
  position: absolute;
  display: flex;
  flex-wrap: wrap;
  align-items: center;
  justify-content: flex-end;
  flex: 1 1 auto;
  gap: 0;
  padding: 0;
  visibility: hidden;
  height: 0;
  width: 100%;

  >* {
    flex: 0 0 auto;
  }
}

.BulkActionButton {
  white-space: nowrap;

  button {
    display: flex;
  }
}

.disabled {
  /* stylelint-disable-next-line -- DO NOT COPY polaris-migrator */
  @mixin base-button-disabled;
  cursor: default;
  pointer-events: none;
}

.AllAction {
  border: 0;
  background: none;
  padding: 0;
  cursor: pointer;
  color: var(--p-color-text-emphasis);
  outline: none;
  /* stylelint-disable-next-line -- needed for focus ring */
  @mixin focus-ring;

  &:hover,
  &:focus {
    color: var(--p-color-text-emphasis-hover);
  }

  &:active {
    color: var(--p-color-text-emphasis-active);
  }

  &:focus-visible:not(:active) {
    /* stylelint-disable-next-line -- needed for focus ring */
    @mixin focus-ring base, 0, focused;
  }
}
```

# components/bulk-actions/bulk-actions.svelte

```svelte
<script lang="ts">
	import UnstyledButton from '../button/unstyled-button.svelte';
	import styles from './bulk-actions.module.css';
	import type {
		AriaLive,
		BulkAction,
		BulkActionListSection,
		BulkActionsProps,
		BulkActionsState
	} from './types.js';
	import {
		getActionSections,
		getVisibleAndHiddenActionsIndices,
		instanceOfBulkActionListSection,
		instanceOfMenuGroupDescriptor,
		isNewBadgeInBadgeActions
	} from './utilities.js';
	import Text from '../text/text.svelte';
	import type { ActionsMeasurements } from './components/bulk-action-measurer/types.js';
	import type { MenuGroupDescriptor } from '$utilities/types.js';
	import BulkActionMenu from './components/bulk-action-menu/bulk-action-menu.svelte';
	import BulkActionButton from './components/bulk-action-button/bulk-action-button.svelte';
	import Popover from '../popover/popover.svelte';
	import ActionList from '../action-list/action-list.svelte';
	import BulkActionsMeasurer from './components/bulk-action-measurer/bulk-action-measurer.svelte';
	import InlineStack from '../inline-stack/inline-stack.svelte';
	import CheckableButton from '../checkable-button/checkable-button.svelte';
	import { classNames } from '$utilities/css.js';

	let {
		promotedActions,
		actions,
		disabled,
		buttonSize,
		paginatedSelectAllAction,
		paginatedSelectAllText,
		label,
		accessibilityLabel,
		selected,
		onToggleAll,
		onMoreActionPopoverToggle,
		width,
		selectMode,
		ref = $bindable(),
	}: BulkActionsProps = $props();

	let popoverActive = $state(false);

	let states = $state<BulkActionsState>({
		disclosureWidth: 0,
		containerWidth: Infinity,
		actionsWidths: [],
		visiblePromotedActions: [],
		hiddenPromotedActions: [],
		hasMeasured: false
	});

	const {
		visiblePromotedActions,
		hiddenPromotedActions,
		containerWidth,
		disclosureWidth,
		actionsWidths,
		hasMeasured
	} = $derived(states);

	function updateState(partialData: Partial<BulkActionsState>): void {
		Object.assign(states, partialData);
	}

	$effect(() => {
		if (containerWidth === 0 || !promotedActions || promotedActions.length === 0) {
			return;
		}

		const { visiblePromotedActions, hiddenPromotedActions } = getVisibleAndHiddenActionsIndices(
			promotedActions,
			disclosureWidth,
			actionsWidths,
			containerWidth
		);

		/* states = {
			visiblePromotedActions,
			hiddenPromotedActions,
			hasMeasured: containerWidth !== Infinity
		}; */
		states.visiblePromotedActions = visiblePromotedActions;
		states.hiddenPromotedActions = hiddenPromotedActions;
		states.hasMeasured = containerWidth !== Infinity;
	});

	const activatorLabel = $derived(
		!promotedActions || (promotedActions && visiblePromotedActions.length === 0)
			? 'Actions'
			: 'More actions'
	);

	const hasTextAndAction = $derived(paginatedSelectAllText && paginatedSelectAllAction);

	const ariaLive: AriaLive = $derived(hasTextAndAction ? 'polite' : undefined);

	const checkableButtonProps = $derived({
		accessibilityLabel,
		label: hasTextAndAction ? paginatedSelectAllText : label,
		selected,
		onToggleAll,
		disabled,
		ariaLive,
		ref
	});

	const togglePopover = () => {
		onMoreActionPopoverToggle?.(popoverActive);
		popoverActive = !popoverActive;
	};

	const handleMeasurement = (measurements: ActionsMeasurements) => {
		const { hiddenActionsWidths: actionsWidths, containerWidth, disclosureWidth } = measurements;
		if (!promotedActions || promotedActions.length === 0) {
			return;
		}

		const { visiblePromotedActions, hiddenPromotedActions } = getVisibleAndHiddenActionsIndices(
			promotedActions,
			disclosureWidth,
			actionsWidths,
			containerWidth
		);

		updateState({
			visiblePromotedActions,
			hiddenPromotedActions,
			actionsWidths,
			containerWidth,
			disclosureWidth,
			hasMeasured: true
		});
	};

	const actionSections = $derived(getActionSections(actions));

	const filteredPromotedActions = $derived(
		promotedActions
			? promotedActions.filter((_, index) => {
					if (!visiblePromotedActions.includes(index)) {
						return false;
					}

					return true;
				})
			: []
	);

	const hiddenPromotedActionObjects = $derived(
		hiddenPromotedActions.map((index) => promotedActions?.[index])
	);

	const mergedHiddenPromotedActions = $derived(
		hiddenPromotedActionObjects.reduce(
			(memo, action) => {
				if (!action) return memo;
				if (instanceOfMenuGroupDescriptor(action)) {
					return memo.concat(action.actions);
				}
				return memo.concat(action);
			},
			[] as (BulkAction | MenuGroupDescriptor)[]
		)
	);

	const hiddenPromotedSection = $derived({
		items: mergedHiddenPromotedActions
	});

	const allHiddenActions = $derived.by(() => {
		if (actionSections) {
			return actionSections;
		}

		if (!actions) {
			return [];
		}

		let isAFlatArray = true;

		return actions
			.filter((action) => action)
			.reduce(
				(
					memo: BulkActionListSection[],
					action: BulkAction | BulkActionListSection
				): BulkActionListSection[] => {
					if (instanceOfBulkActionListSection(action)) {
						isAFlatArray = false;
						return memo.concat(action);
					}
					if (isAFlatArray) {
						if (memo.length === 0) {
							return [{ items: [action] }];
						}
						const lastItem = memo[memo.length - 1];
						memo.splice(memo.length - 1, 1, {
							items: [...lastItem.items, action]
						});
						return memo;
					}

					isAFlatArray = true;

					return memo.concat({ items: [action] });
				},
				[]
			);
	});
</script>

{#snippet paginatedSelectAllMarkup()}
	{#if paginatedSelectAllAction}
		<UnstyledButton
			className={styles.AllAction}
			onClick={paginatedSelectAllAction.onAction}
			size="slim"
			{disabled}
		>
			<Text as="span" variant="bodySm" fontWeight="medium">
				{paginatedSelectAllAction.content}
			</Text>
		</UnstyledButton>
	{/if}
{/snippet}

{#snippet promotedActionsMarkup()}
	{#each filteredPromotedActions as action}
		{#if instanceOfMenuGroupDescriptor(action)}
			<BulkActionMenu
				{...action}
				isNewBadgeInBadgeActions={isNewBadgeInBadgeActions(actionSections)}
				size={buttonSize}
			/>
		{:else}
			<BulkActionButton {disabled} {...action} size={buttonSize} />
		{/if}
	{/each}
{/snippet}

{#snippet activator()}
	<BulkActionButton
		disclosure
		showContentInButton={!promotedActionsMarkup}
		onAction={togglePopover}
		content={activatorLabel}
		{disabled}
		indicator={isNewBadgeInBadgeActions(actionSections)}
		size={buttonSize}
	/>
{/snippet}

{#snippet actionsMarkup()}
	{#if allHiddenActions.length > 0}
		<Popover active={popoverActive} preferredAlignment="right" onClose={togglePopover}>
			{#snippet trigger()}
				{@render activator()}
			{/snippet}
			<ActionList
				sections={hiddenPromotedSection.items.length > 0
					? [hiddenPromotedSection, ...allHiddenActions]
					: allHiddenActions}
				onActionAnyItem={togglePopover}
			/>
		</Popover>
	{/if}
{/snippet}

{#snippet measurerMarkup()}
	<BulkActionsMeasurer {promotedActions} {disabled} {buttonSize} {handleMeasurement} />
{/snippet}

<div class={styles.BulkActions} style={width ? `width: ${width}px` : undefined}>
	<InlineStack gap="400" blockAlign="center">
		<div class={styles.BulkActionsSelectAllWrapper}>
			<CheckableButton {...checkableButtonProps} />
			{@render paginatedSelectAllMarkup()}
		</div>
		{#if selectMode}
			<div class={styles.BulkActionsPromotedActionsWrapper}>
				<InlineStack gap="100" blockAlign="center">
					<div class={styles.BulkActionsOuterLayout}>
						{@render measurerMarkup()}
						<div
							class={classNames(
								styles.BulkActionsLayout,
								!hasMeasured && styles['BulkActionsLayout--measuring']
							)}
						>
							{@render promotedActionsMarkup()}
						</div>
					</div>
					{@render actionsMarkup()}
				</InlineStack>
			</div>
		{/if}
	</InlineStack>
</div>

```

# components/bulk-actions/components/bulk-action-button/bulk-action-button.svelte

```svelte
<script lang="ts">
	import { onMount } from 'svelte';
	import type { BulkActionButtonProps } from './types.js';
	import Button from '$lib/components/button/button.svelte';
	import MenuHorizontalIcon from '@shopify/polaris-icons/dist/svg/MenuHorizontalIcon.svg?component';
	import styles from '../../bulk-actions.module.css';
	import Tooltip from '$lib/components/tooltip/tooltip.svelte';
	import Indicator from '$lib/components/indicator/indicator.svelte';

	let {
		handleMeasurement,
		url,
		external,
		onAction,
		content,
		disclosure,
		accessibilityLabel,
		disabled,
		destructive,
		indicator,
		showContentInButton,
		size
	}: BulkActionButtonProps = $props();

	let bulkActionButton = $state<HTMLDivElement | null>(null);

	onMount(() => {
		if (handleMeasurement && bulkActionButton) {
			const width = bulkActionButton.getBoundingClientRect().width;
			handleMeasurement(width);
		}
	});

	const isActivatorForMoreActionsPopover = $derived(disclosure && !showContentInButton);
	const buttonContent = $derived(isActivatorForMoreActionsPopover ? undefined : content);
</script>

{#snippet buttonMarkup()}
	<Button
		{external}
		{url}
		accessibilityLabel={isActivatorForMoreActionsPopover ? content : accessibilityLabel}
		tone={destructive ? 'critical' : undefined}
		disclosure={disclosure && showContentInButton}
		onClick={onAction}
		{disabled}
		{size}
		icon={isActivatorForMoreActionsPopover ? MenuHorizontalIcon : undefined}
	>
		{buttonContent}
	</Button>
{/snippet}

<div class={styles.BulkActionButton} bind:this={bulkActionButton}>
	{#if isActivatorForMoreActionsPopover && content}
		<Tooltip {content} preferredPosition="below">
			{@render buttonMarkup()}
		</Tooltip>
	{:else}
		{@render buttonMarkup()}
	{/if}

	{#if indicator}
		<Indicator />
	{/if}
</div>

```

# components/bulk-actions/components/bulk-action-button/types.ts

```ts
import type { ButtonProps } from "$lib/components/button/button.types.js";
import type { DestructableAction, DisableableAction } from "$utilities/types.js";

export type BulkActionButtonProps = {
    disclosure?: boolean;
    indicator?: boolean;
    handleMeasurement?(width: number): void;
    showContentInButton?: boolean;
    size?: Extract<ButtonProps['size'], 'micro' | 'medium'>;
} & DisableableAction &
    DestructableAction;
```

# components/bulk-actions/components/bulk-action-measurer/bulk-action-measurer.svelte

```svelte
<script lang="ts">
	import { instanceOfMenuGroupDescriptor } from '../../utilities.js';
	import BulkActionButton from '../bulk-action-button/bulk-action-button.svelte';
	import styles from '../../bulk-actions.module.css';
	import { ACTION_SPACING, type ActionsMeasurerProps } from './types.js';

	let {
		promotedActions = [],
		disabled,
		buttonSize,
		handleMeasurement: handleMeasurementProp
	}: ActionsMeasurerProps = $props();

	let containerNode = $state<HTMLDivElement | null>(null);
	const activatorLabel = 'More actions';

	const handleMeasurement = () => {
		if (!containerNode) {
			return;
		}

		const containerWidth = containerNode.offsetWidth;
		const hiddenActionNodes = containerNode.children;
		const hiddenActionNodesArray = Array.from(hiddenActionNodes);
		const hiddenActionsWidths = hiddenActionNodesArray.map((node) => {
			const buttonWidth = Math.ceil(node.getBoundingClientRect().width);
			return buttonWidth + ACTION_SPACING;
		});
		const disclosureWidth = hiddenActionsWidths.pop() || 0;

		handleMeasurementProp({
			containerWidth,
			disclosureWidth,
			hiddenActionsWidths
		});
	};

	$effect(() => {
		handleMeasurement();
	});

	$effect(() => {
		window.addEventListener('resize', handleMeasurement);
		return () => {
			window.removeEventListener('resize', handleMeasurement);
		};
	});
</script>

{#snippet activator()}
	<BulkActionButton disclosure content={activatorLabel} />
{/snippet}

{#snippet promotedActionsMarkup()}
	{#each promotedActions as action, index}
		{#if instanceOfMenuGroupDescriptor(action)}
			<BulkActionButton disclosure showContentInButton content={action.title} size={buttonSize} />
		{:else}
			<BulkActionButton {disabled} {...action} size={buttonSize} />
		{/if}
	{/each}
{/snippet}

<div class={styles.BulkActionsMeasurerLayout} bind:this={containerNode}>
	{@render promotedActionsMarkup()}
	{@render activator()}
</div>

```

# components/bulk-actions/components/bulk-action-measurer/types.ts

```ts
import type { BulkActionsProps } from "../../types.js";

export interface ActionsMeasurements {
    containerWidth: number;
    disclosureWidth: number;
    hiddenActionsWidths: number[];
}

export interface ActionsMeasurerProps {
    /** Collection of page-level action groups */
    promotedActions?: BulkActionsProps['promotedActions'];
    disabled?: BulkActionsProps['disabled'];
    buttonSize?: BulkActionsProps['buttonSize'];
    handleMeasurement(measurements: ActionsMeasurements): void;
}

export const ACTION_SPACING = 4;
```

# components/bulk-actions/components/bulk-action-menu/bulk-action-menu.svelte

```svelte
<script lang="ts">
	import ActionList from '$lib/components/action-list/action-list.svelte';
	import Popover from '$lib/components/popover/index.js';
	import { UseToggle } from '$lib/use/use-toggle.svelte.js';
	import BulkActionButton from '../bulk-action-button/bulk-action-button.svelte';
	import type { BulkActionsMenuProps } from './types.js';

	let { title, actions, isNewBadgeInBadgeActions, size }: BulkActionsMenuProps = $props();

	const isVisible = new UseToggle(false);
	const toggleMenuVisibility = isVisible.toggle;
</script>

<Popover active={isVisible.value} onClose={toggleMenuVisibility} preferInputActivator>
	{#snippet trigger()}
		<BulkActionButton
			disclosure
			showContentInButton
			onAction={toggleMenuVisibility}
			content={title}
			indicator={isNewBadgeInBadgeActions}
			size={size}
		/>
	{/snippet}
	<ActionList items={actions} onActionAnyItem={toggleMenuVisibility} />
</Popover>

```

# components/bulk-actions/components/bulk-action-menu/types.ts

```ts
import type { ButtonProps } from "$lib/components/button/button.types.js";
import type { MenuGroupDescriptor } from "$utilities/types.js";

export interface BulkActionsMenuProps extends MenuGroupDescriptor {
    isNewBadgeInBadgeActions: boolean;
    size?: Extract<ButtonProps['size'], 'micro' | 'medium'>;
}

```

# components/bulk-actions/types.ts

```ts
import type { Action, ActionListSection, BadgeAction, CheckboxHandles, DisableableAction, MenuGroupDescriptor } from "$utilities/types.js";
import type { ButtonProps } from "../button/button.types.js";

export type BulkAction = DisableableAction & BadgeAction;

export type BulkActionListSection = ActionListSection;

export type AriaLive = 'off' | 'polite' | undefined;

export interface BulkActionsProps {
    /** Visually hidden text for screen readers */
    accessibilityLabel?: string;
    /** State of the bulk actions checkbox */
    selected?: boolean;
    /** Text to select all across pages */
    paginatedSelectAllText?: string;
    /** Action for selecting all across pages */
    paginatedSelectAllAction?: Action;
    /** Callback when the select all checkbox is clicked */
    onToggleAll?(): void;
    /** Actions that will be given more prominence */
    promotedActions?: (BulkAction | MenuGroupDescriptor)[];
    /** List of actions */
    actions?: (BulkAction | BulkActionListSection)[];
    /** Disables bulk actions */
    disabled?: boolean;
    /** Callback when more actions button is toggled */
    onMoreActionPopoverToggle?(isOpen: boolean): void;
    /** The size of the buttons to render */
    buttonSize?: Extract<ButtonProps['size'], 'micro' | 'medium'>;
    /** Label for the bulk actions */
    label?: string;
    /** List is in a selectable state. Will only render the bulk actions when `true` */
    selectMode?: boolean;
    ref?: CheckboxHandles | null;
    /** @deprecated Callback when selectable state of list is changed. Unused callback */
    onSelectModeToggle?(selectMode: boolean): void;
    /** @deprecated If the BulkActions is currently sticky in view */
    isSticky?: boolean;
    /** @deprecated The width of the BulkActions */
    width?: number;
}

export interface BulkActionsState {
    visiblePromotedActions: number[];
    hiddenPromotedActions: number[];
    actionsWidths: number[];
    containerWidth: number;
    disclosureWidth: number;
    hasMeasured: boolean;
}
```

# components/bulk-actions/utilities.ts

```ts
import type { ActionListSection, BadgeAction, DisableableAction, MenuGroupDescriptor } from "$utilities/types.js";
import type { BulkActionsProps } from "./types.js";

type BulkActionListSection = ActionListSection;

export function getVisibleAndHiddenActionsIndices(
    promotedActions: any[] = [],
    disclosureWidth: number,
    actionsWidths: number[],
    containerWidth: number,
) {
    const sumTabWidths = actionsWidths.reduce((sum, width) => sum + width, 0);
    const arrayOfPromotedActionsIndices = promotedActions.map((_, index) => {
        return index;
    });

    const visiblePromotedActions: number[] = [];
    const hiddenPromotedActions: number[] = [];

    if (containerWidth > sumTabWidths) {
        visiblePromotedActions.push(...arrayOfPromotedActionsIndices);
    } else {
        let accumulatedWidth = 0;
        let hasReturned = false;

        arrayOfPromotedActionsIndices.forEach((currentPromotedActionsIndex) => {
            const currentActionsWidth = actionsWidths[currentPromotedActionsIndex];
            const notEnoughSpace =
                accumulatedWidth + currentActionsWidth >=
                containerWidth - disclosureWidth;

            if (notEnoughSpace || hasReturned) {
                hiddenPromotedActions.push(currentPromotedActionsIndex);
                hasReturned = true;
                return;
            }

            visiblePromotedActions.push(currentPromotedActionsIndex);
            accumulatedWidth += currentActionsWidth;
        });
    }

    return {
        visiblePromotedActions,
        hiddenPromotedActions,
    };
}

export function instanceOfBulkActionListSectionArray(
    actions: (BulkAction | BulkActionListSection)[],
): actions is BulkActionListSection[] {
    const validList = actions.filter((action: any) => {
        return action.items;
    });

    return actions.length === validList.length;
}

export function instanceOfBulkActionArray(
    actions: (BulkAction | BulkActionListSection)[],
): actions is BulkAction[] {
    const validList = actions.filter((action: any) => {
        return !action.items;
    });

    return actions.length === validList.length;
}

export type BulkAction = DisableableAction & BadgeAction;

export function instanceOfMenuGroupDescriptor(
    action: MenuGroupDescriptor | BulkAction,
): action is MenuGroupDescriptor {
    return 'title' in action && 'actions' in action;
}

export function instanceOfBulkActionListSection(
    action: BulkAction | BulkActionListSection,
): action is BulkActionListSection {
    return 'items' in action;
}

export function getActionSections(
    actions: BulkActionsProps['actions'],
): BulkActionListSection[] | undefined {
    if (!actions || actions.length === 0) {
        return;
    }

    if (instanceOfBulkActionListSectionArray(actions)) {
        return actions;
    }

    if (instanceOfBulkActionArray(actions)) {
        return [
            {
                items: actions,
            },
        ];
    }
}

export function isNewBadgeInBadgeActions(
    actionSections?: BulkActionListSection[],
) {
    if (!actionSections) return false;

    for (const action of actionSections) {
        for (const item of action.items) {
            if (item.badge?.tone === 'new') return true;
        }
    }

    return false;
}
```

# components/button-group/button-group.module.css

```css
.ButtonGroup {
    /* stylelint-disable -- ButtonGroup custom properties */
    --pc-button-group-item: 10;
    --pc-button-group-focused: 20;
    /* stylelint-enable */
    display: flex;
    flex-wrap: wrap;
    align-items: center;
    margin-top: calc(-1 * var(--p-space-200));
    margin-left: calc(-1 * var(--p-space-200));
}

.Item {
    margin-top: var(--p-space-200);
    margin-left: var(--p-space-200);
}

.Item-plain {
    &:not(:first-child) {
        margin-left: var(--p-space-200);
    }

    &:not(:last-child) {
        margin-right: var(--p-space-200);
    }
}

.variantSegmented {
    display: flex;
    flex-wrap: nowrap;
    margin-top: 0;
    margin-left: 0;

    .Item {
        position: relative;
        margin-top: 0;
        margin-left: 0;
        line-height: 1;

        &:not(:first-child) {
            margin-left: calc(-1 * var(--p-space-025));
        }
    }

    [aria-pressed='true'] {
        /* stylelint-disable-next-line  -- bring pressed button to top */
        z-index: var(--pc-button-group-item);
    }

    .Item-focused {
        /* stylelint-disable-next-line  -- custom property */
        z-index: var(--pc-button-group-focused);
    }
}

.fullWidth {
    .Item {
        flex: 1 1 auto;
    }
}

.extraTight {
    margin-top: calc(-1 * var(--p-space-100));
    margin-left: calc(-1 * var(--p-space-100));

    .Item {
        margin-top: var(--p-space-100);
        margin-left: var(--p-space-100);
    }
}

.tight {
    margin-top: calc(-1 * var(--p-space-200));
    margin-left: calc(-1 * var(--p-space-200));

    .Item {
        margin-top: var(--p-space-200);
        margin-left: var(--p-space-200);
    }
}

.loose {
    margin-top: calc(-1 * var(--p-space-500));
    margin-left: calc(-1 * var(--p-space-500));

    .Item {
        margin-top: var(--p-space-500);
        margin-left: var(--p-space-500);
    }
}

.noWrap {
    display: flex;
    flex-wrap: nowrap;
}
```

# components/button-group/button-group.svelte

```svelte
<script lang="ts">
	import { classNames, variationName } from '$utilities/css.js';
	import styles from './button-group.module.css';
	import type { ButtonGroupProps } from './types.js';

	let { children, gap, variant, fullWidth, connectedTop, noWrap, itemCount }: ButtonGroupProps = $props();

	const className = $derived(
		classNames(
			styles.ButtonGroup,
			gap && styles[gap],
			variant && styles[variationName('variant', variant)],
			fullWidth && styles.fullWidth,
			noWrap && styles.noWrap
		)
	);
</script>

<div
	class={className}
	data-buttongroup-variant={variant}
	data-buttongroup-connected-top={connectedTop}
	data-buttongroup-full-width={fullWidth}
	data-buttongroup-no-wrap={noWrap}
>
	{@render children?.()}
</div>

```

# components/button-group/components/item/button-group-item.svelte

```svelte
<script lang="ts">
	import { UseToggle } from '$lib/use/use-toggle.svelte.js';
	import styles from '../../button-group.module.css';
	import { classNames } from '$utilities/css.js';
	import type { ButtonProps } from '$lib/components/button/button.types.js';
	import type { Snippet } from 'svelte';

	interface ItemProps {
		children: Snippet;
		variant?: ButtonProps['variant'];
	}

	let { children, variant }: ItemProps = $props();
	
	const focused = new UseToggle(false);
	const forceTrueFocused = focused.setTrue;
	const forceFalseFocused = focused.setFalse;

	const className = $derived(
		classNames(
			styles.Item,
			focused.value && styles['Item-focused'],
			variant === 'plain' && styles['Item-plain']
		)
	);
</script>

<div class={className} onfocus={forceTrueFocused} onblur={forceFalseFocused}>
	{@render children?.()}
</div>

```

# components/button-group/index.ts

```ts
import ButtonGroupItemComponent from "./components/item/button-group-item.svelte";
import ButtonGroupComponent from "./button-group.svelte";

type ButtonGroupCompoundType = typeof ButtonGroupComponent & {
    Item: typeof ButtonGroupItemComponent;
};

const ButtonGroup = ButtonGroupComponent as ButtonGroupCompoundType;
ButtonGroup.Item = ButtonGroupItemComponent;

export default ButtonGroup;

```

# components/button-group/types.ts

```ts
import type { Snippet } from "svelte";

export type Gap = 'extraTight' | 'tight' | 'loose';
export type Variant = 'segmented';

export interface ButtonGroupProps {
    /** Determines the space between button group items */
    gap?: Gap;
    /** Styling variant for group */
    variant?: Variant;
    /** Buttons will stretch/shrink to occupy the full width */
    fullWidth?: boolean;
    /** Remove top left and right border radius */
    connectedTop?: boolean;
    /** Prevent buttons in button group from wrapping to next line */
    noWrap?: boolean;
    /** Button components */
    children?: Snippet;
    itemCount?: number
}
```

# components/button/button-from.svelte

```svelte
<script lang="ts">
	import type { ComplexAction } from '$utilities/types.js';
	import Button from './button.svelte';
	import type { ButtonProps } from './button.types.js';
	
	interface Props {
		action: ComplexAction;
		overrides?: Partial<ButtonProps>;
	}

	let { action, overrides, ...rest }: Props = $props();
	const plainVariant = $derived(overrides?.variant);
	const tone = $derived(!overrides?.tone && action.destructive ? 'critical' : overrides?.tone);
	const { onAction } = action;
</script>

<Button
	{...rest}
	{...action}
	{...overrides}
	onClick={onAction}
	variant={plainVariant}
	{tone}
	accessibilityLabel={action.accessibilityLabel}
	url={action.url}
	external={action.external}
	target={action.target}>
	{action.content}
</Button>

```

# components/button/button.module.css

```css
/* stylelint-disable polaris/conventions/polaris/custom-property-allowed-list -- allow custom component properties */

.Button {
    --pc-button-gap: var(--p-space-050);
    --pc-button-bg: transparent;
    --pc-button-bg_hover: var(--pc-button-bg);
    --pc-button-bg_active: var(--pc-button-bg);
    --pc-button-bg_pressed: var(--pc-button-bg_active);
    --pc-button-bg_disabled: var(--p-color-bg-fill-disabled);
    --pc-button-color: inherit;
    --pc-button-color_hover: var(--pc-button-color);
    --pc-button-color_active: var(--pc-button-color);
    --pc-button-color_pressed: var(--pc-button-color_active);
    --pc-button-color_disabled: var(--p-color-text-disabled);
    --pc-button-box-shadow: transparent;
    --pc-button-box-shadow_hover: var(--pc-button-box-shadow);
    --pc-button-box-shadow_active: var(--pc-button-box-shadow);
    --pc-button-box-shadow_pressed: var(--pc-button-box-shadow_active);
    --pc-button-box-shadow_disabled: var(--pc-button-box-shadow);
    --pc-button-icon-fill: currentColor;
    --pc-button-icon-fill_hover: var(--pc-button-icon-fill);
    --pc-button-icon-fill_active: var(--pc-button-icon-fill);
    --pc-button-icon-fill_pressed: var(--pc-button-icon-fill_active);
    --pc-button-icon-fill_disabled: var(--p-color-icon-disabled);
    all: unset;
    position: relative;
    box-sizing: border-box;
    display: inline-flex;
    align-items: center;
    gap: var(--pc-button-gap);
    padding: var(--pc-button-padding-block) var(--pc-button-padding-inline);
    background: var(--pc-button-bg);
    border: none;
    border-radius: var(--p-border-radius-200);
    box-shadow: var(--pc-button-box-shadow);
    color: var(--pc-button-color);
    cursor: pointer;
    user-select: none;
    touch-action: manipulation;
    -webkit-tap-highlight-color: transparent;
  }
  
  /* https://developer.mozilla.org/en-US/docs/Web/CSS/Specificity#increasing_specificity_by_duplicating_selector
     Remove the duplicate selectors once `Icon` supports no fill so there won't be competing specificity */
  /* stylelint-disable selector-max-specificity -- Duplicate selectors to bump specificity to be greater than Icon's svg fill (0, 1, 1) */
  .Button.Button svg {
    fill: var(--pc-button-icon-fill);
  }
  
  .Button.Button:hover svg {
    fill: var(--pc-button-icon-fill_hover);
  }
  
  .Button.Button:active,
  .Button.Button[data-state='open'] svg {
    fill: var(--pc-button-icon-fill_active);
  }
  
  .Button.Button:disabled,
  .Button.Button[disabled],
  .disabled.disabled svg {
    fill: var(--pc-button-icon-fill_disabled);
  }
  
  .pressed.pressed,
  .pressed.pressed:hover,
  .pressed.pressed:active,
  .pressed.pressed:focus-visible svg {
    fill: var(--pc-button-icon-fill_pressed);
  }
  /* stylelint-enable selector-max-specificity */
  
  .Button:hover {
    background: var(--pc-button-bg_hover);
    color: var(--pc-button-color_hover);
    box-shadow: var(--pc-button-box-shadow_hover);
  }
  
  .Button:active,
  .Button[data-state='open'] {
    background: var(--pc-button-bg_active);
    color: var(--pc-button-color_active);
    box-shadow: var(--pc-button-box-shadow_active);
  }
  
  .Button:focus-visible {
    background: var(--pc-button-bg_hover);
    color: var(--pc-button-color_hover);
    outline: var(--p-border-width-050) solid var(--p-color-border-focus);
    outline-offset: var(--p-space-025);
  
    /* Disable focus-ring mixin to prevent overlap of focus-ring and outline */
    &::after {
      content: none;
    }
  }
  
  .Button:disabled,
  .Button[disabled],
  .disabled {
    background: var(--pc-button-bg_disabled);
    color: var(--pc-button-color_disabled);
    box-shadow: none;
    user-select: none;
    pointer-events: none;
  }
  
  .pressed,
  .pressed:hover,
  .pressed:active,
  .pressed:focus-visible {
    background: var(--pc-button-bg_pressed);
    color: var(--pc-button-color_pressed);
    box-shadow: var(--pc-button-box-shadow_pressed);
  }
  
  /* VARIANTS */
  .variantPrimary {
    --pc-button-bg-gradient: var(--p-color-button-gradient-bg-fill);
    --pc-button-box-shadow: var(--p-shadow-button-primary);
    --pc-button-box-shadow_active: var(--p-shadow-button-primary-inset);
    --pc-button-bg: var(--pc-button-bg-gradient), var(--p-color-bg-fill-brand);
    --pc-button-bg_hover: var(--pc-button-bg-gradient),
      var(--p-color-bg-fill-brand-hover);
    --pc-button-bg_active: var(--pc-button-bg-gradient),
      var(--p-color-bg-fill-brand-active);
    --pc-button-bg_disabled: var(--p-color-bg-fill-brand-disabled);
    --pc-button-color: var(--p-color-text-brand-on-bg-fill);
    --pc-button-color_disabled: var(--p-color-text-brand-on-bg-fill-disabled);
    --pc-button-icon-fill: var(--p-color-text-brand-on-bg-fill);
    --pc-button-icon-fill_disabled: var(--p-color-text-brand-on-bg-fill-disabled);
  }
  
  .variantSecondary {
    --pc-button-box-shadow: var(--p-shadow-button);
    --pc-button-box-shadow_active: var(--p-shadow-button-inset);
    --pc-button-bg: var(--p-color-bg-fill);
    --pc-button-bg_hover: var(--p-color-bg-fill-hover);
    --pc-button-bg_active: var(--p-color-bg-fill-active);
    --pc-button-bg_pressed: var(--p-color-bg-fill-selected);
    --pc-button-color: var(--p-color-text);
    --pc-button-icon-fill: var(--p-color-icon);
  }
  
  .variantTertiary {
    --pc-button-bg_hover: var(--p-color-bg-fill-transparent-hover);
    --pc-button-bg_active: var(--p-color-bg-fill-transparent-active);
    --pc-button-bg_pressed: var(--p-color-bg-fill-selected);
    --pc-button-bg_disabled: transparent;
    --pc-button-color: var(--p-color-text);
    --pc-button-icon-fill: var(--p-color-icon);
  }
  
  .variantPlain {
    --pc-button-color: var(--p-color-text-link);
    --pc-button-color_hover: var(--p-color-text-link-hover);
    --pc-button-color_active: var(--p-color-text-link-active);
  }
  
  .variantPlain:is(:hover, :active, :focus-visible):not(.removeUnderline) {
    text-decoration: underline;
  }
  
  .variantMonochromePlain {
    --pc-button-icon-fill: currentColor;
  }
  
  .variantPlain,
  .variantMonochromePlain {
    --pc-button-bg_disabled: transparent;
    margin: calc(-1 * var(--pc-button-padding-block))
      calc(-1 * var(--pc-button-padding-inline));
  }
  
  .variantPlain:focus-visible,
  .variantMonochromePlain:focus-visible {
    border-radius: var(--p-border-radius-300);
    outline-offset: calc(-1 * var(--pc-button-padding-block));
  }
  
  /* TONES */
  .toneSuccess:is(.variantSecondary, .variantTertiary, .variantPlain) {
    --pc-button-color: var(--p-color-text-success);
    --pc-button-color_hover: var(--p-color-text-success-hover);
    --pc-button-color_active: var(--p-color-text-success-active);
    --pc-button-icon-fill: currentColor;
  }
  
  .toneCritical:is(.variantSecondary, .variantTertiary, .variantPlain) {
    --pc-button-color: var(--p-color-text-critical);
    --pc-button-color_hover: var(--p-color-text-critical-hover);
    --pc-button-color_active: var(--p-color-text-critical-active);
    --pc-button-icon-fill: currentColor;
  }
  
  .toneSuccess:is(.variantPrimary) {
    --pc-button-box-shadow: var(--p-shadow-button-primary-success);
    --pc-button-box-shadow_active: var(--p-shadow-button-primary-success-inset);
    --pc-button-bg: var(--p-color-bg-fill-success);
    --pc-button-bg_hover: var(--p-color-bg-fill-success-hover);
    --pc-button-bg_active: var(--p-color-bg-fill-success-active);
    --pc-button-bg_pressed: var(--p-color-bg-fill-success-selected);
  }
  
  .toneCritical:is(.variantPrimary) {
    --pc-button-box-shadow: var(--p-shadow-button-primary-critical);
    --pc-button-box-shadow_active: var(--p-shadow-button-primary-critical-inset);
    --pc-button-bg: var(--p-color-bg-fill-critical);
    --pc-button-bg_hover: var(--p-color-bg-fill-critical-hover);
    --pc-button-bg_active: var(--p-color-bg-fill-critical-active);
    --pc-button-bg_pressed: var(--p-color-bg-fill-critical-selected);
  }
  
  /* SIZES */
  .sizeMicro {
    --pc-button-padding-block: var(--p-space-100);
    --pc-button-padding-inline: var(--p-space-200);
    min-height: var(--p-height-700);
    min-width: var(--p-width-700);
  
    @media (--p-breakpoints-md-up) {
      min-height: var(--p-height-600);
      min-width: var(--p-width-600);
    }
  }
  
  .sizeSlim,
  .sizeMedium {
    --pc-button-padding-block: var(--p-space-150);
    --pc-button-padding-inline: var(--p-space-300);
    min-height: var(--p-height-800);
    min-width: var(--p-width-800);
  
    @media (--p-breakpoints-md-up) {
      min-height: var(--p-height-700);
      min-width: var(--p-width-700);
    }
  }
  
  .sizeLarge {
    --pc-button-padding-block: var(--p-space-150);
    --pc-button-padding-inline: var(--p-space-300);
    min-height: var(--p-height-900);
    min-width: var(--p-height-900);
  
    @media (--p-breakpoints-md-up) {
      min-height: var(--p-height-800);
      min-width: var(--p-width-800);
    }
  }
  
  /* TEXT ALIGNMENT */
  .textAlignCenter {
    justify-content: center;
    text-align: center;
  }
  
  .textAlignStart,
  .textAlignLeft {
    justify-content: start;
    text-align: start;
  }
  
  .textAlignEnd,
  .textAlignRight {
    justify-content: end;
    text-align: end;
  }
  
  /* WIDTH */
  .fullWidth {
    width: 100%;
  }
  
  /* ICON */
  .iconOnly {
    --pc-button-padding-block: var(--p-space-100);
    --pc-button-padding-inline: var(--p-space-100);
  }
  
  .iconOnly:is(.sizeLarge) {
    --pc-button-padding-block: var(--p-space-150);
    --pc-button-padding-inline: var(--p-space-150);
  }
  
  .iconOnly:is(.sizeMicro) {
    --pc-button-padding-block: var(--p-space-050);
    --pc-button-padding-inline: var(--p-space-050);
  }
  
  .iconOnly:is(.variantTertiary) {
    margin: calc(-1 * var(--pc-button-padding-block))
      calc(-1 * var(--pc-button-padding-inline));
  }
  
  .iconOnly:is(.variantTertiary, .variantPlain):not(.toneCritical) {
    --pc-button-icon-fill: var(--p-color-icon-secondary);
    --pc-button-icon-fill_hover: var(--p-color-icon-secondary-hover);
    --pc-button-icon-fill_active: var(--p-color-icon-secondary-active);
    --pc-button-icon-fill_disabled: var(--p-color-icon-disabled);
  }
  
  .iconOnly:is(.variantMonochromePlain) {
    --pc-button-icon-fill: currentColor;
    --pc-button-icon-fill_hover: var(--p-color-icon-secondary-hover);
    --pc-button-icon-fill_active: var(--p-color-icon-secondary-active);
    --pc-button-icon-fill_disabled: var(--p-color-icon-disabled);
  }
  
  .iconOnly:is(.variantPlain, .variantMonochromePlain) {
    --pc-button-padding-block: 0;
    --pc-button-padding-inline: 0;
    margin: 0;
    min-height: var(--p-height-500);
    min-width: var(--p-width-500);
  }
  
  .iconWithText:not(.variantPlain, .variantMonochromePlain) {
    padding-left: calc(var(--pc-button-padding-inline) * 0.5);
  }
  
  /* DISCLOSURE */
  .disclosure:not(.variantPlain, .variantMonochromePlain) {
    padding-right: calc(var(--pc-button-padding-inline) * 0.5);
  }
  
  .disclosure:is(.textAlignStart, .textAlignLeft) {
    justify-content: space-between;
  }
  
  /* LOADING */
  .loading {
    color: transparent;
  }
  
  /* INTERACTION */
  .pressable:active:not(.variantTertiary, .variantPlain, .variantMonochromePlain)
    > * {
    transform: translate3d(0, 1px, 0);
  }
  
  /* UTILITIES */
  .hidden {
    visibility: hidden;
  }
  
  /* ICON */
  .Icon {
    margin: calc(-1 * var(--p-space-050)) 0;
  }
  
  /* SPINNER */
  .Spinner {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
  
    svg {
      fill: var(--pc-button-icon-fill_disabled);
      vertical-align: middle;
    }
  }
  
  /* BUTTON GROUP */
  /* stylelint-disable -- selector-max-combinators */
  [data-buttongroup-variant='segmented']
    > *:not(:first-child)
    .Button:is(.variantPrimary) {
    margin-left: calc(-1 * var(--p-space-025));
  }
  
  [data-buttongroup-variant='segmented'] > *:not(:first-child) .Button {
    border-top-left-radius: var(--p-border-radius-0);
    border-bottom-left-radius: var(--p-border-radius-0);
  }
  
  [data-buttongroup-variant='segmented'] > *:not(:last-child) .Button {
    border-top-right-radius: var(--p-border-radius-0);
    border-bottom-right-radius: var(--p-border-radius-0);
  }
  
  [data-buttongroup-full-width='true'] .Button {
    width: 100%;
  
    @media (--p-breakpoints-md-up) {
      white-space: nowrap;
    }
  }
  
  [data-buttongroup-connected-top='true'] > *:first-child .Button {
    border-top-left-radius: var(--p-border-radius-0);
  }
  
  [data-buttongroup-connected-top='true'] > *:last-child .Button {
    border-top-right-radius: var(--p-border-radius-0);
  }
  
  /* stylelint-enable -- selector-max-combinators */
```

# components/button/button.svelte

```svelte
<script lang="ts">
	import { classNames, variationName } from '$utilities/css.js';
	import type {
		ActionButtonProps,
		ButtonProps,
		CommonButtonProps,
		LinkButtonProps
	} from './button.types.js';
	import styles from './button.module.css';
	import { UseBreakpoints, useBreakpoints } from '$lib/use/use-breakpoints.svelte.js';
	import UnstyledButton from './unstyled-button.svelte';
	import Text from '../text/text.svelte';
	import Spinner from '../spinner/spinner.svelte';
	import ChevronUpIcon from '@shopify/polaris-icons/dist/svg/ChevronUpIcon.svg?component';
	import CaretDownIcon from '@shopify/polaris-icons/dist/svg/CaretDownIcon.svg?component';
	import SelectIcon from '@shopify/polaris-icons/dist/svg/SelectIcon.svg?component';
	import type { IconSource } from '$utilities/types.js';
	import Icon from '../icon/icon.svelte';

	let {
		size = 'medium',
		variant = 'secondary',
		textAlign = 'start',
		disabled = false,
		loading = false,
		fullWidth = false,
		disclosure = false,
		removeUnderline = false,
		tone,
		pressed = false,
		url,
		icon,
		id,
		accessibilityLabel,
		ariaDescribedBy,
		role,
		dataPrimaryLink,
		external,
		download,
		target,
		submit,
		ariaControls,
		ariaExpanded,
		ariaChecked,
		triggerProps,
		ref = $bindable(),
		onClick,
		onFocus,
		onBlur,
		onKeyDown,
		onKeyPress,
		onKeyUp,
		onMouseEnter,
		onTouchStart,
		children
	}: ButtonProps & LinkButtonProps & ActionButtonProps = $props();
	const hasPlainText = $derived(['plain', 'monochromePlain'].includes(variant));
	const bp = new UseBreakpoints();
	const breakpoints = $derived(bp.getCurrentBreakpoints());

	const textFontWeight = $derived(() => {
		if (hasPlainText) {
			return 'regular';
		}

		if (variant === 'primary') {
			return breakpoints?.mdUp ? 'medium' : 'semibold';
		}

		return 'medium';
	});

	const textVariant = $derived(() => {
		if (size === 'large' || (hasPlainText && size !== 'micro')) {
			return 'bodyMd';
		}

		return 'bodySm';
	});

	const isDisabled = $derived(disabled || loading);

	const className = $derived(
		classNames(
			styles.Button,
			styles.pressable,
			styles[variationName('variant', variant)],
			styles[variationName('size', size)],
			styles[variationName('textAlign', textAlign)],
			fullWidth && styles.fullWidth,
			disclosure && styles.disclosure,
			icon && styles.iconWithText,
			icon && styles.iconOnly,
			isDisabled && styles.disabled,
			loading && styles.loading,
			pressed && !disabled && !url && styles.pressed,
			removeUnderline && styles.removeUnderline,
			tone && styles[variationName('tone', tone)]
		)
	);

	const commonProps: CommonButtonProps = $derived({
		class: className,
		'data-primary-link': dataPrimaryLink,
		id,
		accessibilityLabel,
		ariaDescribedBy,
		role
	});

	const linkProps: LinkButtonProps = $derived({
		url,
		external,
		download,
		target
	});

	const actionProps: ActionButtonProps = $derived({
		submit,
		disabled: isDisabled,
		loading,
		ariaControls,
		ariaExpanded,
		ariaChecked,
		pressed
	});

	function getDisclosureIconSource(
		disclosure: NonNullable<ButtonProps['disclosure']>,
		upIcon: IconSource,
		downIcon: IconSource
	) {
		if (disclosure === 'select') {
			return SelectIcon;
		}

		return disclosure === 'up' ? upIcon : downIcon;
	}
</script>
<UnstyledButton bind:ref {onClick} {onFocus} {onBlur} {onKeyDown} {onKeyPress} {onKeyUp} {onMouseEnter} {onTouchStart} {triggerProps} {...commonProps} {...linkProps} {...actionProps} disabled={isDisabled}>
	{#if loading}
		<span class={styles.Spinner}>
			<Spinner size="small" accessibilityLabel="Loading" />
		</span>
	{/if}
	{#if icon}
		<span class={loading ? styles.hidden : styles.Icon}>
			<Icon source={icon} />
		</span>
	{/if}
	<Text as="span" variant={textVariant()} fontWeight={textFontWeight()}>
		{@render children?.()}
	</Text>
	{#if disclosure}
		<span class={loading ? styles.hidden : styles.Icon}>
			<!--svelte-ignore svelte_component_deprecated -->
			<Icon source={getDisclosureIconSource(disclosure, ChevronUpIcon, CaretDownIcon)} />
		</span>
	{/if}
</UnstyledButton>

```

# components/button/button.types.ts

```ts
import type { IconSource, BaseButton } from '$utilities/types.js';
import type {
  Action,
  DisableableAction,
  DestructableAction,
  IconableAction,
  OutlineableAction,
  LoadableAction,
  PlainAction,
} from '$utilities/types.js';
import type { Snippet } from 'svelte';
import type { UnstyledButtonProps } from './unstyled-button.types.js';

export interface ButtonProps extends BaseButton {
  /**
   * Changes the size of the button, giving it more or less padding
   * @default 'medium'
   */
  size?: 'micro' | 'slim' | 'medium' | 'large';
  /** Changes the inner text alignment of the button */
  textAlign?: 'left' | 'right' | 'center' | 'start' | 'end';
  /** Allows the button to grow to the width of its container */
  fullWidth?: boolean;
  /** Displays the button with a disclosure icon. Defaults to `down` when set to true */
  disclosure?: 'down' | 'up' | 'select' | boolean;
  /** Removes underline from button text (including on interaction)
   * @deprecated Use a variant instead
   */
  removeUnderline?: boolean;
  /** Icon to display to the left of the button content */
  icon?: IconSource;
  /** Indicates whether or not the button is the primary navigation link when rendered inside of an `IndexTable.Row` */
  dataPrimaryLink?: boolean;
  /** Sets the color treatment of the Button. */
  tone?: 'critical' | 'success';
  /** Changes the visual appearance of the Button. */
  variant?: 'plain' | 'primary' | 'secondary' | 'tertiary' | 'monochromePlain';
  children?: Snippet;
  triggerProps?: any;
  ref?: HTMLElement
}

export interface CommonButtonProps
  extends Pick<
    ButtonProps,
    | 'id'
    | 'accessibilityLabel'
    | 'ariaDescribedBy'
    | 'role'
  > {
  class: UnstyledButtonProps['class'];
  'data-primary-link'?: boolean;
}

export type LinkButtonProps = Pick<ButtonProps,'url' | 'external' | 'download' | 'target'>;

export type ActionButtonProps = Pick<
  ButtonProps,
  | 'submit'
  | 'disabled'
  | 'loading'
  | 'ariaControls'
  | 'ariaExpanded'
  | 'ariaChecked'
  | 'pressed'
>;

export type ButtonEmits = {
  /** Callback when clicked */
  'click': [];
  /** Callback when button becomes focussed */
  'focus': [];
  /** Callback when focus leaves button */
  'blur': [];
  /** Callback when a keypress event is registered on the button */
  'keypress': [event: KeyboardEvent];
  /** Call back when a keyup event is registered on the button */
  'keyup': [event: KeyboardEvent];
  /** Callback when a keydown event is registered on the button */
  'keydown': [event: KeyboardEvent];
  /** Callback when mouse enter */
  'mouseenter': [];
  /** Callback when element is touched */
  'touchstart': [];
  /** Callback when pointerdown event is being triggered */
  'pointerdown': [event: PointerEvent];
}

export interface ComplexAction
  extends Action,
    DisableableAction,
    DestructableAction,
    IconableAction,
    OutlineableAction,
    LoadableAction,
    PlainAction {}
```

# components/button/unstyled-button.svelte

```svelte
<script lang="ts">
	import { handleMouseUpByBlurring } from '$utilities/focus.js';
	import type { UnstyledButtonProps } from './unstyled-button.types.js';
	import UnstyledLink from './unstyled-link.svelte';

	let {
		id,
		ref = $bindable(),
		children,
		className,
		url,
		external,
		target,
		download,
		submit,
		disabled,
		loading,
		pressed,
		accessibilityLabel,
		role,
		ariaControls,
		ariaExpanded,
		ariaDescribedBy,
		ariaChecked,
		triggerProps,
		onClick,
		onFocus,
		onBlur,
		onKeyDown,
		onKeyPress,
		onKeyUp,
		onMouseEnter,
		onTouchStart,
		...restProps
	}: UnstyledButtonProps = $props();

	const commonProps = {
		id,
		className,
		'aria-label': accessibilityLabel
	};

	const interactiveProps = {
		...commonProps,
		role,
		onClick,
		onFocus,
		onBlur,
		onMouseUp: handleMouseUpByBlurring,
		onMouseEnter,
		onTouchStart
	};
</script>

{#if url}
    {#if disabled}
        <a {...commonProps} {...restProps}>
            {@render children?.()}
        </a>
    {:else}
        <UnstyledLink 
            {...interactiveProps}
            {...restProps}
            url={url}
            external={external}
            target={target}
            download={download}
        >
            {@render children?.()}
        </UnstyledLink>
    {/if}
{:else}
	{#if triggerProps}
		<button {...restProps} {...triggerProps} bind:this={ref}>{@render children?.()}</button>
	{:else}
		<button
			{...interactiveProps}
			{...restProps}
			{...triggerProps}
			bind:this={ref}
			onclick={onClick}
			onfocus={onFocus}
			onblur={onBlur}
			onkeydown={onKeyDown}
			onkeypress={onKeyPress}
			onkeyup={onKeyUp}
			onmouseenter={onMouseEnter}
			ontouchstart={onTouchStart}
			aria-disabled={disabled}
			type={submit ? 'submit' : 'button'}
			aria-busy={loading ? true : undefined}
			aria-controls={ariaControls}
			aria-expanded={ariaExpanded}
			aria-describedby={ariaDescribedBy}
			aria-pressed={pressed}
			tabIndex={disabled ? -1 : undefined}>
			{@render children?.()}
		</button>
	{/if}
{/if}

```

# components/button/unstyled-button.types.ts

```ts
import type { BaseButton } from "$utilities/types.js";
import type { Snippet } from "svelte";

export interface UnstyledButtonProps extends BaseButton {
  children?: Snippet;
  ref?: HTMLElement;
  class?: string;
  [key: string]: any;
}
```

# components/button/unstyled-link.svelte

```svelte
<script lang='ts'>
	import type { Snippet } from 'svelte';
    import type { LinkButtonProps } from './button.types.js';
	import { unstyled } from '$utilities/shared.js';
    let {url, external, download, target, children, className, ...restProps }: LinkButtonProps & { children?: Snippet, className?: string } = $props();
    const rel = target === '_blank' ? 'noopener noreferrer' : undefined;
</script>

{#if external}
    <a href={url} target="_blank" {...unstyled.props} download={download} rel={rel} {...restProps} class={className}>
        {@render children?.()}
    </a>
{:else}
    <a href={url} target="_self" {...unstyled.props} download={download} rel={rel} {...restProps} class={className}>
        {@render children?.()}
    </a>
{/if}
```

# components/callout-card/callout-card.module.css

```css
.CalloutCard {
    display: flex;
    align-items: center;
}

.Image {
    display: none;
    flex: 0 0 auto;
    width: 100px;

    @media (--p-breakpoints-sm-up) {
        display: block;
        margin-left: var(--p-space-500);
    }
}

.DismissImage {
    margin-right: var(--p-space-500);
}

.Content {
    flex: 1 1 auto;
}

.Title {
    margin-bottom: var(--p-space-200);
}

.Buttons {
    margin-top: var(--p-space-200);
}

.Container {
    position: relative;
}

.Dismiss {
    right: var(--p-space-300);
    top: var(--p-space-400);
    position: absolute;

    & svg {
        fill: var(--p-color-icon-secondary);
    }
}

.hasDismiss {
    padding-right: calc(var(--p-space-800) + var(--p-space-300));
}
```

# components/callout-card/callout-card.svelte

```svelte
<script lang="ts">
	import { classNames } from '$utilities/css.js';
	import BlockStack from '../block-stack/block-stack.svelte';
	import ButtonGroup from '../button-group/index.js';
	import ButtonFrom from '../button/button-from.svelte';
	import Button from '../button/button.svelte';
	import LegacyCardSection from '../legacy-card/components/section/legacy-card-section.svelte';
	import LegacyCard from '../legacy-card/legacy-card.svelte';
	import styles from './callout-card.module.css';
	import type { CalloutCardProps } from './types.js';
	import XIcon from '@shopify/polaris-icons/dist/svg/XIcon.svg?component';
	import Text from '../text/text.svelte';
	import Image from '../image/image.svelte';

	let {
		children,
		title,
		illustration,
		primaryAction,
		secondaryAction,
		onDismiss
	}: CalloutCardProps = $props();

	const imageClassName = $derived(classNames(styles.Image, onDismiss && styles.DismissImage));
	const containerClassName = $derived(classNames(styles.Container, onDismiss && styles.hasDismiss));
</script>

{#snippet primaryActionMarkup()}
	{#if primaryAction}
		<ButtonFrom action={primaryAction} overrides={{ variant: 'primary' }} />
	{/if}
{/snippet}

{#snippet secondaryActionMarkup()}
	{#if secondaryAction}
		<ButtonFrom
			action={secondaryAction}
			overrides={{ variant: secondaryAction.variant ? 'secondary' : 'tertiary' }}
		/>
	{/if}
{/snippet}

{#snippet buttonMarkup()}
	{#if secondaryAction}
		<ButtonGroup>
			<ButtonGroup.Item>
				{@render primaryActionMarkup()}
			</ButtonGroup.Item>
			<ButtonGroup.Item>
				{@render secondaryActionMarkup()}
			</ButtonGroup.Item>
		</ButtonGroup>
	{:else}
		{@render primaryActionMarkup()}
	{/if}
{/snippet}

{#snippet dismissButton()}
	{#if onDismiss}
		<div class={styles.Dismiss}>
			<Button variant="tertiary" icon={XIcon} onClick={onDismiss} accessibilityLabel="Dismiss" />
		</div>
	{/if}
{/snippet}

<LegacyCard>
	<div class={containerClassName}>
		{@render dismissButton()}
		<LegacyCardSection>
			<div class={styles.CalloutCard}>
				<div class={styles.Content}>
					<div class={styles.Title}>
						<Text variant="headingSm" as="h2">
							{title}
						</Text>
					</div>
					<Text as="span" variant="bodyMd">
						<BlockStack>
							{@render children?.()}
						</BlockStack>
					</Text>
					<div class={styles.Buttons}>{@render buttonMarkup()}</div>
				</div>

				<Image alt="" class={imageClassName} source={illustration} />
			</div>
		</LegacyCardSection>
	</div>
</LegacyCard>

```

# components/callout-card/types.ts

```ts
import type { IconableAction } from "$utilities/types.js";
import type { Snippet } from "svelte";
import type { ButtonProps } from "../button/button.types.js";

export interface CalloutCardProps {
    /** The content to display inside the callout card. */
    children?: Snippet;
    /** The title of the card */
    title: string;
    /** URL to the card illustration */
    illustration: string;
    /** Primary action for the card */
    primaryAction: IconableAction;
    /** Secondary action for the card */
    secondaryAction?: IconableAction & Pick<ButtonProps, 'variant'>;
    /** Callback when banner is dismissed */
    onDismiss?(): void;
}
```

# components/card/card.svelte

```svelte
<script lang="ts">
	import type { BorderRadiusAliasOrScale } from '@shopify/polaris-tokens';
	import Box from '../box/box.svelte';
	import ShadowBevel from '../shadow-bevel/shadow-bevel.svelte';
	import type { CardProps } from './types.js';
	import { UseBreakpoints } from '$lib/use/use-breakpoints.svelte.js';
	let {
		children,
		background = 'bg-surface',
		padding = { xs: '400' },
		roundedAbove = 'sm'
	}: CardProps = $props();

	const defaultBorderRadius: BorderRadiusAliasOrScale = '300';
	const bp = new UseBreakpoints()
	let breakpoints = $derived(bp.getCurrentBreakpoints());
	const hasBorderRadius = $derived(Boolean(breakpoints?.[`${roundedAbove}Up`]));
</script>

<ShadowBevel boxShadow="100" borderRadius={hasBorderRadius ? defaultBorderRadius : '0'} zIndex="32">
	<Box {background} {padding} overflowX="clip" overflowY="clip" minHeight="100%">
		{@render children?.()}
	</Box>
</ShadowBevel>

```

# components/card/types.ts

```ts
import type { ResponsiveProp } from "$utilities/css.js";
import type { BreakpointsAlias, ColorBackgroundAlias, SpaceScale } from "@shopify/polaris-tokens";
import type { Snippet } from "svelte";

type Spacing = ResponsiveProp<SpaceScale>;

export interface CardProps {
    children?: Snippet;
    /** Background color
     * @default 'bg-surface'
     */
    background?: ColorBackgroundAlias;
    /** The spacing around the card
     * @default {xs: '400', sm: '500'}
     * @example
     * padding='400'
     * padding={{xs: '200', sm: '300', md: '400', lg: '500', xl: '600'}}
     */
    padding?: Spacing;
    /** Border radius value above a set breakpoint
     * @default 'sm'
     */
    roundedAbove?: BreakpointsAlias;
  }
```

# components/checkable-button/checkable-button.module.css

```css
.CheckableButton {
  color: var(--p-color-text);
  display: flex;
  align-items: center;
  gap: calc(var(--p-space-300) + var(--p-space-025));
  margin: 0;
  cursor: pointer;
  user-select: none;
  text-decoration: none;
  text-align: left;
  border-radius: var(--p-border-radius-100);
  width: auto;

  /* Checkable Button has no opinion on its own height, it simply fills its */

  /* container */
  min-height: auto;
  min-width: auto;
  height: 100%;

  svg {
    fill: var(--p-color-text-brand-on-bg-fill);
  }

  &:hover,
  &:active {
    background: transparent;
  }

  &:focus {
    outline: none;
  }
}

.Checkbox {
  pointer-events: none;

  /*
      We do not want to worry about setting the height and width explicitly.
      We want to inherits the height and width of its child (in this case the Checkbox component).

      We do this using flexbox because "the cross size of each flex container is the minimum size necessary to contain the flex items" as per the spec.
      https://www.w3.org/TR/css-flexbox-1/#flex-lines
  */
  display: flex;
}

.Label {
  display: flex;
  align-items: center;
  flex: 1;
  white-space: nowrap;
  overflow: hidden;
  max-width: 100%;
  text-overflow: ellipsis;

  /* padding to fix the bottom of letters being cutoff by overflow: hidden */
  padding: var(--p-space-025) 0;
}
```

# components/checkable-button/checkable-button.svelte

```svelte
<script lang="ts">
	import type { CheckboxHandles } from '$utilities/types.js';
	import Checkbox from '../checkbox/checkbox.svelte';
	import styles from './checkable-button.module.css';
	import type { CheckableButtonProps } from './types.js';
	import Text from '../text/text.svelte';

	let {
		accessibilityLabel,
		label = '',
		onToggleAll,
		selected,
		disabled,
		ariaLive,
		ref
	}: CheckableButtonProps = $props();
</script>

<!-- svelte-ignore a11y_click_events_have_key_events -->
<!-- svelte-ignore a11y_no_static_element_interactions -->
<div class={styles.CheckableButton} onclick={onToggleAll}>
	<div class={styles.Checkbox}>
		<Checkbox
			labelHidden
			{label}
			checked={selected}
			{disabled}
			onChange={onToggleAll}
			bind:ref
		/>

		{#if label}
			<span class={styles.Label} aria-live={ariaLive}>
				<Text as="span" variant="bodySm" fontWeight="medium">
					{label}
				</Text>
			</span>
		{/if}
	</div>
</div>

```

# components/checkable-button/types.ts

```ts
import type { CheckboxHandles } from "$utilities/types.js";

export interface CheckableButtonProps {
    accessibilityLabel?: string;
    label?: string;
    selected?: boolean;
    disabled?: boolean;
    onToggleAll?(): void;
    ariaLive?: 'off' | 'polite';
    ref?: CheckboxHandles | null
}
```

# components/checkbox/checkbox.module.css

```css
.Checkbox {
    position: relative;
    margin: var(--p-space-025);
}

.ChoiceLabel .Backdrop {
    border-width: 0;
    box-shadow: inset 0 0 0 var(--p-border-width-0165) var(--p-color-input-border);
    transition: border-color var(--p-motion-duration-100) var(--p-motion-ease-out),
        border-width var(--p-motion-duration-100) var(--p-motion-ease-out),
        box-shadow var(--p-motion-duration-100) var(--p-motion-ease-out);

    /* This fixes artifacts caused by box-shadow in some browsers */
    transform: translate3d(0, 0, 0);
}

.ChoiceLabel:hover .Backdrop {
    border-color: var(--p-color-input-border-hover);
    box-shadow: inset 0 0 0 var(--p-border-width-0165) var(--p-color-input-border-hover);
    background-color: var(--p-color-input-bg-surface-hover);
}

.ChoiceLabel:active .Backdrop,
.ChoiceLabel:checked .Backdrop {
    border-color: var(--p-color-bg-fill-brand);
    border-width: 0;
    box-shadow: inset 0 0 0 var(--p-space-050) var(--p-color-bg-fill-brand);
}

/* stylelint-disable selector-max-specificity, selector-max-class, selector-max-combinators, max-nesting-depth -- Much easier to read the rules when written like this */
.Input {
    position: absolute;
    z-index: var(--p-z-index-1);
    width: 100%;
    height: 100%;
    opacity: 0;
    margin: 0;

    &:focus-visible {
        +.Backdrop {
            /* stylelint-disable-next-line -- generated by polaris-migrator DO NOT COPY */
            @mixin focus-ring base, 0, focused;
            outline: var(--p-border-width-050) solid var(--p-color-border-focus);
            outline-offset: var(--p-space-025);
            background-color: var(--p-color-input-bg-surface-hover);
            border-width: 0;
        }
    }

    &:checked,
    &.Input-indeterminate {
        +.Backdrop {
            /* stylelint-disable-next-line -- generated by polaris-migrator DO NOT COPY */
            @mixin control-backdrop active;
            border-color: var(--p-color-bg-fill-brand);
            background-color: var(--p-color-bg-fill-brand-selected);
            box-shadow: inset 0 0 0 var(--p-space-800) var(--p-color-bg-fill-brand-selected);
        }

        ~.Icon {
            transition: opacity var(--p-motion-duration-150) var(--p-motion-ease-out),
                transform var(--p-motion-duration-150) var(--p-motion-ease-out);
            opacity: 1;

            svg {
                fill: var(--p-color-text-brand-on-bg-fill);
            }

            &.animated {
                transition: initial;
            }
        }
    }

    &:disabled {
        +.Backdrop {
            /* stylelint-disable-next-line -- generated by polaris-migrator DO NOT COPY */
            @mixin control-backdrop disabled;

            /* We set the border-color to transparent here
           in order for the background color to bleed all the way to the edge of the element. */
            border-color: transparent;
            background-color: var(--p-color-checkbox-bg-surface-disabled);
            box-shadow: none;

            &::before {
                background-color: transparent;
            }
        }

        ~.Icon svg {
            color: var(--p-color-checkbox-icon-disabled);
        }
    }

    &:disabled:checked,
    &:disabled.Input-indeterminate {
        +.Backdrop {
            background-color: var(--p-color-checkbox-bg-surface-disabled);

            &::before {
                background-color: transparent;
            }
        }
    }

    &.toneMagic {
        +.Backdrop {
            background-color: var(--p-color-bg-surface-magic);
            box-shadow: inset 0 0 0 var(--p-border-width-0165) var(--p-color-border-magic-secondary);

            .ChoiceLabel:hover & {
                background-color: var(--p-color-bg-surface-magic-hover);
                box-shadow: inset 0 0 0 var(--p-border-width-0165) var(--p-color-border-magic-secondary-hover);
            }
        }

        &:checked,
        &.Input-indeterminate {
            +.Backdrop {
                border-color: var(--p-color-bg-fill-magic);
                background-color: var(--p-color-bg-fill-magic);
                box-shadow: inset 0 0 0 var(--p-space-800) var(--p-color-bg-fill-magic);

                .ChoiceLabel:hover & {
                    border-color: var(--p-color-bg-fill-magic);
                    background-color: var(--p-color-bg-fill-magic);
                    box-shadow: inset 0 0 0 var(--p-space-800) var(--p-color-bg-fill-magic);
                }
            }
        }
    }

    /* stylelint-enable selector-max-specificity, selector-max-class, selector-max-combinators, max-nesting-depth */
}

.Backdrop {
    /* stylelint-disable-next-line -- generated by polaris-migrator DO NOT COPY */
    @mixin control-backdrop;
    position: relative;
    display: block;
    width: 100%;
    height: 100%;

    border: var(--p-border-width-0165) solid var(--p-color-input-border);

    &:hover {
        border-color: var(--p-color-input-border-hover);
    }
}

.Icon {
    position: absolute;
    transform-origin: 50% 50%;
    pointer-events: none;
    opacity: 0;
    transition: opacity var(--p-motion-duration-100) var(--p-motion-ease-out),
        transform var(--p-motion-duration-100) var(--p-motion-ease-out);

    top: calc(-1 * var(--p-space-050));
    left: calc(-1 * var(--p-space-050));
    bottom: calc(-1 * var(--p-space-050));
    right: calc(-1 * var(--p-space-050));

    &.animated {
        top: 0;
        left: 0;
        bottom: 0;
        right: 0;
        margin: var(--p-space-050);
        transition: initial;
    }

    svg {
        color: var(--p-color-text-brand-on-bg-fill);

        position: absolute;
        top: 0;
        left: 0;
        bottom: 0;
        right: 0;
    }

    @media (-ms-high-contrast: active) {
        fill: windowText;
    }
}

/* stylelint-disable selector-max-specificity, selector-max-class, selector-max-combinators, selector-max-compound-selectors -- generated by polaris-migrator DO NOT COPY */
.error {
    .Icon svg {
        color: var(--p-color-text-critical-on-bg-fill);
    }

    .Input {
        +.Backdrop {
            /* stylelint-disable-next-line -- generated by polaris-migrator DO NOT COPY */
            @mixin control-backdrop error;
            background-color: var(--p-color-bg-surface-critical);
            box-shadow: inset 0 0 0 var(--p-border-width-0165) var(--p-color-bg-fill-critical-active);
        }
    }

    .Backdrop {
        &:active {
            box-shadow: inset 0 0 0 var(--p-space-050) var(--p-color-bg-fill-critical-active);
        }
    }

    .Input:checked,
    .Input.Input-indeterminate {
        +.Backdrop {
            background-color: var(--p-color-bg-fill-critical-selected);
            box-shadow: inset 0 0 0 var(--p-space-300) var(--p-color-bg-fill-critical-selected);
        }
    }

    .Input:active {
        +.Backdrop {
            background-color: var(--p-color-border-critical);
            box-shadow: inset 0 0 0 var(--p-space-050) var(--p-color-bg-fill-critical-active);
        }
    }

    .Input:focus-visible+.Backdrop {

        &,
        .ChoiceLabel:hover & {
            border-color: var(--p-color-border-critical-secondary);
            background-color: var(--p-color-bg-surface-critical);
        }
    }
}

/* stylelint-enable selector-max-specificity, selector-max-class, selector-max-combinators */

/* stylelint-disable-next-line selector-max-combinators, selector-max-type -- override */
.animated svg>path {
    stroke-dasharray: 2;
    stroke-dashoffset: 2;

    /* stylelint-disable-next-line selector-max-combinators, selector-max-type, selector-no-qualifying-type -- override */
    &.checked {
        animation-name: pathAnimation;
        animation-duration: var(--p-motion-duration-150);
        animation-fill-mode: forwards;
        /* stylelint-disable-next-line declaration-property-value-disallowed-list -- override */
        animation-timing-function: linear;
        animation-direction: normal;
        animation-iteration-count: 1;
        opacity: 1;
    }
}

/* stylelint-disable-next-line polaris/motion/at-rule-disallowed-list -- override */
@keyframes pathAnimation {
    from {
        stroke-dashoffset: 2;
    }

    to {
        stroke-dashoffset: 0;
    }
}
```

# components/checkbox/checkbox.svelte

```svelte
<script lang="ts">
	import { classNames, variationName } from '$utilities/css.js';
	import { noop } from '$utilities/noop.js';
	import Choice from '../choice/choice.svelte';
	import type {Choice as ChoiceType } from '../choice-list/types.js';
	import { helpTextID } from '../choice/types.js';
	import { errorTextID } from '../inline-error/types.js';
	import styles from './checkbox.module.css';
	import type { CheckboxProps } from './types.js';
	let {
		ariaControls,
		ariaDescribedBy: ariaDescribedByProp,
		label,
		labelHidden,
		checked = $bindable(false),
		helpText,
		disabled,
		id: idProp,
		name,
		value = $bindable(),
		error,
		onChange,
		onFocus,
		onBlur,
		labelClassName,
		fill,
		bleed,
		bleedBlockStart,
		bleedBlockEnd,
		bleedInlineStart,
		bleedInlineEnd,
		isWithinListbox,
		tone,
		ref = $bindable(),
	}: CheckboxProps = $props();

	let inputNode = $state<HTMLInputElement | undefined>(undefined);
	const uniqId = $props.id();
	const id = idProp ?? uniqId;

	ref = {
		focus: () => {
			inputNode?.focus();
		}
	};

	const handleBlur = () => {
		onBlur && onBlur();
	};

	const handleOnClick = () => {
		if (onChange == null || inputNode == null || disabled) {
			return;
		}

		const choice = {

		}
		onChange(inputNode.checked, id);
		inputNode.focus();
	};

	const describedBy: string[] = $derived.by(() => {
		const newDescribedBy: string[] = [];
		if (error && typeof error !== 'boolean') {
			newDescribedBy.push(errorTextID(id));
		}
		if (helpText) {
			newDescribedBy.push(helpTextID(id));
		}
		if (ariaDescribedByProp) {
			newDescribedBy.push(ariaDescribedByProp);
		}
		return newDescribedBy;
	});

	const ariaDescribedBy = $derived(describedBy.length ? describedBy.join(' ') : undefined);
	const wrapperClassName = $derived(classNames(styles.Checkbox, error && styles.error));

	/* const isIndeterminate = $derived(checked === 'indeterminate'); */
	const isChecked = $derived(Boolean(checked));

	/* const indeterminateAttributes = $derived(
		isIndeterminate
			? { indeterminate: true, 'aria-checked': 'mixed' as const }
			: { 'aria-checked': isChecked }
	); */

	const inputClassName = $derived(
		classNames(
			styles.Input,
			/* isIndeterminate && styles['Input-indeterminate'], */
			tone && styles[variationName('tone', tone)]
		)
	);

	const extraChoiceProps = $derived({
		helpText,
		error,
		bleed,
		bleedBlockStart,
		bleedBlockEnd,
		bleedInlineStart,
		bleedInlineEnd
	});
</script>

{#snippet iconSource()}
	<svg viewBox="0 0 16 16" style="color: white;" shape-rendering="geometricPrecision" text-rendering="geometricPrecision">
		<path
			class={classNames(checked && styles.checked)}
			d="M1.5,5.5L3.44655,8.22517C3.72862,8.62007,4.30578,8.64717,4.62362,8.28044L10.5,1.5"
			transform="translate(2 2.980376)"
			opacity="0"
			fill="none"
			stroke="currentColor"
			stroke-width="2"
			stroke-linecap="round"
			stroke-linejoin="round"
			pathLength="1"
		/>
	</svg>
{/snippet}

<Choice
	{id}
	{label}
	{labelHidden}
	{disabled}
	labelClassName={classNames(styles.ChoiceLabel, labelClassName)}
	{fill}
	{tone}
	{...extraChoiceProps}
>
	<span class={wrapperClassName}>
		<input
			bind:this={inputNode}
			{id}
			{name}
			{value}
			type="checkbox"
			bind:checked={checked}
			{disabled}
			class={inputClassName}
			onblur={handleBlur}
			onchange={noop}
			onclick={handleOnClick}
			onfocus={onFocus}
			aria-invalid={error != null}
			aria-controls={ariaControls}
			aria-describedby={ariaDescribedBy}
			role={isWithinListbox ? 'presentation' : 'checkbox'}
		/>
		<!-- svelte-ignore a11y_no_static_element_interactions -->
		<!-- svelte-ignore element_invalid_self_closing_tag -->
		<span
			class={styles.Backdrop}
			onclick={(e) => e.stopPropagation()}
			onkeyup={(e) => e.stopPropagation()}
		/>
		<span class={classNames(styles.Icon, styles.animated)}>
			<!-- {#if isIndeterminate}
				<Icon source={MinusIcon} />
			{:else} -->
				{@render iconSource()}
			<!-- {/if} -->
		</span>
	</span>
</Choice>

```

# components/checkbox/types.ts

```ts
import type { ResponsiveProp } from "$utilities/css.js";
import type { CheckboxHandles } from "$utilities/types.js";
import type { ChoiceBleedProps } from "../choice/types.js";

export interface CheckboxProps extends ChoiceBleedProps {
    /** Indicates the ID of the element that is controlled by the checkbox */
    ariaControls?: string;
    /** Indicates the ID of the element that describes the checkbox */
    ariaDescribedBy?: string;
    /** Label for the checkbox */
    label: string;
    /** Visually hide the label */
    labelHidden?: boolean;
    /** Checkbox is selected. `indeterminate` shows a horizontal line in the checkbox */
    checked?: boolean;
    /** Disable input */
    disabled?: boolean;
    /** ID for form input */
    id?: string;
    /** Name for form input */
    name?: string;
    /** Value for form input */
    value?: string;
    /** Callback when checkbox is toggled */
    onChange?(newChecked: boolean, id: string): void;
    /** Callback when checkbox is focused */
    onFocus?(): void;
    /** Callback when focus is removed */
    onBlur?(): void;
    /** Added to the wrapping label */
    labelClassName?: string;
    /** Grow to fill the space. Equivalent to width: 100%; height: 100% */
    fill?: ResponsiveProp<boolean>;
    /** Additional text to aide in use */
    helpText?: string;
    /** Display an error message */
    error?: Error | boolean;
    /** Indicates the tone of the checkbox */
    tone?: 'magic';
    /** Whether the checkbox is within a listbox */
    isWithinListbox?: boolean;
    ref?: CheckboxHandles | null;
}
```

# components/choice-list/choice-list.module.css

```css
.ChoiceChildren {
    /* stylelint-disable-next-line -- generated by polaris-migrator DO NOT COPY */
    padding-left: calc(var(--p-space-200) + 20px);
}
```

# components/choice-list/choice-list.svelte

```svelte
<script lang="ts">
	import { noop } from '$utilities/noop.js';
	import type { Component } from 'svelte';
	import styles from './choice-list.module.css';
	import type { Choice, ChoiceListProps } from './types.js';
	import Checkbox from '../checkbox/checkbox.svelte';
	import RadioButton from '../radio-button/radio-button.svelte';
	import Box from '../box/box.svelte';
	import Text from '../text/text.svelte';
	import Bleed from '../bleed/bleed.svelte';
	import { errorTextID } from '../inline-error/types.js';
	import InlineError from '../inline-error/inline-error.svelte';
	import BlockStack from '../block-stack/block-stack.svelte';
	let {
		title,
		titleHidden,
		allowMultiple,
		choices,
		selected,
		onChange = noop,
		error,
		disabled = false,
		name: nameProp,
		tone
	}: ChoiceListProps = $props();

	const ControlComponent: any = allowMultiple ? Checkbox : RadioButton;
	const uniqName = $props.id();
	const name = nameProp ?? uniqName;
	const finalName = allowMultiple ? `${name}[]` : name;

	function updateSelectedChoices(
		{ value }: Choice,
		checked: boolean,
		selected: string[],
		allowMultiple = false
	) {
		if (checked) {
			return allowMultiple ? [...selected, value] : [value];
		}

		const s = selected.filter((selectedChoice) => selectedChoice !== value);
		return s;
	}

	function handleChange(checked: boolean, choice: Choice) {
		onChange(updateSelectedChoices(choice, checked, selected, allowMultiple), name);
	}

	function choiceIsSelected({ value }: Choice, selected: string[]) {
		return selected.includes(value);
	}
</script>

{#snippet titleMarkup()}
	{#if title}
		<Box as="legend" paddingBlockEnd={{ xs: '0', md: '100' }}>
			<Text as="span" variant="bodyMd" visuallyHidden={titleHidden}>
				{title}
			</Text>
		</Box>
	{/if}
{/snippet}

{#snippet choicesMarkup()}
	{#each choices as choice}
		{@const { value, id, label, helpText, disabled: choiceDisabled, describedByError } = choice}
		{@const isSelected = choiceIsSelected(choice, selected)}
		{@const renderedChildren = choice.renderChildren ? choice.renderChildren(isSelected) : null}

		{#snippet children()}
			{#if renderedChildren}
				<div class={styles.ChoiceChildren}>
					<Box paddingBlockStart={{ xs: '400', md: '0' }}>{renderedChildren}</Box>
				</div>
			{/if}
		{/snippet}

		<li>
			<Bleed marginBlockEnd={helpText ? { xs: '100', md: '0' } : { xs: '0' }}>
				<ControlComponent
					name={finalName}
					{value}
					{id}
					{label}
					disabled={choiceDisabled || disabled}
					fill={{ xs: true, sm: false }}
					checked={choiceIsSelected(choice, selected)}
					{helpText}
					onChange={handleChange}
					ariaDescribedBy={error && describedByError ? errorTextID(finalName) : null}
					{tone}
				/>
				{@render children()}
			</Bleed>
		</li>
	{/each}
{/snippet}

{#snippet errorMarkup()}
	{#if error}
		<Box paddingBlockStart={{ xs: '0', md: '100' }} paddingBlockEnd="200">
			<InlineError message={error.message} fieldID={finalName} />
		</Box>
	{/if}
{/snippet}

<BlockStack as="fieldset" gap={{ xs: '400', md: '0' }} id={finalName}>
	{@render titleMarkup()}
	<BlockStack as="ul" gap={{ xs: '400', md: '0' }}>
		{@render choicesMarkup()}
	</BlockStack>
	{@render errorMarkup()}
</BlockStack>

```

# components/choice-list/types.ts

```ts
export interface Choice {
    /** Value of the choice */
    value: string;
    /** Label for the choice */
    label: string;
    /** A unique identifier for the choice */
    id?: string;
    /** Disable choice */
    disabled?: boolean;
    /** Additional text to aide in use */
    helpText?: string;
    /** Indicates that the choice is aria-describedBy the error message */
    describedByError?: boolean;
    /**  Method to render children with a choice */
    renderChildren?(isSelected: boolean): string | false;
}

export interface ChoiceListProps {
    /** Label for list of choices */
    title: string;
    /** Collection of choices */
    choices: Choice[];
    /** Collection of selected choices */
    selected: string[];
    /** Name for form input */
    name?: string;
    /** Allow merchants to select multiple options at once */
    allowMultiple?: boolean;
    /** Toggles display of the title */
    titleHidden?: boolean;
    /** Display an error message */
    error?: Error;
    /** Disable all choices **/
    disabled?: boolean;
    /** Callback when the selected choices change */
    onChange?(selected: string[], name: string): void;
    /** Indicates the tone of the choice list */
    tone?: 'magic';
}
```

# components/choice/choice.module.css

```css
/* stylelint-disable polaris/conventions/polaris/custom-property-allowed-list -- Polaris component custom properties */
.Choice {
    /*
      Explicitly not using -p-space-0 because we need to set the unit so it'll
      work in a calc().
      We specify 0rem here because our bundle process uses postcss-pxtorem.
      This forceable converts 0px to 0 which is invalid for calcs but leaves rems alone.
      See https://github.com/cuth/postcss-pxtorem/blob/122649015322214f8e9d1ac852eb11c0791b634b/index.js#L52
    */
    /* stylelint-disable-next-line length-zero-no-unit -- see above */
    --pc-choice-space-0: 0rem;
    @mixin responsive-props choice, bleed-block-start,
    --pc-choice-bleed-block-start;
    @mixin responsive-props choice, bleed-block-end, --pc-choice-bleed-block-end;
    @mixin responsive-props choice, bleed-inline-start,
    --pc-choice-bleed-inline-start;
    @mixin responsive-props choice, bleed-inline-end, --pc-choice-bleed-inline-end;
    @mixin responsive-props choice, fill, --pc-choice-fill;
    display: inline-flex;
    align-items: center;
    justify-content: flex-start;
    cursor: pointer;
    padding-block-start: calc(var(--pc-choice-bleed-block-start, var(--pc-choice-space-0)) + var(--p-space-100));
    padding-block-end: calc(var(--pc-choice-bleed-block-end, var(--pc-choice-space-0)) + var(--p-space-100));
    padding-inline-start: var(--pc-choice-bleed-inline-start,
            var(--pc-choice-space-0));
    padding-inline-end: var(--pc-choice-bleed-inline-end,
            var(--pc-choice-space-0));
    margin-block-start: calc(-1 * var(--pc-choice-bleed-block-start, var(--pc-choice-space-0)));
    margin-block-end: calc(-1 * var(--pc-choice-bleed-block-end, var(--pc-choice-space-0)));
    margin-inline-start: calc(-1 * var(--pc-choice-bleed-inline-start, var(--pc-choice-space-0)));
    margin-inline-end: calc(-1 * var(--pc-choice-bleed-inline-end, var(--pc-choice-space-0)));

    /* width/height has to account for the extra padding from bleed */
    inline-size: calc(var(--pc-choice-fill, auto) + var(--pc-choice-bleed-inline-start, var(--pc-choice-space-0)) + var(--pc-choice-bleed-inline-end, var(--pc-choice-space-0)));
    block-size: calc(var(--pc-choice-fill, auto) + var(--pc-choice-bleed-block-start, var(--pc-choice-space-0)) + var(--pc-choice-bleed-block-end, var(--pc-choice-space-0)));
}

.labelHidden {
    /* When there's no label, there's no extra padding */
    padding-block-start: var(--pc-choice-bleed-block-start,
            var(--pc-choice-space-0));
    padding-block-end: var(--pc-choice-bleed-block-end, var(--pc-choice-space-0));

    >.Label {
        /* stylelint-disable-next-line -- generated by polaris-migrator DO NOT COPY */
        @mixin visually-hidden;
    }

    .Control {
        margin-top: 0;
        margin-right: 0;
    }
}

.disabled {
    cursor: default;

    >.Label {
        color: var(--p-color-text-disabled);

        &:hover {
            cursor: default;
        }

        @media (-ms-high-contrast: active) {
            color: grayText;
        }
    }
}

.toneMagic>.Label {
    color: var(--p-color-text-magic);
}

.disabled+.Descriptions {
    /* the <Text/> component in the HelpText markup in Choice.tsx is set to `undefined` when the disabled prop is true
       Which tells it to inherit whatever color we specify here. */
    color: var(--p-color-text-disabled);
}

.Control {
    /* stylelint-disable-next-line -- Polaris component custom properties */
    --pc-choice-size: 18px;

    @media (--p-breakpoints-md-down) {
        /* stylelint-disable-next-line -- Polaris component custom properties */
        --pc-choice-size: 20px;
    }

    display: flex;
    flex: 0 0 auto;
    align-items: stretch;
    /* stylelint-disable-next-line -- generated by polaris-migrator DO NOT COPY */
    width: var(--pc-choice-size);
    /* stylelint-disable-next-line -- generated by polaris-migrator DO NOT COPY */
    height: var(--pc-choice-size);
    margin-right: var(--p-space-200);

    >* {
        width: 100%;
    }
}

.Label {
    -webkit-tap-highlight-color: transparent;

    &:hover {
        cursor: pointer;
    }
}

.Descriptions {
    /* stylelint-disable-next-line -- Polaris component custom properties */
    --pc-choice-size: 18px;

    @media (--p-breakpoints-md-down) {
        /* stylelint-disable-next-line -- Polaris component custom properties */
        --pc-choice-size: 20px;
    }

    /* stylelint-disable-next-line -- generated by polaris-migrator DO NOT COPY */
    padding-left: calc(var(--p-space-200) + var(--pc-choice-size));
}

.HelpText {
    margin-bottom: var(--p-space-100);
}
```

# components/choice/choice.svelte

```svelte
<script lang="ts">
	import {
		applyStyles,
		classNames,
		getResponsiveProps,
		getResponsiveValue,
		variationName
	} from '$utilities/css.js';
	import styles from './choice.module.css';
	import { helpTextID, type ChoiceProps } from './types.js';
	import Text from '../text/text.svelte';
	import InlineError from '../inline-error/inline-error.svelte';
	let {
		id,
		label,
		disabled,
		error,
		children,
		labelHidden,
		helpText,
		onClick,
		labelClassName,
		fill,
		bleed,
		bleedBlockStart,
		bleedBlockEnd,
		bleedInlineStart,
		bleedInlineEnd,
		tone
	}: ChoiceProps = $props();

	const className = $derived(
		classNames(
			styles.Choice,
			labelHidden && styles.labelHidden,
			disabled && styles.disabled,
			tone && styles[variationName('tone', tone)],
			labelClassName
		)
	);

	const labelStyle = $derived({
		// Pass through overrides for bleed values if they're set by the prop
		...getResponsiveProps('choice', 'bleed-block-end', 'space', bleedBlockEnd || bleed),
		...getResponsiveProps('choice', 'bleed-block-start', 'space', bleedBlockStart || bleed),
		...getResponsiveProps('choice', 'bleed-inline-start', 'space', bleedInlineStart || bleed),
		...getResponsiveProps('choice', 'bleed-inline-end', 'space', bleedInlineEnd || bleed),
		...Object.fromEntries(
			Object.entries(getResponsiveValue('choice', 'fill', fill)).map(
				// Map "true" => "100%" and "false" => "auto" for use in
				// inline/block-size calc()
				([key, value]) => [key, value ? '100%' : 'auto']
			)
		)
	});
</script>

{#snippet labelMarkup()}
	<!-- svelte-ignore a11y_click_events_have_key_events -->
	<!-- svelte-ignore a11y_no_noninteractive_element_interactions -->
	<label class={className} for={id} onclick={onClick} style={applyStyles(labelStyle)}>
		<span class={styles.Control}>{@render children?.()}</span>
		<span class={styles.Label}>
			<Text as="span" variant="bodyMd">
				{label}
			</Text>
		</span>
	</label>
{/snippet}

{#snippet helpTextMarkup()}
	{#if helpText}
		<div class={styles.HelpText} id={helpTextID(id)}>
			<Text as="span" tone={disabled ? undefined : 'subdued'}>
				{helpText}
			</Text>
		</div>
	{/if}
{/snippet}

{#snippet errorMarkup()}
	{#if error && typeof error !== 'boolean'}
		<div class={styles.Error}>
			<InlineError message={error.message} fieldID={id} />
		</div>
	{/if}
{/snippet}

{#snippet descriptionMarkup()}
	<div class={styles.Descriptions}>
		{@render errorMarkup()}
		{@render helpTextMarkup()}
	</div>
{/snippet}

<div>
	{@render labelMarkup()}
	{@render descriptionMarkup()}
</div>

```

# components/choice/types.ts

```ts
import type { ResponsiveProp } from "$utilities/css.js";
import type { SpaceScale } from "@shopify/polaris-tokens";
import type { Snippet } from "svelte";

type Spacing = ResponsiveProp<SpaceScale>;

export interface ChoiceBleedProps {
    /** Spacing around children. Accepts a spacing token or an object of spacing tokens for different screen sizes.
     * @example
     * bleed='4'
     * bleed={{xs: '2', sm: '3', md: '4', lg: '5', xl: '6'}}
     */
    bleed?: Spacing;
    /** Vertical start spacing around children. Accepts a spacing token or an object of spacing tokens for different screen sizes.
     * @example
     * bleedBlockStart='4'
     * bleedBlockStart={{xs: '2', sm: '3', md: '4', lg: '5', xl: '6'}}
     */
    bleedBlockStart?: Spacing;
    /** Vertical end spacing around children. Accepts a spacing token or an object of spacing tokens for different screen sizes.
     * @example
     * bleedBlockEnd='4'
     * bleedBlockEnd={{xs: '2', sm: '3', md: '4', lg: '5', xl: '6'}}
     */
    bleedBlockEnd?: Spacing;
    /** Horizontal start spacing around children. Accepts a spacing token or an object of spacing tokens for different screen sizes.
     * @example
     * bleedInlineStart='4'
     * bleedInlineStart={{xs: '2', sm: '3', md: '4', lg: '5', xl: '6'}}
     */
    bleedInlineStart?: Spacing;
    /** Horizontal end spacing around children. Accepts a spacing token or an object of spacing tokens for different screen sizes.
     * @example
     * bleedInlineEnd='4'
     * bleedInlineEnd={{xs: '2', sm: '3', md: '4', lg: '5', xl: '6'}}
     */
    bleedInlineEnd?: Spacing;
}

export interface ChoiceProps extends ChoiceBleedProps {
    /** A unique identifier for the choice */
    id: string;
    /**	Label for the choice */
    label: string;
    /** Whether the associated form control is disabled */
    disabled?: boolean;
    /** Visually hide the label */
    labelHidden?: boolean;
    /**  Content to display inside the choice */
    children?: Snippet;
    /** Callback when clicked */
    onClick?(): void;
    /** Added to the label element */
    labelClassName?: string;
    /** Grow to fill the space. Equivalent to width: 100%; height: 100% */
    fill?: ResponsiveProp<boolean>;
    /** Display an error message */
    error?: Error | boolean;
    /** Additional text to aide in use. Will add a wrapping <div> */
    helpText?: string;
    /** Indicates the tone of the choice */
    tone?: 'magic';
}

export function helpTextID(id: string) {
    return `${id}HelpText`;
}
```

# components/combobox/combobox.module.css

```css
.Listbox {
    padding: var(--p-space-200) 0;
    overflow: visible;
}
```

# components/combobox/combobox.svelte

```svelte
<script lang="ts">
	import type {
		ComboboxListboxOptionType,
		ComboboxListboxType,
		ComboboxTextFieldType
	} from '$utilities/combobox/types.js';
	import type { PopoverPublicAPI } from '../popover/types.js';
	import styles from './combobox.module.css';
	import type { ComboboxProps } from './types.js';
	import ComboboxTextFieldContextProvider from '../app-provider/combobox-text-filed-context-provider.svelte';
	import ComboboxListboxContextProvider from '../app-provider/combobox-list-box-context-provider.svelte';
	import ComboboxListboxOptionContextProvider from '../app-provider/combobox-list-box-option-context-provider.svelte';
	import Popover from '../popover/index.js';

	let {
		activator,
		allowMultiple,
		children,
		preferredPosition = 'below',
		willLoadMoreOptions,
		height,
		maxHeight,
		minHeight,
		onScrolledToBottom,
		onClose
	}: ComboboxProps = $props();

	let popoverActive = $state(false);
	let activeOptionId = $state<string | undefined>(undefined);
	let textFieldLabelId = $state<string | undefined>(undefined);
	let listboxId = $state<string | undefined>(undefined);
	let textFieldFocused = $state(false);
	let shouldOpen = $derived(!popoverActive);
	let ref = $state<PopoverPublicAPI | null>(null);

	const handleClose = () => {
		popoverActive = false;
		onClose?.();

		activeOptionId = undefined;
	};

	const handleOpen = () => {
		popoverActive = true;
		activeOptionId = undefined;
	};

	const onOptionSelected = () => {
		if (!allowMultiple) {
			handleClose();
			activeOptionId = undefined;
			return;
		}

		ref?.forceUpdatePosition();
	};

	const handleFocus = () => {
		if (shouldOpen) {
			handleOpen();
		}
	};

	const handleChange = () => {
		if (shouldOpen) {
			handleOpen();
		}
	};

	const handleBlur = () => {
		if (popoverActive) {
			handleClose();
		}
	};

	const textFieldContextValue: ComboboxTextFieldType = $derived({
		activeOptionId,
		expanded: popoverActive,
		listboxId,
		setTextFieldFocused: (value) => (textFieldFocused = value),
		setTextFieldLabelId: (value) => (textFieldLabelId = value),
		onTextFieldFocus: handleFocus,
		onTextFieldChange: handleChange,
		onTextFieldBlur: handleBlur
	});

	const listboxOptionContextValue: ComboboxListboxOptionType = $derived({ allowMultiple });
	const listboxContextValue: ComboboxListboxType = $derived({
		listboxId,
		textFieldLabelId,
		textFieldFocused,
		willLoadMoreOptions,
		onOptionSelected,
		setActiveOptionId: (value) => (activeOptionId = value),
		setListboxId: (value) => (listboxId = value),
		onKeyToBottom: onScrolledToBottom
	});
</script>

{#snippet activatorMarkup()}
	<ComboboxTextFieldContextProvider value={textFieldContextValue}>
		{@render activator()}
	</ComboboxTextFieldContextProvider>
{/snippet}

<Popover
	trigger={activatorMarkup}
	active={popoverActive}
	autofocusTarget="none"
	preventFocusOnClose
	fullWidth
	preferInputActivator={false}
	{preferredPosition}
	onClose={handleClose}
>
	<Popover.Pane {onScrolledToBottom} {height} {maxHeight} {minHeight}>
		<ComboboxListboxContextProvider value={listboxContextValue}>
			<ComboboxListboxOptionContextProvider value={listboxOptionContextValue}>
				<div class={styles.Listbox}>
					{@render children?.()}
				</div>
			</ComboboxListboxOptionContextProvider>
		</ComboboxListboxContextProvider>
	</Popover.Pane>
</Popover>

```

# components/combobox/components/text-field/text-field.svelte

```svelte
<script lang="ts">
	import { labelID } from '$lib/components/label/types.js';
	import type { TextFieldProps } from '$lib/components/text-field/types.js';
	import TextField from '$lib/components/text-field/text-field.svelte';
	import { COMBOBOX_TEXT_FIELD_CONTEXT_KEY, type ComboboxTextFieldType } from '$utilities/combobox/types.js';
	import { useContext } from '$utilities/contexts.js';

	let {
		value,
		id: idProp,
		type = 'text',
		ariaAutocomplete = 'list',
		onFocus,
		onBlur,
		onChange,
		...rest
	}: TextFieldProps = $props();

	const comboboxTextFieldContext = useContext<ComboboxTextFieldType>(COMBOBOX_TEXT_FIELD_CONTEXT_KEY);
	const {
		activeOptionId,
		listboxId,
		expanded,
		setTextFieldFocused,
		setTextFieldLabelId,
		onTextFieldFocus,
		onTextFieldChange,
		onTextFieldBlur
	} = $derived(comboboxTextFieldContext()!);
	const uniqueId = $props.id();
	const textFieldId = $derived(idProp || uniqueId);
	const labelId = $derived(labelID(idProp || uniqueId));

	$effect(() => {
		if (setTextFieldLabelId) setTextFieldLabelId(labelId);
	});

	const handleFocus = (event: FocusEvent | undefined) => {
		if (onFocus) onFocus(event);
		if (onTextFieldFocus) onTextFieldFocus();
		if (setTextFieldFocused) setTextFieldFocused(true);
	};

	const handleBlur = (event: FocusEvent | undefined) => {
		if (onBlur) onBlur(event);
		if (onTextFieldBlur) onTextFieldBlur();
		if (setTextFieldFocused) setTextFieldFocused(false);
	};

	const handleChange = (value: string, id: string) => {
		if (onChange) onChange(value, id);
		if (onTextFieldChange) onTextFieldChange(value);
	};
</script>

<TextField
	{...rest}
	{value}
	id={textFieldId}
	{type}
	{ariaAutocomplete}
	ariaActiveDescendant={activeOptionId}
	ariaControls={listboxId}
	role="combobox"
	ariaExpanded={expanded}
	onFocus={handleFocus}
	onBlur={handleBlur}
	onChange={handleChange}
/>

```

# components/combobox/index.ts

```ts
import ComboboxComponent from "./combobox.svelte";
import TextFieldComponent from "./components/text-field/text-field.svelte";

type ComboboxCompoundComponent = typeof ComboboxComponent & {
    TextField: typeof TextFieldComponent;
};

const Combobox = ComboboxComponent as ComboboxCompoundComponent;
Combobox.TextField = TextFieldComponent;

export default Combobox;
```

# components/combobox/types.ts

```ts
import type { Snippet } from "svelte";
import type { PopoverProps } from "../popover/types.js";
import type { ListboxProps } from "../listbox/types.js";
import type { TextFieldProps } from "../text-field/types.js";

export interface ComboboxProps {
    /** The text field component to activate the Popover */
    activator: Snippet
    /** Allows more than one option to be selected */
    allowMultiple?: boolean;
    /** The content to display inside the popover */
    children?: Snippet;
    /** The preferred direction to open the popover */
    preferredPosition?: PopoverProps['preferredPosition'];
    /** Whether or not more options are available to lazy load when the bottom of the listbox reached. Use the hasMoreResults boolean provided by the GraphQL API of the paginated data. */
    willLoadMoreOptions?: boolean;
    /** Height to set on the Popover Pane. */
    height?: string;
    /** Callback fired when the bottom of the listbox is reached. Use to lazy load when listbox option data is paginated. */
    maxHeight?: string;
    /** Min Height to set on the Popover Pane. */
    minHeight?: string;
    /** Callback fired when the bottom of the lisbox is reached. Use to lazy load when listbox option data is paginated. */
    onScrolledToBottom?(): void;
    /** Callback fired when the popover closes */
    onClose?(): void;
}
```

# components/conditional-render/conditional-render.svelte

```svelte
<script lang="ts">
	interface ConditionalRenderProps {
		condition: boolean;
		children: any;
	}
	let { condition, children }: ConditionalRenderProps = $props();
</script>

{#if condition}
	{@render children()}
{/if}

```

# components/conditional-render/conditional-wrapper.svelte

```svelte
<script lang="ts">
	interface ConditionalWrapperProps {
		children: any;
		condition: boolean;
		wrapper: (children: any) => any;
	}
	let { condition, children, wrapper }: ConditionalWrapperProps = $props();
</script>

{#if condition}
	{@render wrapper(children)}
{:else}
    {@render children()}
{/if}

```

# components/connected/components/item/connected-item.svelte

```svelte
<script lang="ts">
	import type { ItemProps } from '../../types.js';
	import styles from '../../connected.module.css';
	import { UseToggle } from '$lib/use/use-toggle.svelte.js';
	import { classNames } from '$utilities/css.js';
	let { children, position }: ItemProps = $props();

	const focused = new UseToggle(false);
	const forceTrueFocused = focused.setTrue;
	const forceFalseFocused = focused.setFalse;

	const className = $derived(
		classNames(
			styles.Item,
			focused.value && styles['Item-focused'],
			position === 'primary' ? styles['Item-primary'] : styles['Item-connection']
		)
	);
</script>

<div onblur={forceFalseFocused} onfocus={forceTrueFocused} class={className}>
	{@render children?.()}
</div>

```

# components/connected/connected.module.css

```css
.Connected {
    /* stylelint-disable -- Polaris component custom properties */
    --pc-connected-item: 10;
    --pc-connected-primary: 20;
    --pc-connected-focused: 30;
    /* stylelint-enable */
    position: relative;
    display: flex;
    align-items: center;
}

.Item {
    position: relative;
    /* stylelint-disable-next-line -- generated by polaris-migrator DO NOT COPY */
    z-index: var(--pc-connected-item);
    flex: 0 0 auto;

    &:not(:first-child) {
        margin-left: var(--p-space-100);
    }
}

/* This is a violation of our component model, but itâ€™s the cleanest
     way to remove the border radii on connected elements.
     TextField.scss has a dependency due to this override. */
.Item-primary {
    /* stylelint-disable-next-line -- generated by polaris-migrator DO NOT COPY */
    z-index: var(--pc-connected-primary);
    flex: 1 1 auto;
}

.Item-focused {
    /* stylelint-disable-next-line -- generated by polaris-migrator DO NOT COPY */
    z-index: var(--pc-connected-focused);
}
```

# components/connected/connected.svelte

```svelte
<script lang="ts">
	import styles from './connected.module.css';
	import type { ConnectedProps } from './types.js';
	import Item from './components/item/connected-item.svelte';
	let { children, left, right }: ConnectedProps = $props();
</script>

{#snippet leftConnectionMarkup()}
	{#if left}
		<Item position="left">{@render left()}</Item>
	{/if}
{/snippet}

{#snippet rightConnectionMarkup()}
	{#if right}
		<Item position="right">{@render right()}</Item>
	{/if}
{/snippet}

<div class={styles.Connected}>
    {@render leftConnectionMarkup()}
    <Item position="primary">{@render children?.()}</Item>
    {@render rightConnectionMarkup()}
</div>

```

# components/connected/types.ts

```ts
import type { Snippet } from "svelte";

export interface ConnectedProps {
    /** Content to display on the left */
    left?: Snippet;
    /** Content to display on the right */
    right?: Snippet;
    /** Connected content */
    children?: Snippet;
}

export type ItemPosition = 'left' | 'right' | 'primary';

export interface ItemProps {
  /** Position of the item */
  position: ItemPosition;
  /** Item content */
  children?: Snippet;
}
```

# components/datepicker/components/day/day.svelte

```svelte
<script lang="ts">
	import { classNames } from '$utilities/css.js';
	import { noop } from '$utilities/noop.js';
	import styles from '../../datepicker.module.css';
	import type { DayProps } from './types.js';
  import Text from '$lib/components/text/text.svelte';
	import { isSameDay } from '$utilities/dates.js';
	import { monthName } from '../../utilities.js';

	let {
		day,
		focused,
		onClick,
		onHover = noop,
		onFocus = noop,
		selected,
		inRange,
		inHoveringRange,
		disabled,
		lastDayOfMonth,
		isLastSelectedDay,
		isFirstSelectedDay,
		isHoveringRight,
		rangeIsDifferent,
		weekday,
		selectedAccessibilityLabelPrefix
	}: DayProps = $props();

	let dayNode = $state<HTMLButtonElement | null>(null);
	let hoverValue = $derived(lastDayOfMonth || day);

	$effect(() => {
		if (focused && dayNode) {
			dayNode.focus();
		}
	});

	let handleClick = $derived(day ? (onClick && !disabled ? onClick.bind(null, day) : noop) : noop);
	let today = $derived(day ? isSameDay(new Date(), day) : false);

	const dayCellClassName = $derived(
		classNames(
			styles.DayCell,
			selected && styles['DayCell-selected'],
			(inRange || inHoveringRange) && !disabled && styles['DayCell-inRange'],
			isLastSelectedDay && styles['DayCell-lastInRange'],
			isFirstSelectedDay && styles['DayCell-firstInRange'],
			isHoveringRight && styles['DayCell-hoverRight'],
			rangeIsDifferent && styles['DayCell-hasRange']
		)
	);

	const dayClassName = $derived(
		classNames(
			styles.Day,
			selected && styles['Day-selected'],
			disabled && styles['Day-disabled'],
			(inRange || inHoveringRange) && !disabled && styles['Day-inRange'],
			isLastSelectedDay && styles['Day-lastInRange'],
			isFirstSelectedDay && styles['Day-firstInRange'],
			isHoveringRight && styles['Day-hoverRight'],
			rangeIsDifferent && styles['Day-hasRange']
		)
	);

	const date = day?.getDate();
	const tabIndex = $derived((focused || selected || today || date === 1) && !disabled ? 0 : -1);

	const ariaLabel = $derived([
		selected && selectedAccessibilityLabelPrefix ? `${selectedAccessibilityLabelPrefix} ` : '',
		`${today ? 'Today' : ''}`,
		`${weekday ? weekday : ''} `,
		`${monthName(day?.getMonth() ?? 0)}`,
		`${date} `,
		`${day?.getFullYear()}`
	].join(''));
</script>

{#if !day}
	<td
		class={styles.EmptyDayCell}
		onmouseover={() => onHover(hoverValue)}
		onfocus={() => onFocus(hoverValue)}
	></td>
{:else}
<td class={dayCellClassName}>
  <button
    onfocus={() => onFocus(day)}
    type="button"
    bind:this={dayNode}
    tabIndex={tabIndex}
    class={dayClassName}
    onmouseover={() => onHover(hoverValue)}
    onclick={handleClick}
    aria-label={ariaLabel}
    aria-disabled={disabled}
    aria-pressed={selected}
  >
    <Text
      as="span"
      variant="bodySm"
      alignment="center"
      fontWeight={today ? 'bold' : 'regular'}>
      {date}
    </Text>
  </button>
</td>
{/if}

```

# components/datepicker/components/day/types.ts

```ts
export interface DayProps {
    focused?: boolean;
    day?: Date;
    selected?: boolean;
    inRange?: boolean;
    inHoveringRange?: boolean;
    disabled?: boolean;
    lastDayOfMonth?: any;
    isLastSelectedDay?: boolean;
    isFirstSelectedDay?: boolean;
    isHoveringRight?: boolean;
    rangeIsDifferent?: boolean;
    weekday?: string;
    selectedAccessibilityLabelPrefix?: string;
    onClick?(day: Date): void;
    onHover?(day?: Date): void;
    onFocus?(day: Date): void;
}
```

# components/datepicker/components/month/month.svelte

```svelte
<script lang="ts">
	import {
		dateIsInRange,
		dateIsSelected,
		getNewRange,
		getOrderedWeekdays,
		getWeeksForMonth,
		isDateAfter,
		isDateBefore,
		isDateDisabled,
		isSameDay
	} from '$utilities/dates.js';
	import { noop } from '$utilities/noop.js';
	import { monthName, weekdayName } from '../../utilities.js';
	import Day from '../day/day.svelte';
	import Weekday from '../weekday/weekday.svelte';
	import styles from '../../datepicker.module.css';
	import type { MonthProps } from './types.js';
	import type { Range } from '$utilities/dates.js';
	import Text from '$lib/components/text/text.svelte';

	let {
		focusedDate,
		selected,
		hoverDate,
		disableDatesBefore,
		disableDatesAfter,
		disableSpecificDates,
		allowRange,
		onChange = noop,
		onHover = noop,
		onFocus = noop,
		month,
		year,
		weekStartsOn,
		accessibilityLabelPrefixes
	}: MonthProps = $props();

	const now = new Date();
	const current = $derived(now.getMonth() === month && now.getFullYear() === year);
	const weeks = $state(getWeeksForMonth(month, year, weekStartsOn));

	function weekdayLabel(weekday: number) {
		return weekdayName(weekday);
	}

	function isDateStart(day: Date | null, range: Range) {
		if (day == null) return false;
		const { start } = range;

		return Boolean(start && isSameDay(start, day));
	}

	function isDateEnd(day: Date | null, range: Range) {
		if (day == null) return false;
		const { end } = range;

		return Boolean(end && isSameDay(end, day));
	}

	function hoveringDateIsInRange(day: Date | null, range: Range, hoverEndDate: Date) {
		if (day == null) {
			return false;
		}
		const { start, end } = range;
		return Boolean(isSameDay(start, end) && day > start && day <= hoverEndDate);
	}

	const handleDateClick = (selectedDate: Date) => {
		onChange(getNewRange(allowRange ? selected : undefined, selectedDate));
	};

	const lastDayOfMonth = new Date(year, (month as number) + 1, 0);
	const isInHoveringRange = allowRange ? hoveringDateIsInRange : () => false;
</script>

{#snippet weekdays()}
	{#each getOrderedWeekdays(weekStartsOn) as weekday}
		<Weekday
			title={weekdayName(weekday) ?? ''}
			label={weekdayLabel(weekday) ?? ''}
			current={current && new Date().getDay() === weekday}
		/>
	{/each}
{/snippet}

{#snippet renderWeek(day: Date, dayIndex: number)}
	{#if day == null}
		<Day {onHover} {lastDayOfMonth} />
	{:else}
		{@const disabled =
			(disableDatesBefore && isDateBefore(day, disableDatesBefore)) ||
			(disableDatesAfter && isDateAfter(day, disableDatesAfter)) ||
			(disableSpecificDates && isDateDisabled(day, disableSpecificDates))}
		{@const isFirstSelectedDay = allowRange && selected && isDateStart(day, selected)}
		{@const isLastSelectedDay =
			allowRange &&
			selected &&
			((!isSameDay(selected.start, selected.end) && isDateEnd(day, selected)) ||
				(hoverDate &&
					isSameDay(selected.start, selected.end) &&
					isDateAfter(hoverDate, selected.start) &&
					isSameDay(day, hoverDate) &&
					!isFirstSelectedDay))}
		{@const rangeIsDifferent = !(selected && isSameDay(selected.start, selected.end))}
		{@const isHoveringRight = hoverDate && isDateBefore(day, hoverDate)}
		{@const [firstAccessibilityLabelPrefix, lastAccessibilityLabelPrefix] =
			accessibilityLabelPrefixes}
		{@const accessibilityLabelPrefix =
			(allowRange && isFirstSelectedDay) || (!allowRange && firstAccessibilityLabelPrefix)
				? firstAccessibilityLabelPrefix
				: allowRange && isLastSelectedDay
					? lastAccessibilityLabelPrefix
					: ''}

		<Day
			selectedAccessibilityLabelPrefix={accessibilityLabelPrefix}
			weekday={weekdayLabel(dayIndex)}
			focused={focusedDate != null && isSameDay(day, focusedDate)}
			{day}
			{onFocus}
			onClick={handleDateClick}
			{onHover}
			selected={selected != null && dateIsSelected(day, selected)}
			inRange={selected != null && dateIsInRange(day, selected)}
			{disabled}
			inHoveringRange={selected != null &&
				hoverDate != null &&
				isInHoveringRange(day, selected, hoverDate)}
			{isLastSelectedDay}
			{isFirstSelectedDay}
			{isHoveringRight}
			{rangeIsDifferent}
		/>
	{/if}
{/snippet}

{#snippet weeksMarkup()}
	{#each weeks as week}
		<tr class={styles.Week}>
			{#each week as day, index}
				{#if day}
					{@render renderWeek(day, index)}
				{/if}
			{/each}
		</tr>
	{/each}
{/snippet}

<div class={styles.MonthContainer}>
	<table role="grid" class={styles.Month}>
		<caption class={styles.Title}>
			<Text as="span" variant="bodyMd" alignment="center" fontWeight={current ? 'bold' : 'medium'}>
				{monthName(month)}{' '}{year}
			</Text>
		</caption>
		<thead>
			<tr class={styles.WeekHeadings}>
				{@render weekdays()}
			</tr>
		</thead>
		<tbody>{@render weeksMarkup()}</tbody>
	</table>
</div>

```

# components/datepicker/components/month/types.ts

```ts
import type { Range } from "$utilities/dates.js";

export interface MonthProps {
    focusedDate?: Date;
    selected?: Range;
    hoverDate?: Date;
    month: number;
    year: number;
    disableDatesBefore?: Date;
    disableDatesAfter?: Date;
    disableSpecificDates?: Date[];
    allowRange?: boolean;
    weekStartsOn: number;
    accessibilityLabelPrefixes: [string | undefined, string];
    onChange?(date: Range): void;
    onHover?(hoverEnd: Date): void;
    onFocus?(date: Date): void;
}
```

# components/datepicker/components/weekday/types.ts

```ts
export interface WeekdayProps {
    label: string;
    title: string;
    current: boolean;
}

```

# components/datepicker/components/weekday/weekday.svelte

```svelte
<script lang="ts">
	import styles from '../../datepicker.module.css';
	import type { WeekdayProps } from './types.js';
	import Text from '$lib/components/text/text.svelte';
  let { label, title, current }: WeekdayProps = $props();
</script>

<th aria-label={label} scope="col" class={styles.Weekday}>
	<Text
		as="span"
		variant="bodySm"
		alignment="center"
		fontWeight={current ? 'bold' : 'regular'}
		tone={!current ? 'subdued' : undefined}
	>
		{title}
	</Text>
</th>

```

# components/datepicker/datepicker.module.css

```css
.DatePicker {
  /* stylelint-disable-next-line -- Polaris component custom properties */
  --pc-date-picker-range-end-border-radius: var(--p-border-radius-200);
  position: relative;
}

.MonthLayout {
  display: flex;
  flex-wrap: wrap;
  margin-top: calc(-1 * var(--p-space-400));
  margin-left: calc(-1 * var(--p-space-400));
}

.MonthContainer {
  flex: 1 1 230px;
  margin-top: var(--p-space-400);
  margin-left: var(--p-space-400);
  max-width: calc(100% - var(--p-space-400));
  min-width: 230px;
}

.Month {
  width: 100%;
  table-layout: fixed;
  border-collapse: collapse;
  border: none;
  border-spacing: 0;
}

.DayCell {
  width: calc(100% / 7);
  background: transparent;
  margin: 0;
  padding: 0;
  border-radius: var(--p-border-radius-100);
}

.DayCell-inRange {
  border-radius: 0;
}

.Day {
  display: block;
  height: 100%;
  width: 100%;
  margin: 0;
  padding: var(--p-space-200);
  background: transparent;
  border: none;
  border-radius: var(--p-border-radius-200);
  outline: none;
  color: var(--p-color-text);
  cursor: pointer;

  &:hover {
    background: var(--p-color-bg-fill-brand-hover);
    color: var(--p-color-text-brand-on-bg-fill);
    outline: var(--p-border-width-025) solid transparent;
  }

  /* stylelint-disable-next-line -- generated by polaris-migrator DO NOT COPY */
  @mixin focus-ring base, 0, base;

  &:focus-visible:not(:active) {
    /* stylelint-disable-next-line -- generated by polaris-migrator DO NOT COPY */
    @mixin focus-ring base, 0, focused;
  }
}

.Day-inRange {
  background: var(--p-color-bg-surface-brand-selected);
  border-radius: 0;

  @media (-ms-high-contrast: active) {
    -ms-high-contrast-adjust: none;
    background-color: Highlight;
    color: HighlightText;

    &:hover {
      background-color: HighlightText;
      color: Highlight;
      outline: var(--p-border-width-050) solid Highlight;
    }
  }
}

.Day-selected {
  background: var(--p-color-bg-fill-brand-selected);
  color: var(--p-color-text-brand-on-bg-fill);

  @media (-ms-high-contrast: active) {
    -ms-high-contrast-adjust: none;
    background-color: Highlight;
    color: HighlightText;

    &:hover {
      background-color: HighlightText;
      color: Highlight;
      outline: var(--p-border-width-050) solid Highlight;
    }
  }
}

.Day-disabled {
  background-color: transparent;
  color: var(--p-color-text-disabled);

  &:hover {
    background-color: transparent;
    color: var(--p-color-text-disabled);
  }

  @media (-ms-high-contrast) {
    -ms-high-contrast-adjust: none;
    color: grayText;

    &:hover {
      color: grayText;
      outline: none;
    }
  }

  &:focus {
    /* stylelint-disable-next-line -- generated by polaris-migrator DO NOT COPY */
    @mixin no-focus-ring;
  }
}

.EmptyDayCell {
  width: calc(100% / 7);
  margin: 0;
  padding: 0;
}

.Weekday {
  padding: var(--p-space-200);
  background: transparent;
}

.Header {
  position: absolute;
  top: var(--p-space-400);
  display: flex;
  justify-content: space-between;
  width: 100%;
}

.Title {
  flex: 1 1 auto;
  padding-bottom: var(--p-space-100);
}

.Day-firstInRange {
  border-radius: var(--p-border-radius-200);

  &.Day-hasRange,
  &.Day-hoverRight {
    /* stylelint-disable -- Polaris component custom properties */
    border-radius: var(--pc-date-picker-range-end-border-radius) 0 0 var(--pc-date-picker-range-end-border-radius);
    /* stylelint-enable */

    &::after {
      /* stylelint-disable -- generated by polaris-migrator DO NOT COPY */
      border-radius: var(--pc-date-picker-range-end-border-radius) 0 0 var(--pc-date-picker-range-end-border-radius);
      /* stylelint-enable */
    }
  }
}

.Day-lastInRange {
  /* stylelint-disable -- Polaris component custom properties */
  border-radius: 0 var(--pc-date-picker-range-end-border-radius) var(--pc-date-picker-range-end-border-radius) 0;
  /* stylelint-enable */

  &::after {
    /* stylelint-disable -- generated by polaris-migrator DO NOT COPY */
    border-radius: 0 var(--pc-date-picker-range-end-border-radius) var(--pc-date-picker-range-end-border-radius) 0;
    /* stylelint-enable */
  }
}

.Week {
  margin-bottom: var(--p-space-050);

  /* stylelint-disable-next-line selector-max-specificity -- generated by polaris-migrator DO NOT COPY */
  >.Day-inRange:first-child:not(.Day-firstInRange):not(.Day-lastInRange) {
    border-radius: var(--p-border-radius-100) 0 0 var(--p-border-radius-100);
  }

  /* stylelint-disable-next-line selector-max-specificity -- generated by polaris-migrator DO NOT COPY */
  >.Day-inRange:last-child:not(.Day-firstInRange):not(.Day-lastInRange) {
    border-radius: 0 var(--p-border-radius-100) var(--p-border-radius-100) 0;
  }
}

.Day-inRange,
.Day-inRange:not(:hover)+.Day {

  /* stylelint-disable-next-line selector-max-specificity -- generated by polaris-migrator DO NOT COPY */
  &::after {
    /* stylelint-disable -- generated by polaris-migrator DO NOT COPY */
    border-radius: 0 var(--pc-date-picker-range-end-border-radius) var(--pc-date-picker-range-end-border-radius) 0;
    /* stylelint-enable */
  }
}
```

# components/datepicker/datepicker.svelte

```svelte
<script lang="ts">
	import { noop } from '$utilities/noop.js';
	import styles from './datepicker.module.css';
	import type { DatePickerProps } from './types.js';
	import {
		getNextDisplayMonth,
		getNextDisplayYear,
		getPreviousDisplayMonth,
		getPreviousDisplayYear,
		isDateAfter,
		isDateBefore,
		isDateDisabled,
		type Range
	} from '$utilities/dates.js';
	import { monthName } from './utilities.js';
	import Month from './components/month/month.svelte';
	import { classNames } from '$utilities/css.js';
	import Button from '../button/button.svelte';
	import ArrowLeftIcon from '@shopify/polaris-icons/dist/svg/ArrowLeftIcon.svg?component';
	import ArrowRightIcon from '@shopify/polaris-icons/dist/svg/ArrowRightIcon.svg?component';

	let {
		id,
		selected,
		month,
		year,
		allowRange,
		multiMonth,
		disableDatesBefore,
		disableDatesAfter,
		disableSpecificDates,
		weekStartsOn = 0,
		dayAccessibilityLabelPrefix,
		onMonthChange,
		onChange = noop
	}: DatePickerProps = $props();

	let hoverDate = $state<Date | undefined>(undefined);
	let focusDate = $state<Date | undefined>(undefined);

	$effect(() => {
		selected;
		focusDate = undefined;
	});

	const handleFocus = (date: Date) => {
		focusDate = date;
	};

	const setFocusDateAndHandleMonthChange = (date: Date) => {
		if (onMonthChange) {
			onMonthChange(date.getMonth(), date.getFullYear());
		}
		hoverDate = date;
		focusDate = date;
	};

	const handleDateSelection = (range: Range) => {
		const { end } = range;

		hoverDate = end;
		focusDate = new Date(end);
		onChange(range);
	};

	const handleMonthChangeClick = (month: number, year: number) => {
		if (!onMonthChange) {
			return;
		}
		focusDate = undefined;
		onMonthChange(month, year);
	};

	const handleHover = (date: Date) => {
		hoverDate = date;
	};

	function deriveRange(selected?: Date | Range) {
		return selected instanceof Date ? { start: selected, end: selected } : selected;
	}

	const handleKeyUp = (event: KeyboardEvent) => {
		const { key } = event;

		const range = deriveRange(selected);
		const focusedDate = focusDate || (range && range.start);

		if (focusedDate == null) {
			return;
		}

		if (key === 'ArrowUp') {
			const previousWeek = new Date(focusedDate);
			previousWeek.setDate(focusedDate.getDate() - 7);
			if (
				!(
					(disableDatesBefore && isDateBefore(previousWeek, disableDatesBefore)) ||
					(disableSpecificDates && isDateDisabled(previousWeek, disableSpecificDates))
				)
			) {
				setFocusDateAndHandleMonthChange(previousWeek);
			}
		}

		if (key === 'ArrowDown') {
			const nextWeek = new Date(focusedDate);
			nextWeek.setDate(focusedDate.getDate() + 7);
			if (
				!(
					(disableDatesAfter && isDateAfter(nextWeek, disableDatesAfter)) ||
					(disableSpecificDates && isDateDisabled(nextWeek, disableSpecificDates))
				)
			) {
				setFocusDateAndHandleMonthChange(nextWeek);
			}
		}

		if (key === 'ArrowRight') {
			const tomorrow = new Date(focusedDate);
			tomorrow.setDate(focusedDate.getDate() + 1);
			if (
				!(
					(disableDatesAfter && isDateAfter(tomorrow, disableDatesAfter)) ||
					(disableSpecificDates && isDateDisabled(tomorrow, disableSpecificDates))
				)
			) {
				setFocusDateAndHandleMonthChange(tomorrow);
			}
		}

		if (key === 'ArrowLeft') {
			const yesterday = new Date(focusedDate);
			yesterday.setDate(focusedDate.getDate() - 1);
			if (
				!(
					(disableDatesBefore && isDateBefore(yesterday, disableDatesBefore)) ||
					(disableSpecificDates && isDateDisabled(yesterday, disableSpecificDates))
				)
			) {
				setFocusDateAndHandleMonthChange(yesterday);
			}
		}
	};

	function handleKeyDown(event: KeyboardEvent) {
		const { key } = event;

		if (key === 'ArrowUp' || key === 'ArrowDown' || key === 'ArrowLeft' || key === 'ArrowRight') {
			event.preventDefault();
			event.stopPropagation();
		}
	}

	const showNextYear = getNextDisplayYear(month, year);
	const showNextMonth = getNextDisplayMonth(month);

	const showNextToNextYear = getNextDisplayYear(showNextMonth, showNextYear);
	const showNextToNextMonth = getNextDisplayMonth(showNextMonth);

	const showPreviousYear = getPreviousDisplayYear(month, year);
	const showPreviousMonth = getPreviousDisplayMonth(month);

	const previousMonthName = monthName(showPreviousMonth);
	const nextMonth = multiMonth ? monthName(showNextToNextMonth) : monthName(showNextMonth);
	const nextYear = multiMonth ? showNextToNextYear : showNextYear;

	const monthIsSelected = $derived(deriveRange(selected));

	const firstDatePickerAccessibilityLabelPrefix = allowRange
		? 'Start of range'
		: dayAccessibilityLabelPrefix;
	const secondDatePickerAccessibilityLabelPrefix = 'End of range';

	const accessibilityLabelPrefixes: [string | undefined, string] = [
		firstDatePickerAccessibilityLabelPrefix,
		secondDatePickerAccessibilityLabelPrefix
	];

	const datePickerClassName = $derived(classNames(styles.DatePicker));
</script>

{#snippet secondDatePicker()}
	<Month
		onFocus={handleFocus}
		focusedDate={focusDate}
		month={showNextMonth}
		year={showNextYear}
		selected={monthIsSelected}
		{hoverDate}
		onChange={handleDateSelection}
		onHover={handleHover}
		{disableDatesBefore}
		{disableDatesAfter}
		{disableSpecificDates}
		{allowRange}
		{weekStartsOn}
		{accessibilityLabelPrefixes}
	/>
{/snippet}

<!-- svelte-ignore a11y_no_static_element_interactions -->
<div {id} class={datePickerClassName} onkeydown={handleKeyDown} onkeyup={handleKeyUp}>
	<div class={styles.Header}>
		<Button
			variant="tertiary"
			icon={ArrowLeftIcon}
			accessibilityLabel={`Show previous month, ${previousMonthName} ${showPreviousYear}`}
			onClick={() => handleMonthChangeClick(showPreviousMonth, showPreviousYear)}
		/>
		<Button
			variant="tertiary"
			icon={ArrowRightIcon}
			accessibilityLabel={`Show next month, ${nextMonth} ${nextYear}`}
			onClick={() => handleMonthChangeClick(showNextMonth, showNextYear)}
		/>
	</div>
	<div class={styles.MonthLayout}>
		<Month
			onFocus={handleFocus}
			focusedDate={focusDate}
			{month}
			{year}
			selected={deriveRange(selected)}
			{hoverDate}
			onChange={handleDateSelection}
			onHover={handleHover}
			{disableDatesBefore}
			{disableDatesAfter}
			{disableSpecificDates}
			{allowRange}
			{weekStartsOn}
			{accessibilityLabelPrefixes}
		/>
		{@render secondDatePicker()}
	</div>
</div>

```

# components/datepicker/types.ts

```ts
import type { Range } from '$utilities/dates.js';

export interface DatePickerProps {
    /** ID for the element */
    id?: string;
    /** The selected date or range of dates */
    selected?: Date | Range;
    /** The month to show, from 0 to 11. 0 is January, 1 is February ... 11 is December */
    month: number;
    /** The year to show */
    year: number;
    /** Allow a range of dates to be selected */
    allowRange?: boolean;
    /** Disable selecting dates before this. */
    disableDatesBefore?: Date;
    /** Disable selecting dates after this. */
    disableDatesAfter?: Date;
    /** Disable specific dates. */
    disableSpecificDates?: Date[];
    /** The selection can span multiple months */
    multiMonth?: boolean;
    /**
     * First day of week, from 0 to 6. 0 is Sunday, 1 is Monday ... 6 is Saturday
     * @default 0
     */
    weekStartsOn?: number;
    /** Visually hidden prefix text for selected days on single selection date pickers */
    dayAccessibilityLabelPrefix?: string;
    /** Callback when date is selected. */
    onChange?(date: Range): void;
    /** Callback when month is changed. */
    onMonthChange?(month: number, year: number): void;
}

export type { Range };
```

# components/datepicker/utilities.ts

```ts
export function monthName(month: number) {
    switch (month) {
        case 0:
            return 'january';
        case 1:
            return 'february';
        case 2:
            return 'march';
        case 3:
            return 'april';
        case 4:
            return 'may';
        case 5:
            return 'june';
        case 6:
            return 'july';
        case 7:
            return 'august';
        case 8:
            return 'september';
        case 9:
            return 'october';
        case 10:
            return 'november';
        case 11:
            return 'december';
    }
}

export function weekdayName(weekday: number) {
    switch (weekday) {
        case 0:
            return 'sunday';
        case 1:
            return 'monday';
        case 2:
            return 'tuesday';
        case 3:
            return 'wednesday';
        case 4:
            return 'thursday';
        case 5:
            return 'friday';
        case 6:
            return 'saturday';
    }
}
```

# components/description-list/description-list.module.css

```css
.DescriptionList {
  margin: 0;
  padding: 0;
  word-break: break-word;

  @media (--p-breakpoints-sm-up) {
    display: flex;
    flex-wrap: wrap;
    align-items: flex-start;
  }
}

.Term {
  font-weight: var(--p-font-weight-semibold);
  padding: var(--p-space-400) 0 var(--p-space-200);

  .spacingTight & {
    padding: var(--p-space-200) 0 var(--p-space-100);
  }

  @media (--p-breakpoints-sm-up) {
    flex: 0 1 25%;
    padding: var(--p-space-400) var(--p-space-400) var(--p-space-400) 0;

    .spacingTight & {
      padding: var(--p-space-200) var(--p-space-200) var(--p-space-200) 0;
    }

    /* stylelint-disable-next-line selector-max-class, selector-max-combinators -- generated by polaris-migrator DO NOT COPY */
    .Description+&+.Description {
      border-top: var(--p-border-width-025) solid var(--p-color-border-secondary);
    }
  }
}

.Description {
  margin-left: 0;
  padding: 0 0 var(--p-space-400);

  .spacingTight & {
    padding: 0 0 var(--p-space-200);
  }

  +.Term {
    border-top: var(--p-border-width-025) solid var(--p-color-border-secondary);
  }

  @media (--p-breakpoints-sm-up) {
    flex: 1 1 51%;
    padding: var(--p-space-400) 0;

    .spacingTight & {
      padding: var(--p-space-200) 0;
    }

    /* stylelint-disable-next-line selector-max-class, selector-max-combinators -- generated by polaris-migrator DO NOT COPY */
    +.Term+.Description {
      border-top: var(--p-border-width-025) solid var(--p-color-border-secondary);
    }
  }
}
```

# components/description-list/description-list.svelte

```svelte
<script lang="ts">
	import { classNames } from '$utilities/css.js';
	import styles from './description-list.module.css';
	import type { DescriptionListProps } from './types.js';
	import Text from '$lib/components/text/text.svelte';

	let { items, gap = 'loose' }: DescriptionListProps = $props();

	const className = $derived(
		classNames(styles.DescriptionList, gap === 'tight' && styles.spacingTight)
	);
</script>

<dl class={className}>
	{#each items as { term, description }, index}
		<dt class={styles.Term}>
			<Text as="span" variant="headingSm">
				{#if typeof term === 'string'}
					{term}
				{:else}
					{@render term()}
				{/if}
			</Text>
		</dt>
		<dd class={styles.Description}>
			{#if typeof description === 'string'}
				{description}
			{:else}
				{@render description()}
			{/if}
		</dd>
	{/each}
</dl>

```

# components/description-list/types.ts

```ts
import type { Snippet } from "svelte";

interface Item {
    /** Title of the item */
    term: string | Snippet;
    /**  Item content */
    description: string | Snippet;
}

export interface DescriptionListProps {
    /** Collection of items for list */
    items: Item[];
    /** Determines the spacing between list items */
    gap?: 'tight' | 'loose';
}
```

# components/divider/divider.module.css

```css
.Divider {
    border: 0;
    margin: 0;
}
```

# components/divider/divider.svelte

```svelte
<script lang="ts">
	import { applyStyles } from '$utilities/css.js';
	import styles from './divider.module.css';
	import type { DividerProps } from './types.js';

	let { borderColor = 'border-secondary', borderWidth = '025' }: DividerProps = $props();

	const borderColorValue = $derived(
		borderColor === 'transparent' ? borderColor : `var(--p-color-${borderColor})`
	);
</script>

<hr
	class={styles.Divider}
	style={applyStyles({
		'border-block-start': `var(--p-border-width-${borderWidth}) solid ${borderColorValue}`
	})}
/>

```

# components/divider/types.ts

```ts
import type { BorderWidthScale, ColorBorderAlias } from "@shopify/polaris-tokens";

export interface DividerProps {
    /**
     * Divider border color
     * @default 'border-secondary'
     */
    borderColor?: ColorBorderAlias | 'transparent';
    /**
     * Divider border width
     * @default '025'
     */
    borderWidth?: BorderWidthScale;
}
```

# components/empty-search-result/empty-search-result.svelte

```svelte
<script lang="ts">
	import type { EmptySearchResultProps } from './types.js';
	import Image from '../image/image.svelte';
	import Text from '../text/text.svelte';
	import BlockStack from '../block-stack/block-stack.svelte';
	let { title, description, withIllustration }: EmptySearchResultProps = $props();
	const altText = 'Empty search results';
</script>

{#snippet descriptionMarkup()}
	{#if description}
		<p>{description}</p>
	{/if}
{/snippet}

{#snippet illustrationMarkup()}
	{#if withIllustration}
		<Image alt={altText} source="empty-search.svg" draggable={false} />
	{/if}
{/snippet}

<BlockStack align="center">
	{@render illustrationMarkup()}
	<Text variant="headingLg" as="p">
		{title}
	</Text>
	<Text tone="subdued" as="span">
		{@render descriptionMarkup()}
	</Text>
</BlockStack>

```

# components/empty-search-result/empty-search.svg

This is a file of the type: SVG Image

# components/empty-search-result/types.ts

```ts
export interface EmptySearchResultProps {
    title: string;
    description?: string;
    withIllustration?: boolean;
}
```

# components/empty-state/empty-state.module.css

```css
.ImageContainer {
    position: relative;
    display: flex;
    align-items: center;
    justify-content: center;
}

.Image {
    opacity: 0;
    transition: opacity var(--p-motion-duration-150) var(--p-motion-ease);
    z-index: var(--p-z-index-1);

    &.loaded {
        opacity: 1;
    }
}

.imageContained {
    @media (--p-breakpoints-md-up) {
        position: initial;
        width: 100%;
    }
}

.SkeletonImageContainer {
    /* stylelint-disable polaris/conventions/polaris/custom-property-allowed-list -- container custom property for size to prevent layout shift */
    --pc-empty-state-skeleton-image-container-size: 226px;
    height: var(--pc-empty-state-skeleton-image-container-size);
    width: var(--pc-empty-state-skeleton-image-container-size);
    /* stylelint-enable polaris/conventions/polaris/custom-property-allowed-list -- container custom property for size  to prevent layout shift */
    display: flex;
    align-items: center;
    justify-content: center;
}

.SkeletonImage {
    position: absolute;
    z-index: var(--p-z-index-0);
    /* stylelint-disable polaris/conventions/polaris/custom-property-allowed-list -- container custom property for placeholder size */
    --pc-empty-state-skeleton-image-size: 145px;
    height: var(--pc-empty-state-skeleton-image-size);
    width: var(--pc-empty-state-skeleton-image-size);
    /* stylelint-enable polaris/conventions/polaris/custom-property-allowed-list -- container custom property for placeholder size */
    background-color: var(--p-color-bg-fill-secondary);
    border-radius: var(--p-border-radius-full);
    opacity: 1;
    transition: opacity var(--p-motion-duration-500) var(--p-motion-ease);

    &.loaded {
        opacity: 0;
    }

    @media screen and (-ms-high-contrast: active) {
        background-color: grayText;
    }
}
```

# components/empty-state/empty-state.svelte

```svelte
<script lang="ts">
	import type { EmptyStateProps } from './types.js';
	import styles from './empty-state.module.css';
	import { classNames } from '$utilities/css.js';
	import Image from '../image/image.svelte';
	import ButtonFrom from '../button/button-from.svelte';
	import Box from '../box/box.svelte';
	import Text from '../text/text.svelte';
	import InlineStack from '../inline-stack/inline-stack.svelte';
	import BlockStack from '../block-stack/block-stack.svelte';

	let {
		children,
		heading,
		image,
		largeImage,
		imageContained,
		fullWidth = false,
		action,
		secondaryAction,
		footerContent
	}: EmptyStateProps = $props();

	let imageLoaded = $state(false);
	let imageRef: HTMLImageElement | undefined = $state();
	$effect(() => {
		if (imageRef?.complete) {
			imageLoaded = true;
		}
	});

	const imageClassNames = $derived(
		classNames(styles.Image, imageLoaded && styles.loaded, imageContained && styles.imageContained)
	);

	const skeletonImageClassNames = $derived(
		classNames(styles.SkeletonImage, imageLoaded && styles.loaded)
	);

	const imageContainerClassNames = $derived(
		classNames(styles.ImageContainer, !imageLoaded && styles.SkeletonImageContainer)
	);
</script>

{#snippet loadedImageMarkup()}
	{#if largeImage}
		<Image
			alt=""
			role="presentation"
			ref={imageRef}
			source={largeImage}
			className={imageClassNames}
			sourceSet={[
				{ source: image, descriptor: '568w' },
				{ source: largeImage, descriptor: '1136w' }
			]}
			sizes="(max-width: 568px) 60vw"
			onLoad={() => (imageLoaded = true)}
		/>
	{:else}
		<Image
			alt=""
			role="presentation"
			ref={imageRef}
			className={imageClassNames}
			source={image}
			onLoad={() => (imageLoaded = true)}
		/>
	{/if}
{/snippet}

{#snippet imageMarkup()}
	<div class={imageContainerClassNames}>
		{@render loadedImageMarkup()}
		<div class={skeletonImageClassNames}></div>
	</div>
{/snippet}

{#snippet secondaryActionMarkup()}
	{#if secondaryAction}
		<ButtonFrom overrides={{ variant: 'secondary' }} action={secondaryAction} />
	{/if}
{/snippet}

{#snippet footerContentMarkup()}
	<Box paddingBlockStart="400">
		<Text as="span" alignment="center" variant="bodySm">
			{@render footerContent?.()}
		</Text>
	</Box>
{/snippet}

{#snippet primaryActionMarkup()}
	{#if action}
		<ButtonFrom overrides={{ variant: 'primary' }} {action} />
	{/if}
{/snippet}

{#snippet headingMarkup()}
	<Box paddingBlockEnd="150">
		<Text variant="headingMd" as="p" alignment="center">
			{heading}
		</Text>
	</Box>
{/snippet}

{#snippet childrenMarkup()}
	<Text as="span" alignment="center" variant="bodySm">
		{@render children?.()}
	</Text>
{/snippet}

{#snippet textContentMarkup()}
	<Box paddingBlockEnd="400">
		{@render headingMarkup()}
		{@render childrenMarkup()}
	</Box>
{/snippet}

{#snippet actionsMarkup()}
	<InlineStack align="center" gap="200">
		{@render secondaryActionMarkup()}
		{@render primaryActionMarkup()}
	</InlineStack>
{/snippet}

{#snippet detailsMarkup()}
	<Box maxWidth={fullWidth ? '100%' : '400px'}>
		<BlockStack inlineAlign="center">
			{@render textContentMarkup()}
			{@render actionsMarkup()}
			{@render footerContentMarkup()}
		</BlockStack>
	</Box>
{/snippet}

<Box paddingInlineStart="0" paddingInlineEnd="0" paddingBlockStart="500" paddingBlockEnd="1600">
	<BlockStack inlineAlign="center">
		{@render imageMarkup()}
		{@render detailsMarkup()}
	</BlockStack>
</Box>

```

# components/empty-state/types.ts

```ts
import type { ComplexAction } from "$utilities/types.js";
import type { Snippet } from "svelte";

export interface EmptyStateProps {
    /** The empty state heading */
    heading?: string;
    /**
     * The path to the image to display.
     * The image should have ~40px of white space above when empty state is used within a card, modal, or navigation component
     */
    image: string;
    /** The path to the image to display on large screens */
    largeImage?: string;
    /** Whether or not to limit the image to the size of its container on large screens */
    imageContained?: boolean;
    /** Whether or not the content should span the full width of its container  */
    fullWidth?: boolean;
    /** Elements to display inside empty state */
    children?: Snippet;
    /** Primary action for empty state */
    action?: ComplexAction;
    /** Secondary action for empty state */
    secondaryAction?: ComplexAction;
    /** Secondary elements to display below empty state actions */
    footerContent?: Snippet;
  }
```

# components/event-listener/event-listener.svelte

```svelte
<script lang="ts">
	import { onDestroy, onMount } from 'svelte';
	import type { BaseEventProps, EventListenerProps } from './types.js';
	let { event, capture, handler, window: customWindow, passive }: EventListenerProps = $props();

	const attachListener = () => {
		const window = customWindow || globalThis.window;
		window?.addEventListener(event, handler, { capture, passive });
	};

	const detachListener = (prevProps?: BaseEventProps) => {
		const window = customWindow || globalThis.window;
		window?.removeEventListener(event, handler, capture);
	};

	onMount(() => {
		//console.log("In EventListner onMount");
		attachListener();
	});

	onDestroy(() => {
		//console.log("In EventListner onDestroy");
		detachListener();
	});
</script>

```

# components/event-listener/types.ts

```ts
export interface BaseEventProps {
    event: string;
    capture?: boolean;
    handler(event: Event): void;
    window?: Window | null;
}

export interface EventListenerProps extends BaseEventProps {
    passive?: boolean;
}
```

# components/filters/components/filter-bar/filter-bar.svelte

```svelte
<script lang="ts">
	import UnstyledButton from '$lib/components/button/unstyled-button.svelte';
	import type { PropsWithChildren } from '$utilities/props-with-children.js';
	import type { ActionListItemDescriptor, FilterInterface } from '$utilities/types.js';
	import styles from '../../filters.module.css';
	import type { FiltersBarProps } from './types.js';
	import Text from '$lib/components/text/text.svelte';
	import PlusIcon from '@shopify/polaris-icons/dist/svg/PlusIcon.svg?component';
	import FilterPill from '../filter-pill/filter-pill.svelte';
	import Popover from '$lib/components/popover/popover.svelte';
	import ActionList from '$lib/components/action-list/action-list.svelte';
	import { classNames } from '$utilities/css.js';
	import Button from '$lib/components/button/button.svelte';
	import Box from '$lib/components/box/box.svelte';
	import InlineStack from '$lib/components/inline-stack/inline-stack.svelte';

	let {
		filters,
		appliedFilters,
		onClearAll,
		disabled,
		hideQueryField,
		disableFilters,
		mountedStateStyles,
		onAddFilterClick,
		closeOnChildOverlayClick,
		children,
	}: PropsWithChildren<FiltersBarProps> = $props();


	let popoverActive = $state(false);
	let hasMounted = $state(false);

	const togglePopoverActive = () => (popoverActive = !popoverActive);

	const handleAddFilterClick = () => {
		onAddFilterClick?.();
		togglePopoverActive();
	};

	const appliedFilterKeys = $derived(appliedFilters?.map(({ key }) => key));

	const pinnedFromPropsKeys = $derived(filters.filter(({ pinned }) => pinned).map(({ key }) => key));

	const pinnedFiltersFromPropsAndAppliedFilters = $derived(filters.filter(({ pinned, key }) => {
		const isPinnedOrApplied = Boolean(pinned) || appliedFilterKeys?.includes(key);
		return isPinnedOrApplied;
	}));

	let localPinnedFilters = $derived<string[]>(
		pinnedFiltersFromPropsAndAppliedFilters.map(({ key }) => key)
	);

	$effect(() => {
		localPinnedFilters = pinnedFiltersFromPropsAndAppliedFilters.map(({ key }) => key);
	});

	const pinnedFilters = $derived(
		localPinnedFilters
			.map((key) => filters.find((filter) => filter.key === key))
			.reduce<FilterInterface[]>((acc, filter) => (filter ? [...acc, filter] : acc), [])
	);

	const onFilterClick =
		({ key, onAction }: FilterInterface) =>
		() => {
			// PopoverOverlay will cause a rerender of the component and nuke the
			// popoverActive state, so we set this as a microtask
			setTimeout(() => {
				localPinnedFilters = [...new Set([...localPinnedFilters, key])];
				onAction?.();
				togglePopoverActive();
			}, 0);
		};

	const filterToActionItem = (filter: FilterInterface) => ({
		...filter,
		content: filter.label,
		onAction: onFilterClick(filter)
	});

	const unpinnedFilters = filters.filter(
		(filter) => !pinnedFilters.some(({ key }) => key === filter.key)
	);

	const unsectionedFilters = unpinnedFilters
		.filter((filter) => !filter.section && !filter.hidden)
		.map(filterToActionItem);

	const sectionedFilters = unpinnedFilters
		.filter((filter) => filter.section)
		.reduce(
			(acc, filter) => {
				const filterActionItem = filterToActionItem(filter);
				const sectionIndex = acc.findIndex((section) => section.title === filter.section);

				if (sectionIndex === -1) {
					acc.push({
						title: filter.section!,
						items: [filterActionItem]
					});
				} else {
					acc[sectionIndex].items.push(filterActionItem);
				}

				return acc;
			},
			[] as {
				title: string;
				items: ActionListItemDescriptor[];
			}[]
		);

	const hasOneOrMorePinnedFilters = $derived(pinnedFilters.length >= 1);

	const handleClearAllFilters = () => {
		localPinnedFilters = pinnedFromPropsKeys;
		onClearAll?.();
	};
	const shouldShowAddButton = $derived(
		filters.some((filter) => !filter.pinned) || filters.length !== localPinnedFilters.length
	);

	const appliedFilter = (filterKey: string) => appliedFilters?.find(({ key }) => key === filterKey);

	const handleFilterPillRemove = (filterKey: string) => {
		(localPinnedFilters = localPinnedFilters.filter((key) => {
			const isMatchedFilters = key === filterKey;
			const isPinnedFilterFromProps = pinnedFromPropsKeys.includes(key);
			return !isMatchedFilters || isPinnedFilterFromProps;
		})),
			appliedFilter(filterKey)?.onRemove?.(filterKey);
	};
</script>

{#snippet addFilterActivator()}
	<div>
		<UnstyledButton
			type="button"
			class={styles.AddFilter}
			onClick={handleAddFilterClick}
			aria-label="Add filter"
			disabled={disabled ||
				(unsectionedFilters.length === 0 && sectionedFilters.length === 0) ||
				disableFilters}
		>
			<Text as="span" variant="bodySm" tone={disabled ? 'disabled' : 'base'}>Add filter</Text>
			<PlusIcon />
		</UnstyledButton>
	</div>
{/snippet}

{#snippet pinnedFiltersMarkup()}
	{#each pinnedFilters as { key: filterKey, ...pinnedFilter }}
		{@const appliedFilterz = appliedFilter(filterKey)}
		<FilterPill
			key={filterKey}
			{...pinnedFilter}
			initialActive={hasMounted && !pinnedFilter.pinned && !appliedFilterz}
			unsavedChanges={appliedFilterz?.unsavedChanges}
			label={appliedFilterz?.label || pinnedFilter.label}
			{filterKey}
			selected={appliedFilterKeys?.includes(filterKey)}
			onRemove={(filterKey) => handleFilterPillRemove(filterKey)}
			disabled={pinnedFilter.disabled || disableFilters}
			{closeOnChildOverlayClick}
		/>
	{/each}
{/snippet}

{#snippet addButton()}
	{#if shouldShowAddButton}
		<div
			class={classNames(
				styles.AddFilterActivator,
				hasOneOrMorePinnedFilters && styles.AddFilterActivatorMultiple
			)}
		>
			<Popover
				active={popoverActive && !disabled}
				onClose={togglePopoverActive}
				trigger={addFilterActivator}
			>
				<ActionList actionRole="menuitem" items={unsectionedFilters} sections={sectionedFilters} />
			</Popover>
		</div>
	{/if}
{/snippet}

{#snippet clearAllMarkup()}
	{#if appliedFilters?.length}
		<div
			class={classNames(
				styles.ClearAll,
				hasOneOrMorePinnedFilters && shouldShowAddButton && styles.MultiplePinnedFilterClearAll
			)}
		>
			<Button size="micro" onClick={handleClearAllFilters} variant="monochromePlain">
				Clear all
			</Button>
		</div>
	{/if}
{/snippet}

<div
	class={classNames(
		styles.FiltersWrapper,
		shouldShowAddButton && hasOneOrMorePinnedFilters && styles.FiltersWrapperWithAddButton
	)}
	aria-live="polite"
	style={mountedStateStyles}
>
	<div class={classNames(styles.FiltersInner)}>
		<div class={classNames(styles.FiltersStickyArea)}>
			{@render pinnedFiltersMarkup()}
			{@render addButton()}
			{@render clearAllMarkup()}
		</div>
	</div>
	{#if hideQueryField}
		<Box paddingInlineEnd="300" paddingBlockStart="200" paddingBlockEnd="200">
			<InlineStack
				align="start"
				blockAlign="center"
				gap={{
					xs: '400',
					md: '300'
				}}
			>
				{@render children?.()}
			</InlineStack>
		</Box>
	{/if}
</div>

```

# components/filters/components/filter-bar/types.ts

```ts
import type { TransitionStatus } from "$lib/components/popover/components/popover-overlay/types.js";
import type { AppliedFilterInterface, FilterInterface } from "$utilities/types.js";

export interface FiltersBarProps {
    /** Currently entered text in the query field */
    queryValue?: string;
    /** Placeholder text for the query field. */
    queryPlaceholder?: string;
    /** Whether the query field is focused. */
    focused?: boolean;
    /** Available filters added to the filter bar. Shortcut filters are pinned to the front of the bar. */
    filters: FilterInterface[];
    /** Applied filters which are rendered as filter pills. The remove callback is called with the respective key. */
    appliedFilters?: AppliedFilterInterface[];
    /** Callback when the reset all button is pressed. */
    onClearAll: () => void;
    /** Disable all filters. */
    disabled?: boolean;
    /** Hide the query field. */
    hideQueryField?: boolean;
    /** Disable the filters */
    disableFilters?: boolean;
    mountedState?: TransitionStatus;
    /** Callback when the add filter button is clicked. */
    onAddFilterClick?: () => void;
    /** Whether the filter should close when clicking inside another Popover. */
    closeOnChildOverlayClick?: boolean;
    mountedStateStyles?: any;
}
```

# components/filters/components/filter-pill/filter-pill.module.css

```css
.FilterButton {
  background: var(--p-color-bg-surface);
  border-radius: var(--p-border-radius-200);
  border: var(--p-color-border) dashed var(--p-border-width-025);
  cursor: pointer;
  color: var(--p-color-text);

  /* stylelint-disable-next-line -- generated by polaris-migrator DO NOT COPY */
  @mixin focus-ring base, var(--p-border-width-025);

  /* stylelint-disable-next-line selector-max-specificity -- specificity is required to override focus-ring mixin */
  &.focusedFilterButton:focus-within:not(:active) {
    /* stylelint-disable-next-line -- generated by polaris-migrator DO NOT COPY */
    @mixin focus-ring base, 0, focused;
  }

  &:hover,
  &:focus,
  &:active {
    background: var(--p-color-bg-surface-hover);
    border-color: var(--p-color-border);

    path {
      fill: var(--p-color-icon-hover);
    }
  }

  &:hover,
  &:active {
    border-style: solid;
  }

  &:hover,
  &:focus {
    background: transparent;
  }

  &:active {
    background: var(--p-color-bg-surface-secondary);
  }

  &.ActiveFilterButton {
    background: var(--p-color-bg-surface);
    border-style: solid;

    &:active {
      background: var(--p-color-bg-surface-secondary);
    }
  }

  &::after {
    border-radius: var(--p-border-radius-200);
  }
}

.PlainButton {
  background: none;
  color: inherit;
  border: none;
  padding: 0;
  font: inherit;
  cursor: inherit;
  outline: inherit;

  path {
    fill: var(--p-color-icon);
  }

  &[aria-disabled='true'] {
    path {
      fill: var(--p-color-icon-disabled);
    }
  }
}

.ToggleButton {
  padding: 0 var(--p-space-200) 0 var(--p-space-300);
  height: 26px;

  @media (--p-breakpoints-md-up) {
    padding: 0 var(--p-space-100) 0 var(--p-space-200);
    height: 22px;
  }
}

.ActiveFilterButton .ToggleButton {
  padding-right: var(--p-space-050);

  @media (--p-breakpoints-md-up) {
    padding-right: 0;
  }
}

.clearButton {
  /* stylelint-disable-next-line -- generated by polaris-migrator DO NOT COPY */
  @mixin focus-ring base, 0, base;
  margin-right: var(--p-space-200);

  @media (--p-breakpoints-md-up) {
    margin-right: var(--p-space-100);
  }

  &:focus-visible:not(:active) {
    /* stylelint-disable-next-line -- generated by polaris-migrator DO NOT COPY */
    @mixin focus-ring base, 0, focused;
  }
}

.IconWrapper {
  @media (--p-breakpoints-md-up) {
    scale: 0.8;
  }
}

.PopoverWrapper {
  min-width: 185px;
  max-width: 300px;
  word-break: break-word;
}

.ClearButtonWrapper {
  button {
    min-height: 0;
    padding: 0;
    margin: 0;
  }
}
```

# components/filters/components/filter-pill/filter-pill.svelte

```svelte
<script lang="ts">
	import Icon from '$lib/components/icon/icon.svelte';
	import { UseToggle } from '$lib/use/use-toggle.svelte.js';
	import { classNames } from '$utilities/css.js';
	import ChevronDownIcon from '@shopify/polaris-icons/dist/svg/ChevronDownIcon.svg?component';
	import styles from './filter-pill.module.css';
	import type { FilterPillProps } from './types.js';
	import Box from '$lib/components/box/box.svelte';
	import InlineStack from '$lib/components/inline-stack/inline-stack.svelte';
	import Text from '$lib/components/text/text.svelte';
	import Button from '$lib/components/button/button.svelte';
	import XSmallIcon from '@shopify/polaris-icons/dist/svg/XSmallIcon.svg?component';
	import UnstyledButton from '$lib/components/button/unstyled-button.svelte';
	import Popover from '$lib/components/popover/index.js';
	import BlockStack from '$lib/components/block-stack/block-stack.svelte';
	import { getContext, type Snippet } from 'svelte';
	import type { VueNode } from '$utilities/types.js';
	import { isSvelteConstruct } from '$lib/components/page/components/page-header/types.js';

	let {
		unsavedChanges = false,
		filterKey,
		label,
		filter,
		disabled,
		hideClearButton,
		selected,
		initialActive,
		disclosureZIndexOverride,
		closeOnChildOverlayClick,
		onRemove,
		onClick
	}: FilterPillProps = $props();

	let elementRef = $state<HTMLDivElement>();
	const focused = new UseToggle(false);
	const setFocusedTrue = focused.setTrue;
	const setFocusedFalse = focused.setFalse;
	let popoverActive = $derived(initialActive);

	const setScroll = (node: Node) => {
		if (!node || !popoverActive) {
			return;
		}

		const parent = node.parentElement?.parentElement;

		if (!parent) {
			return;
		}

		parent.scroll?.({
			left: (node as HTMLElement).offsetLeft
		});
	};

	const togglePopoverActive = () => {
		if (filter) {
			popoverActive = !popoverActive;
		}

		if (onClick) {
			onClick(filterKey);
		}
	};

	const handlePopoverClose = () => {
		togglePopoverActive();
		if (!selected) {
			onRemove?.(filterKey);
		}
	};

	const handleClear = () => {
		if (onRemove) onRemove(filterKey);
		popoverActive = false;
	};

	const buttonClasses = $derived(
		classNames(
			styles.FilterButton,
			selected && styles.ActiveFilterButton,
			popoverActive && styles.FocusFilterButton,
			focused && styles.focusedFilterButton
		)
	);

	const clearButtonClassNames = $derived(classNames(styles.PlainButton, styles.clearButton));

	const toggleButtonClassNames = $derived(classNames(styles.PlainButton, styles.ToggleButton));
</script>

{#snippet disclosureMarkup()}
	{#if !selected}
		<div class={styles.IconWrapper}>
			<Icon source={ChevronDownIcon} tone="base" />
		</div>
	{/if}
{/snippet}

{#snippet labelMarkup()}
	<Box paddingInlineStart={unsavedChanges ? '0' : '050'}>
		<InlineStack>
			<Text variant="bodySm" as="span">
				{label}
			</Text>
		</InlineStack>
	</Box>
{/snippet}

{#snippet unsavedPip()}
	{#if unsavedChanges}
		<Box paddingInlineEnd="150">
			<Box background="bg-fill-emphasis" borderRadius="050" width="6px" minHeight="6px" />
		</Box>
	{/if}
{/snippet}

{#snippet removeFilterButtonMarkup()}
	{#if selected}
		<UnstyledButton
			onClick={handleClear}
			class={clearButtonClassNames}
			type="button"
			aria-label="Clear"
		>
			<div class={styles.IconWrapper}>
				<Icon source={XSmallIcon} tone="base" />
			</div>
		</UnstyledButton>
	{/if}
{/snippet}

{#snippet activator()}
	<div class={buttonClasses}>
		<InlineStack gap="0" wrap={false}>
			<UnstyledButton
				onFocus={setFocusedTrue}
				onBlur={setFocusedFalse}
				onClick={togglePopoverActive}
				class={toggleButtonClassNames}
				type="button"
				accessibilityLabel={unsavedChanges ? `Unsaved changes - ${label}` : label}
			>
				<InlineStack wrap={false} align="center" blockAlign="center" gap="0">
					{@render unsavedPip()}
					{@render labelMarkup()}
					{@render disclosureMarkup()}
				</InlineStack>
			</UnstyledButton>

			{@render removeFilterButtonMarkup()}
		</InlineStack>
	</div>
{/snippet}

{#snippet clearButtonMarkup()}
	{#if !hideClearButton}
		<div class={styles.ClearButtonWrapper}>
			<Button onClick={handleClear} variant="plain" disabled={!selected} textAlign="left">
				Clear
			</Button>
		</div>
	{/if}
{/snippet}

{#snippet renderVueNode(vueNode: VueNode)}
	{#if isSvelteConstruct(vueNode)}
		{@render vueNode()}
	{:else}
		{vueNode}
	{/if}
{/snippet}

{#if !disabled}
	<div use:setScroll bind:this={elementRef}>
		<Popover
			active={popoverActive}
			onClose={handlePopoverClose}
			preferredAlignment="left"
			zIndexOverride={disclosureZIndexOverride}
			preventCloseOnChildOverlayClick={!closeOnChildOverlayClick}
		>
			{#snippet trigger()}
				{@render activator()}
			{/snippet}

			<div class={styles.PopoverWrapper}>
				<Popover.Section>
					<BlockStack gap="100">
						{@render renderVueNode(filter)}
						{@render clearButtonMarkup()}
					</BlockStack>
				</Popover.Section>
			</div>
		</Popover>
	</div>
{/if}

```

# components/filters/components/filter-pill/types.ts

```ts
import type { FilterInterface } from "$utilities/types.js";

export interface FilterPillProps extends FilterInterface {
    /** Whether the filter is newly applied or updated and hasn't been saved */
    unsavedChanges?: boolean;
    /** A unique identifier for the filter */
    filterKey: string;
    /** Whether the filter is selected or not */
    selected?: boolean;
    /** Whether the Popover will be initially open or not */
    initialActive: boolean;
    /** Whether filtering is disabled */
    disabled?: boolean;
    /** Override z-index of popovers and tooltips */
    disclosureZIndexOverride?: number;
    /** Whether the filter should close when clicking inside another Popover. */
    closeOnChildOverlayClick?: boolean;
    /** Callback invoked when the filter is removed */
    onRemove?(key: string): void;
    /** Callback invoked when the filter is clicked */
    onClick?(key: string): void;
}
```

# components/filters/components/search-field/search-field.svelte

```svelte
<script lang="ts">
	import { UseBreakpoints } from '$lib/use/use-breakpoints.svelte.js';
	import type { SearchFieldProps } from './types.js';
	import Text from '$lib/components/text/text.svelte';
	import TextField from '$lib/components/text-field/text-field.svelte';
	import Icon from '$lib/components/icon/icon.svelte';
	import SearchIcon from '@shopify/polaris-icons/dist/svg/SearchIcon.svg?component';

	let {
		onChange,
		onClear,
		onFocus,
		onBlur,
		focused,
		value,
		placeholder,
		disabled,
		borderlessQueryField,
		loading,
		selectedViewName
	}: SearchFieldProps = $props();

	const id = $props.id();
	const bp = new UseBreakpoints();
	const mdUp = $derived(bp.breakpoints?.mdUp);

	function handleChange(eventValue: string) {
		onChange(eventValue ?? value);
	}

	function handleClear() {
		if (onClear) {
			onClear();
		} else {
			onChange('');
		}
	}
</script>

{#snippet suffix()}
	{#if value && selectedViewName && mdUp}
		<Text as="span" variant="bodyMd" tone="subdued">
			{`in:${selectedViewName}`}
		</Text>
	{/if}
{/snippet}

{#snippet prefix()}
	{#if mdUp}
		<Icon source={SearchIcon} />
	{/if}
{/snippet}

<TextField
	{id}
	{value}
	onChange={handleChange}
	{onFocus}
	{onBlur}
	onClearButtonClick={handleClear}
	autoComplete="off"
	{placeholder}
	{disabled}
	variant={borderlessQueryField ? 'borderless' : 'inherit'}
	size="slim"
	{prefix}
	{suffix}
	{focused}
	label={placeholder ?? ""}
	labelHidden
	clearButton
	autoSize={Boolean(suffix)}
	{loading}
/>

```

# components/filters/components/search-field/types.ts

```ts
export interface SearchFieldProps {
    onChange: (value: string) => void;
    onFocus?: () => void;
    onBlur?: () => void;
    onClear?: () => void;
    focused?: boolean;
    value?: string;
    placeholder?: string;
    disabled?: boolean;
    borderlessQueryField?: boolean;
    /** Show a loading spinner to the right of the input */
    loading?: boolean;
    /** @deprecated If present, will show as a suffix in the text field when entering a search term */
    selectedViewName?: string;
}
```

# components/filters/filters.module.css

```css
.Container {
  position: relative;
  /* stylelint-disable-next-line -- z-index below Card shadow bevel (32) */
  z-index: 30;
  border-bottom: var(--p-border-width-025) solid var(--p-color-border-secondary);
  border-top-left-radius: var(--p-border-radius-200);
  border-top-right-radius: var(--p-border-radius-200);
  background: var(--p-color-bg-surface);
}

@media (--p-breakpoints-sm-down) {
  .Container {
    border-top-left-radius: 0;
    border-top-right-radius: 0;
  }
}

.SearchField {
  flex: 1;
}

.FiltersWrapper {
  border-bottom: var(--p-border-width-025) solid var(--p-color-border-secondary);
  height: 53px;
  overflow: hidden;

  @media (--p-breakpoints-sm-down) {
    background: var(--p-color-bg-surface);
  }

  @media (--p-breakpoints-md-up) {
    height: auto;
    overflow: visible;
  }
}

.hideQueryField .FiltersWrapper {
  display: flex;
  align-items: center;
}

.FiltersInner {
  overflow: auto;
  white-space: nowrap;
  padding: var(--p-space-300) var(--p-space-200) var(--p-space-500);
}

.hideQueryField .FiltersInner {
  flex: 1;
  padding: var(--p-space-300);
}

@media (--p-breakpoints-md-up) {
  .FiltersInner {
    overflow: visible;
    flex-wrap: wrap;
    gap: var(--p-space-200);
    /* stylelint-disable-next-line -- No 6px space token */
    padding: 0.375rem var(--p-space-200);
  }

  .hideQueryField .FiltersInner {
    flex: 1;
    /* stylelint-disable-next-line -- No 6px space token */
    padding: 0.375rem var(--p-space-200);
  }
}

.AddFilter {
  background: var(--p-color-bg-surface);
  border-radius: var(--p-border-radius-200);
  border: var(--p-color-border) dashed var(--p-border-width-025);
  padding: 0 var(--p-space-200) 0 var(--p-space-300);
  height: 28px;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  outline: inherit;
  /* stylelint-disable-next-line -- generated by polaris-migrator DO NOT COPY */
  @mixin focus-ring base, var(--p-border-width-025);

  path {
    fill: var(--p-color-icon);
  }

  @media (--p-breakpoints-md-up) {
    height: 24px;
    /* stylelint-disable-next-line -- generated by polaris-migrator DO NOT COPY */
    padding: 0 0.375rem 0 var(--p-space-200);
  }

  &:hover,
  &:focus {
    background: transparent;
    border-color: var(--p-color-border-hover);

    path {
      fill: var(--p-color-icon-hover);
    }
  }

  &:hover {
    border-style: solid;
  }

  &:focus {
    outline-offset: var(--p-border-width-050);
  }

  &:active {
    background: var(--p-color-bg-surface-tertiary);
    border-color: var(--p-color-border-hover);
  }

  &[aria-disabled='true'] {
    background: var(--p-color-bg-fill-disabled);
    border-color: transparent;
    color: var(--p-color-text-disabled);
    cursor: default;

    path {
      fill: var(--p-color-icon-disabled);
    }
  }

  &:focus-visible:not(:active) {
    /* stylelint-disable-next-line -- generated by polaris-migrator DO NOT COPY */
    @mixin focus-ring base, 0, focused;
  }

  &::after {
    border-radius: var(--p-border-radius-200);
  }

  span {
    margin-right: var(--p-space-050);

    @media (--p-breakpoints-md-up) {
      margin-right: var(--p-space-025);
    }
  }

  svg {
    width: var(--p-space-500);

    @media (--p-breakpoints-md-up) {
      width: var(--p-space-400);
    }
  }
}

@media (--p-breakpoints-md-down) {
  .FiltersWrapperWithAddButton {
    position: relative;

    .FiltersInner {
      padding: var(--p-space-200);
      padding-right: 0;
    }
  }

  .AddFilterActivatorMultiple {
    position: sticky;
    z-index: var(--p-z-index-1);
    top: 0;
    right: 0;
    display: flex;
    padding: var(--p-space-100) var(--p-space-400) var(--p-space-100) 0;
    background: var(--p-color-bg-surface);
    margin-left: var(--p-space-200);

    &::before {
      content: '';
      position: absolute;
      top: 0;
      left: -12px;
      width: 12px;
      height: 100%;
      pointer-events: none;
      /* stylelint-disable -- needed to create the fade effect */
      background: linear-gradient(90deg,
          rgba(255, 255, 255, 0) 0%,
          var(--p-color-bg-surface) 70%,
          var(--p-color-bg-surface) 100%);
      /* stylelint-enable */
    }

    .AddFilter {
      padding: var(--p-space-300) var(--p-space-200);

      /* stylelint-disable-next-line selector-max-combinators -- required to hide the text of the button */
      span {
        display: none;
      }
    }
  }
}

.FiltersStickyArea {
  position: relative;
  display: flex;
  gap: var(--p-space-100);
  flex-wrap: nowrap;
  align-items: center;
  justify-content: flex-start;

  @media (--p-breakpoints-md-up) {
    flex-wrap: wrap;
  }
}

.ClearAll {
  margin-left: var(--p-space-200);
}

@media (--p-breakpoints-md-down) {
  .ClearAll {
    margin-left: 0;
    padding-right: var(--p-space-400);
  }

  .MultiplePinnedFilterClearAll {
    transform: translateX(-8px);
    position: relative;
    z-index: var(--p-z-index-1);
    margin-left: 0;
    padding-right: var(--p-space-400);
  }
}
```

# components/filters/filters.svelte

```svelte
<script lang="ts">
	import { applyStyles, classNames } from '$utilities/css.js';
	import styles from './filters.module.css';
	import {
		defaultFilterStyles,
		defaultStyle,
		transitionFilterStyles,
		transitionStyles,
		type FiltersProps
	} from './types.js';
	import FiltersBar from './components/filter-bar/filter-bar.svelte';
	import Box from '../box/box.svelte';
	import InlineStack from '../inline-stack/inline-stack.svelte';
	import SearchField from './components/search-field/search-field.svelte';

	let {
		queryValue,
		queryPlaceholder,
		focused,
		filters,
		appliedFilters,
		onQueryChange,
		onQueryClear,
		onQueryBlur,
		onQueryFocus,
		onClearAll,
		children,
		disabled,
		hideFilters,
		hideQueryField,
		disableQueryField,
		borderlessQueryField,
		loading,
		disableFilters,
		mountedState,
		onAddFilterClick,
		closeOnChildOverlayClick,
		selectedViewName
	}: FiltersProps = $props();

	const hideFilterBar = $derived(hideFilters || filters.length === 0);

	const mountedStateStyles = $derived(
		mountedState && !hideQueryField
			? {
					...defaultFilterStyles,
					...transitionFilterStyles[mountedState]
				}
			: undefined
	);
</script>

{#snippet queryFieldMarkup()}
	{#if !hideQueryField}
		<div class={styles.Container}>
			<Box padding="200">
				<InlineStack
					align="start"
					blockAlign="center"
					gap={{
						xs: '400',
						md: '300'
					}}
				>
					<div
						class={styles.SearchField}
						style={mountedState
							? applyStyles({
									...defaultStyle,
									...transitionStyles[mountedState]
								})
							: undefined}
					>
						<SearchField
							onChange={onQueryChange}
							onFocus={onQueryFocus}
							onBlur={onQueryBlur}
							onClear={onQueryClear}
							value={queryValue}
							placeholder={queryPlaceholder}
							{focused}
							disabled={disabled || disableQueryField}
							{borderlessQueryField}
							{loading}
							{selectedViewName}
						/>
					</div>
					{@render children?.()}
				</InlineStack>
			</Box>
		</div>
	{/if}
{/snippet}

{#snippet filtersMarkup()}
	{#if !hideFilterBar}
		<FiltersBar
			{filters}
			{appliedFilters}
			{onClearAll}
			{disabled}
			{hideQueryField}
			{disableFilters}
			{onAddFilterClick}
			{closeOnChildOverlayClick}
			{mountedStateStyles}
		>
			{@render children?.()}
		</FiltersBar>
	{/if}
{/snippet}

<div class={classNames(styles.Filters, hideQueryField && styles.hideQueryField)}>
	{@render queryFieldMarkup()}
	{@render filtersMarkup()}
</div>

```

# components/filters/types.ts

```ts
import type { AppliedFilterInterface, FilterInterface } from "$utilities/types.js";
import type { Snippet } from "svelte";
import type { TransitionStatus } from "../popover/components/popover-overlay/types.js";

export const TRANSITION_DURATION = 'var(--p-motion-duration-150)';
export const TRANSITION_MARGIN = '-36px';

export const defaultStyle = {
    transition: `opacity ${TRANSITION_DURATION} var(--p-motion-ease)`,
    opacity: 0,
};

export const transitionStyles = {
    entering: { opacity: 1 },
    entered: { opacity: 1 },
    exiting: { opacity: 0 },
    exited: { opacity: 0 },
    unmounted: { opacity: 0 },
};

export const defaultFilterStyles = {
    transition: `opacity ${TRANSITION_DURATION} var(--p-motion-ease), margin ${TRANSITION_DURATION} var(--p-motion-ease)`,
    opacity: 0,
    marginTop: TRANSITION_MARGIN,
};

export const transitionFilterStyles = {
    entering: {
        opacity: 1,
        marginTop: 0,
    },
    entered: {
        opacity: 1,
        marginTop: 0,
    },
    exiting: {
        opacity: 0,
        marginTop: TRANSITION_MARGIN,
    },
    exited: {
        opacity: 0,
        marginTop: TRANSITION_MARGIN,
    },
    unmounted: {
        opacity: 0,
        marginTop: TRANSITION_MARGIN,
    },
};

export interface FiltersProps {
    /** Currently entered text in the query field */
    queryValue?: string;
    /** Placeholder text for the query field. */
    queryPlaceholder?: string;
    /** Whether the query field is focused. */
    focused?: boolean;
    /** Available filters added to the filter bar. Shortcut filters are pinned to the front of the bar. */
    filters: FilterInterface[];
    /** Applied filters which are rendered as filter pills. The remove callback is called with the respective key. */
    appliedFilters?: AppliedFilterInterface[];
    /** Callback when the query field is changed. */
    onQueryChange: (queryValue: string) => void;
    /** Callback when the clear button is triggered. */
    onQueryClear: () => void;
    /** Callback when the reset all button is pressed. */
    onClearAll: () => void;
    /** Callback when the query field is blurred. */
    onQueryBlur?: () => void;
    /** Callback when the query field is focused. */
    onQueryFocus?: () => void;
    /** The content to display inline with the controls. */
    children?: Snippet;
    /** Disable all filters. */
    disabled?: boolean;
    /** Hide filter bar for applied filters. */
    hideFilters?: boolean;
    /** Hide the query field. */
    hideQueryField?: boolean;
    /** Disable the query field. */
    disableQueryField?: boolean;
    /** Disable the filters */
    disableFilters?: boolean;
    /** Whether the text field should be borderless. Should be true when used as part of the IndexFilters component. */
    borderlessQueryField?: boolean;
    /** Whether an asyncronous task is currently being run. */
    loading?: boolean;
    mountedState?: TransitionStatus;
    /** Callback when the add filter button is clicked. */
    onAddFilterClick?: () => void;
    /** Whether the filter should close when clicking inside another Popover. */
    closeOnChildOverlayClick?: boolean;
    /** @deprecated The name of the currently selected view */
    selectedViewName?: string;
}
```

# components/form-layout/components/group/form-layout-group.svelte

```svelte
<script lang="ts">
	import BlockStack from '$lib/components/block-stack/block-stack.svelte';
	import Box from '$lib/components/box/box.svelte';
	import InlineStack from '$lib/components/inline-stack/inline-stack.svelte';
	import Text from '$lib/components/text/text.svelte';
	import type { GroupProps } from '../../types.js';

	const id = $props.id();
	let helpTextElement = null;
	let titleElement = null;
	let helpTextId: undefined | string = $derived(`${id}-help-text`);
	let titleId: undefined | string = $derived(`${id}-title`);

	let { children, condensed, title, helpText }: GroupProps = $props();
</script>

{#snippet helpTextMarkup()}
	{#if helpText}
		<Box id={helpTextId} color="text-secondary">
			{#if typeof helpText === 'string'}
				{helpText}
			{:else}
				{@render helpText()}
			{/if}
		</Box>
	{/if}
{/snippet}

{#snippet titleMarkup()}
	{#if title}
		<Text as="p" id={titleId}>
			{title}
		</Text>
	{/if}
{/snippet}

<BlockStack role="group" gap="200">
	{@render titleMarkup()}
	<InlineStack gap="300">{@render children?.()}</InlineStack>
	{@render helpTextMarkup()}
</BlockStack>

```

# components/form-layout/components/item/form-layout-item.svelte

```svelte
<script lang="ts">
	import { classNames } from '$utilities/css.js';
	import styles from '../../form-layout.module.css';
	import type { ItemProps } from '../../types.js';
	let { children, condensed }: ItemProps = $props();

	const className = $derived(classNames(styles.Item, condensed ? styles.condensed : styles.grouped));
</script>

<div class={className}>
    {@render children?.()}
</div>

```

# components/form-layout/form-layout.module.css

```css
.Item {
    /* stylelint-disable-next-line -- Polaris component custom properties */
    --pc-form-layout-item-min-size: 220px;
    flex: 1 1 0;

    &.grouped {
        /* stylelint-disable-next-line -- Polaris component custom properties */
        min-width: var(--pc-form-layout-item-min-size);

        @media (--p-breakpoints-xs-only) {
            min-width: 100%;
        }
    }

    &.condensed {
        /* stylelint-disable-next-line -- Polaris component custom properties */
        flex-basis: calc(0.5 * var(--pc-form-layout-item-min-size));
        /* stylelint-disable-next-line -- Polaris component custom properties */
        min-width: calc(0.5 * var(--pc-form-layout-item-min-size));
    }
}
```

# components/form-layout/form-layout.svelte

```svelte
<script lang='ts'>
    import BlockStack from '$lib/components/block-stack/block-stack.svelte';
    import type { FormLayoutProps } from './types.js';
    let { children }: FormLayoutProps = $props();
</script>

<BlockStack gap="400">
    {@render children?.()}
</BlockStack>

```

# components/form-layout/types.ts

```ts
import type { Snippet } from "svelte";
import FormLayoutGroupComponent from "./components/group/form-layout-group.svelte";
import FormLayoutItemComponent from "./components/item/form-layout-item.svelte";
import FormLayoutComponent from "./form-layout.svelte";

export interface FormLayoutProps {
    /** The content to display inside the layout. */
    children?: Snippet;
}

export interface GroupProps {
    children?: Snippet;
    condensed?: boolean;
    title?: string;
    helpText?: string | Snippet;
}

export interface ItemProps {
    children?: Snippet;
    condensed?: boolean;
}

/* export const FormLayout = {
    Group: FormLayoutGroup,
    Item: FormLayoutItem
} */

type FormLayoutCompoundComponent = typeof FormLayoutComponent & {
    Group: typeof FormLayoutGroupComponent;
    Item: typeof FormLayoutItemComponent;
};

const FormLayout = FormLayoutComponent as FormLayoutCompoundComponent;
FormLayout.Group = FormLayoutGroupComponent;
FormLayout.Item = FormLayoutItemComponent;

export default FormLayout;
```

# components/form/form.svelte

```svelte
<script lang="ts">
	import type { FormProps } from './types.js';
	import Text from '../text/text.svelte';

	let {
		acceptCharset,
		action,
		autoComplete,
		children,
		encType,
		implicitSubmit = true,
		method = 'post',
		name,
		noValidate,
		preventDefault = true,
		target,
		onSubmit
	}: FormProps = $props();

	function normalizeAutoComplete(autoComplete?: boolean) {
		if (autoComplete == null) {
			return autoComplete;
		}

		return autoComplete ? 'on' : 'off';
	}

	const autoCompleteInputs = normalizeAutoComplete(autoComplete);

	const handleSubmit = (event: SubmitEvent) => {
		if (!preventDefault) {
			return;
		}

		event.preventDefault();
		onSubmit(event);
	};
</script>

<form
	acceptcharset={acceptCharset}
	enctype={encType}
	{action}
	autoComplete={autoCompleteInputs}
	{method}
	{name}
	novalidate={noValidate}
	{target}
	onsubmit={handleSubmit}
>
	{#if implicitSubmit}
		<Text as="span" visuallyHidden>
			<button type="submit" aria-hidden="true" tabIndex={-1}> Submit </button>
		</Text>
	{/if}
	{children}
</form>

```

# components/form/types.ts

```ts
import type { Snippet } from "svelte";

type Enctype =
    | 'application/x-www-form-urlencoded'
    | 'multipart/form-data'
    | 'text/plain';

//type Method = 'post' | 'get' | 'action';
type Method = 'post' | 'get';

type Target = '_blank' | '_self' | '_parent' | '_top' | string;

export interface FormProps {
    /** Space separated list of character encodings */
    acceptCharset?: string;
    /** Where to send form-data on submittal */
    action?: string;
    /** Grants the browser the ability to autocomplete input elements */
    autoComplete?: boolean;
    /** The content to display inside the form. */
    children?: Snippet;
    /** Media type when submitting content to server */
    encType?: Enctype;
    /** Toggles if form submits on Enter keypress. Defaults to true. */
    implicitSubmit?: boolean;
    /** Method used to submit form */
    method?: Method;
    /** A unique name for the form */
    name?: string;
    /** Whether or not form is validated when submitting */
    noValidate?: boolean;
    /** Blocks the default form action */
    preventDefault?: boolean;
    /** Where to display response after form submittal */
    target?: Target;
    /** Callback when form is submitted */
    onSubmit(event: SubmitEvent): unknown;
}
```

# components/grid/components/grid-cell/grid-cell.module.css

```css
.Cell {
    /* Remap custom properties as mobile first fallbacks for grid-row and grid-column */
    /* stylelint-disable -- Polaris component custom properties */
    --pc-row-xs: initial;
    --pc-row-sm: var(--pc-row-xs);
    --pc-row-md: var(--pc-row-sm);
    --pc-row-lg: var(--pc-row-md);
    --pc-row-xl: var(--pc-row-lg);
    --pc-column-xs: initial;
    --pc-column-sm: var(--pc-column-xs);
    --pc-column-md: var(--pc-column-sm);
    --pc-column-lg: var(--pc-column-md);
    --pc-column-xl: var(--pc-column-lg);
    /* stylelint-enable */
    min-width: 0;
    /* stylelint-disable-next-line -- generated by polaris-migrator DO NOT COPY */
    grid-row: var(--pc-row-xs);
    /* stylelint-disable-next-line -- generated by polaris-migrator DO NOT COPY */
    grid-column: var(--pc-column-xs);

    @media (--p-breakpoints-sm-up) {
        /* stylelint-disable-next-line -- generated by polaris-migrator DO NOT COPY */
        grid-row: var(--pc-row-sm);
        /* stylelint-disable-next-line -- generated by polaris-migrator DO NOT COPY */
        grid-column: var(--pc-column-sm);
    }

    @media (--p-breakpoints-md-up) {
        /* stylelint-disable-next-line -- generated by polaris-migrator DO NOT COPY */
        grid-row: var(--pc-row-md);
        /* stylelint-disable-next-line -- generated by polaris-migrator DO NOT COPY */
        grid-column: var(--pc-column-md);
    }

    @media (--p-breakpoints-lg-up) {
        /* stylelint-disable-next-line -- generated by polaris-migrator DO NOT COPY */
        grid-row: var(--pc-row-lg);
        /* stylelint-disable-next-line -- generated by polaris-migrator DO NOT COPY */
        grid-column: var(--pc-column-lg);
    }

    @media (--p-breakpoints-xl-up) {
        /* stylelint-disable-next-line -- generated by polaris-migrator DO NOT COPY */
        grid-row: var(--pc-row-xl);
        /* stylelint-disable-next-line -- generated by polaris-migrator DO NOT COPY */
        grid-column: var(--pc-column-xl);
    }
}

@mixin responsive-grid-cells;
```

# components/grid/components/grid-cell/grid-cell.svelte

```svelte
<script lang="ts">
	import { applyStyles, classNames } from '$utilities/css.js';
	import type { CellProps } from '../../types.js';
	import styles from './grid-cell.module.css';
	let { area: gridArea, column, columnSpan, row, children }: CellProps = $props();

	const className = $derived(classNames(
		styles.Cell,
		columnSpan?.xs && styles[`Cell-${columnSpan.xs}-column-xs`],
		columnSpan?.sm && styles[`Cell-${columnSpan.sm}-column-sm`],
		columnSpan?.md && styles[`Cell-${columnSpan.md}-column-md`],
		columnSpan?.lg && styles[`Cell-${columnSpan.lg}-column-lg`],
		columnSpan?.xl && styles[`Cell-${columnSpan.xl}-column-xl`]
	));

	const style = $derived({
		gridArea,
		'--pc-column-xs': column?.xs,
		'--pc-column-sm': column?.sm,
		'--pc-column-md': column?.md,
		'--pc-column-lg': column?.lg,
		'--pc-column-xl': column?.xl,
		'--pc-row-xs': row?.xs,
		'--pc-row-sm': row?.sm,
		'--pc-row-md': row?.md,
		'--pc-row-lg': row?.lg,
		'--pc-row-xl': row?.xl
	});
</script>

<div class={className} style={applyStyles(style)}>
    {@render children?.()}
</div>

```

# components/grid/grid.module.css

```css
.Grid {
  /* Remap custom properties as mobile first fallbacks for grid-template-areas and grid-template-columns */
  /* stylelint-disable -- Polaris component custom properties */
  --pc-grid-areas-xs: initial;
  --pc-grid-areas-sm: var(--pc-grid-areas-xs);
  --pc-grid-areas-md: var(--pc-grid-areas-sm);
  --pc-grid-areas-lg: var(--pc-grid-areas-md);
  --pc-grid-areas-xl: var(--pc-grid-areas-lg);
  --pc-grid-columns-xs: 6;
  --pc-grid-columns-sm: var(--pc-grid-columns-xs);
  --pc-grid-columns-md: var(--pc-grid-columns-sm);
  --pc-grid-columns-lg: 12;
  --pc-grid-columns-xl: var(--pc-grid-columns-lg);
  /* stylelint-enable */
  display: grid;
  /* stylelint-disable-next-line -- generated by polaris-migrator DO NOT COPY */
  gap: var(--pc-grid-gap-xs, var(--p-space-400));
  /* stylelint-disable-next-line -- generated by polaris-migrator DO NOT COPY */
  grid-template-areas: var(--pc-grid-areas-xs);
  /* stylelint-disable-next-line -- generated by polaris-migrator DO NOT COPY */
  grid-template-columns: repeat(var(--pc-grid-columns-xs), minmax(0, 1fr));

  @media (--p-breakpoints-sm-up) {
    /* stylelint-disable-next-line -- generated by polaris-migrator DO NOT COPY */
    gap: var(--pc-grid-gap-sm, var(--p-space-400));
    /* stylelint-disable-next-line -- generated by polaris-migrator DO NOT COPY */
    grid-template-areas: var(--pc-grid-areas-sm);
    /* stylelint-disable-next-line -- generated by polaris-migrator DO NOT COPY */
    grid-template-columns: repeat(var(--pc-grid-columns-sm), minmax(0, 1fr));
  }

  @media (--p-breakpoints-md-up) {
    /* stylelint-disable-next-line -- generated by polaris-migrator DO NOT COPY */
    gap: var(--pc-grid-gap-md, var(--p-space-400));
    /* stylelint-disable-next-line -- generated by polaris-migrator DO NOT COPY */
    grid-template-areas: var(--pc-grid-areas-md);
    /* stylelint-disable-next-line -- generated by polaris-migrator DO NOT COPY */
    grid-template-columns: repeat(var(--pc-grid-columns-md), minmax(0, 1fr));
  }

  @media (--p-breakpoints-lg-up) {
    /* stylelint-disable-next-line -- generated by polaris-migrator DO NOT COPY */
    gap: var(--pc-grid-gap-lg, var(--p-space-400));
    /* stylelint-disable-next-line -- generated by polaris-migrator DO NOT COPY */
    grid-template-areas: var(--pc-grid-areas-lg);
    /* stylelint-disable-next-line -- generated by polaris-migrator DO NOT COPY */
    grid-template-columns: repeat(var(--pc-grid-columns-lg), minmax(0, 1fr));
  }

  @media (--p-breakpoints-xl-up) {
    /* stylelint-disable-next-line -- generated by polaris-migrator DO NOT COPY */
    gap: var(--pc-grid-gap-xl, var(--p-space-400));
    /* stylelint-disable-next-line -- generated by polaris-migrator DO NOT COPY */
    grid-template-areas: var(--pc-grid-areas-xl);
    /* stylelint-disable-next-line -- generated by polaris-migrator DO NOT COPY */
    grid-template-columns: repeat(var(--pc-grid-columns-xl), minmax(0, 1fr));
  }
}
```

# components/grid/grid.svelte

```svelte
<script lang="ts">
	import { applyStyles } from '$utilities/css.js';
	import styles from './grid.module.css';
	import type { GridProps } from './types.js';
	let { gap, areas, children, columns }: GridProps = $props();

	function formatAreas(areas?: string[]) {
		if (!areas) return;
		return `'${areas?.join(`' '`)}'`;
	}

	const style = $derived({
		'--pc-grid-gap-xs': gap?.xs,
		'--pc-grid-gap-sm': gap?.sm,
		'--pc-grid-gap-md': gap?.md,
		'--pc-grid-gap-lg': gap?.lg,
		'--pc-grid-gap-xl': gap?.xl,
		'--pc-grid-columns-xs': columns?.xs,
		'--pc-grid-columns-sm': columns?.sm,
		'--pc-grid-columns-md': columns?.md,
		'--pc-grid-columns-lg': columns?.lg,
		'--pc-grid-columns-xl': columns?.xl,
		'--pc-grid-areas-xs': formatAreas(areas?.xs),
		'--pc-grid-areas-sm': formatAreas(areas?.sm),
		'--pc-grid-areas-md': formatAreas(areas?.md),
		'--pc-grid-areas-lg': formatAreas(areas?.lg),
		'--pc-grid-areas-xl': formatAreas(areas?.xl)
	});
</script>

<div class={styles.Grid} style={applyStyles(style)}>
	{@render children?.()}
</div>

```

# components/grid/index.ts

```ts
import GridComponent from "./grid.svelte";
import GridCellComponent from "./components/grid-cell/grid-cell.svelte";

type GridCompoundComponent = typeof GridComponent & {
    Cell: typeof GridCellComponent;
};

const Grid = GridComponent as GridCompoundComponent;
Grid.Cell = GridCellComponent;
export default Grid;
```

# components/grid/types.ts

```ts
import type { Snippet } from "svelte";

type Breakpoints = 'xs' | 'sm' | 'md' | 'lg' | 'xl';

type Cell = {
  [Breakpoint in Breakpoints]?: string;
};

interface Columns {
  /** Number of columns the section should span on extra small screens */
  xs?: 1 | 2 | 3 | 4 | 5 | 6;
  /** Number of columns the section should span on small screens */
  sm?: 1 | 2 | 3 | 4 | 5 | 6;
  /** Number of columns the section should span on medium screens */
  md?: 1 | 2 | 3 | 4 | 5 | 6;
  /** Number of columns the section should span on large screens */
  lg?: 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12;
  /** Number of columns the section should span on extra large screens */
  xl?: 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12;
}

export interface CellProps {
  /**
   * Set grid-template-areas
   * @deprecated To avoid a11y issues, nest layout components in individual grid
   * cells instead. See:
   * https://polaris.shopify.com/components/layout-and-structure
   */
  area?: string;
  column?: Cell;
  columnSpan?: Columns;
  row?: Cell;
  children?: Snippet;
}

type Areas = {
  [Breakpoint in Breakpoints]?: string[];
};

type GridColumns = {
  [Breakpoint in Breakpoints]?: number;
};

type Gap = {
  [Breakpoint in Breakpoints]?: string;
};

export interface GridProps {
  /**
   * Set grid-template-areas
   * @deprecated To avoid a11y issues, nest layout components in individual grid
   * cells instead. See:
   * https://polaris.shopify.com/components/layout-and-structure
   */
  areas?: Areas;
  /* Number of columns */
  columns?: GridColumns;
  /* Grid gap */
  gap?: Gap;
  children?: Snippet;
}
```

# components/icon/icon.module.css

```css
.Icon {
    display: block;
    height: 20px;
    width: 20px;

    max-height: 100%;
    max-width: 100%;
    margin: auto;
}

.Icon svg {
    fill: currentColor;
}

.toneInherit svg {
    color: inherit;
}

.toneBase svg {
    color: var(--p-color-icon);
}

.toneSubdued svg {
    color: var(--p-color-icon-secondary);
}

.toneCaution svg {
    color: var(--p-color-icon-caution);
}

.toneWarning svg {
    color: var(--p-color-icon-warning);
}

.toneCritical svg {
    color: var(--p-color-icon-critical);
}

.toneInteractive svg {
    color: var(--p-color-icon-emphasis);
}

.toneInfo svg {
    color: var(--p-color-icon-info);
}

.toneSuccess svg {
    color: var(--p-color-icon-success);
}

.tonePrimary svg {
    color: var(--p-color-icon-brand);
}

.toneEmphasis svg {
    color: var(--p-color-icon-emphasis);
}

.toneMagic svg {
    color: var(--p-color-icon-magic);
}

.toneTextCaution svg {
    color: var(--p-color-text-caution);
}

.toneTextWarning svg {
    color: var(--p-color-text-warning);
}

.toneTextCritical svg {
    color: var(--p-color-text-critical);
}

.toneTextInfo svg {
    color: var(--p-color-text-info);
}

.toneTextPrimary svg {
    color: var(--p-color-text-brand);
}

.toneTextSuccess svg {
    color: var(--p-color-text-success);
}

.toneTextMagic svg {
    color: var(--p-color-text-magic);
}

.Svg,
.Img {
    position: relative;
    display: block;
    width: 100%;
    max-width: 100%;
    max-height: 100%;
}

.Placeholder {
    /* stylelint-disable-next-line -- generated by polaris-migrator DO NOT COPY */
    padding-bottom: 100%;
    background: var(--p-color-bg-fill-tertiary);
    border-radius: var(--p-border-radius-100);
}
```

# components/icon/icon.svelte

```svelte
<script lang='ts'>
	import { UseBreakpoints } from "$lib/use/use-breakpoints.svelte.js";
	import { classNames, variationName } from "$utilities/css.js";
	import Text from "../text/text.svelte";
    import styles from './icon.module.css';
    import type { IconProps } from './types.ts';
    let { source, tone, accessibilityLabel }: IconProps = $props();

    const className = $derived(
        classNames(
            styles.Icon,
            tone && styles[variationName('tone', tone)],
        )
    );

    const bp = new UseBreakpoints()
    let breakpoints = $derived(bp.getCurrentBreakpoints());
    const mdDown = $derived(breakpoints?.mdDown);
</script>

<span class={className}>
    {#if accessibilityLabel}
        <Text as="span" visuallyHidden>
            {accessibilityLabel}
        </Text>
    {/if}

    <!--svelte-ignore svelte_component_deprecated -->
    <svelte:component this={source} class={styles.Svg} focusable="false" aria-hidden="true" {...(mdDown ? {viewBox: '1 1 18 18'} : {})} />
</span>
```

# components/icon/types.ts

```ts
import type { IconSource } from "$utilities/types.js";

type Tone =
    | 'base'
    | 'inherit'
    | 'subdued'
    | 'caution'
    | 'warning'
    | 'critical'
    | 'interactive'
    | 'info'
    | 'success'
    | 'primary'
    | 'emphasis'
    | 'magic'
    | 'textCaution'
    | 'textWarning'
    | 'textCritical'
    | 'textInfo'
    | 'textSuccess'
    | 'textPrimary'
    | 'textMagic';

export interface IconProps {
    /** The SVG contents to display in the icon (icons should fit in a 20 Ã— 20 pixel viewBox) */
    source: IconSource;
    /** Set the color for the SVG fill */
    tone?: Tone;
    /** Descriptive text to be read to screenreaders */
    accessibilityLabel?: string;
}
```

# components/image/image.svelte

```svelte
<script lang="ts">
	import type { ImageProps } from './types.js';

	let { alt, sourceSet, source, crossOrigin, ref, onLoad, className, ...rest }: ImageProps = $props();

	const finalSourceSet = $derived(
		sourceSet
			? sourceSet.map(({ source: subSource, descriptor }) => `${subSource} ${descriptor}`).join(',')
			: null
	);
</script>

<img
	{alt}
	bind:this={ref}
	src={source}
	crossorigin={crossOrigin}
	class={className}
	onload={onLoad}
	{...finalSourceSet ? { srcset: finalSourceSet } : {}}
	{...rest}
/>

```

# components/image/types.ts

```ts
import type { HTMLImgAttributes } from 'svelte/elements';
interface SourceSet {
    source: string;
    descriptor?: string;
}

type CrossOrigin = 'anonymous' | 'use-credentials' | '' | undefined;

export interface ImageProps extends HTMLImgAttributes {
    alt: string;
    source: string;
    crossOrigin?: CrossOrigin;
    sourceSet?: SourceSet[];
    className?: string;
    onLoad?(): void;
    onError?(): void;
    ref?: HTMLImageElement;
}
```

# components/index-provider/index-provider.svelte

```svelte
<script lang="ts">
	import type { Snippet } from 'svelte';
	import IndexContextProvider from '../app-provider/index-context-provider.svelte';
	import IndexSelectionChangeContextProvider from '../app-provider/index-selection-change-context-provider.svelte';
	import IndexRowContextProvider from '../app-provider/index-row-context-provider.svelte';
	import type { IndexProviderProps } from '$utilities/index-provider/types.js';
	import { useBulkSelectionData } from '$utilities/index-provider/hooks.js';
	import { HandleBulkSelection } from '$lib/use/use-bulk-selection.svelte.js';

	let {
		children,
		resourceName: passedResourceName,
		loading,
		onSelectionChange,
		selectedItemsCount = 0,
		itemCount,
		hasMoreItems,
		condensed,
		selectable: isSelectableIndex = true,
		paginatedSelectAllText: defaultPaginatedSelectAllText
	}: IndexProviderProps = $props();

	const {
		paginatedSelectAllText,
		bulkActionsLabel,
		bulkActionsAccessibilityLabel,
		resourceName,
		selectMode,
		bulkSelectState
	} = $derived(useBulkSelectionData({
		selectedItemsCount,
		itemCount,
		hasMoreItems,
		resourceName: passedResourceName,
		defaultPaginatedSelectAllText
	}));

	const handleSelection = new HandleBulkSelection({ onSelectionChange });

	const contextValue = $derived({
		itemCount,
		selectMode: selectMode && isSelectableIndex,
		selectable: isSelectableIndex,
		resourceName,
		loading,
		paginatedSelectAllText,
		hasMoreItems,
		bulkActionsLabel,
		bulkActionsAccessibilityLabel,
		bulkSelectState,
		selectedItemsCount,
		condensed
	});

	const rowContextValue = $derived({
		selectable: isSelectableIndex,
		selectMode: selectMode && isSelectableIndex,
		condensed,
	});
</script>

<IndexContextProvider value={contextValue}>
	<IndexRowContextProvider value={rowContextValue}>
		<IndexSelectionChangeContextProvider value={handleSelection.handleSelectionChange}>
			{@render children?.()}
		</IndexSelectionChangeContextProvider>
	</IndexRowContextProvider>
</IndexContextProvider>

```

# components/index-table/components/cell/cell.svelte

```svelte
<script lang="ts">
	import { classNames } from '$utilities/css.js';
	import styles from '../../index-table.module.css';
	import type { CellProps } from './types.js';
	let {
		children,
		className: customClassName,
		flush,
		colSpan,
		headers,
		scope,
		as = 'td',
		id
	}: CellProps = $props();

	const className = $derived(
		classNames(customClassName, styles.TableCell, flush && styles['TableCell-flush'])
	);
</script>

<svelte:element this={as} {id} colspan={colSpan} {headers} {scope} class={className}>
	{@render children?.()}
</svelte:element>

```

# components/index-table/components/cell/types.ts

```ts
import type { Snippet } from "svelte";

export interface CellProps {
    /** The table cell element to render. Render the cell as a `th` if it serves as a subheading
     * @default 'td'
     */
    as?: 'th' | 'td';
    /** The unique ID to set on the cell element */
    id?: string;
    /** The cell contents */
    children?: Snippet;
    /** Custom class name to apply to the cell element */
    className?: string;
    /** Whether the cell padding should be removed
     * @default false
     */
    flush?: boolean;
    /** For subheader cells -- The number of the columns that the cell element should extend to */
    colSpan?: HTMLTableCellElement['colSpan'];
    /**  For subheader cells -- Indicates the cells that the `th` element relates to */
    scope?: "col" | "colgroup" | "row" | "rowgroup" | null | undefined;
    /** A space-separated list of the `th` cell IDs that describe or apply to it. Use for cells within a row that relate to a subheader cell in addition to their column header. */
    headers?: HTMLTableCellElement['headers'];
}
```

# components/index-table/components/checkbox/checkbox-wrapper.svelte

```svelte
<script lang="ts">
	import { useContext } from '$utilities/contexts.js';
	import { onDestroy, onMount, type Snippet } from 'svelte';
	import { ROW_CONTEXT_KEY } from '$utilities/index-table/context.js';
	import type { RowContextType } from '$utilities/index-table/context.js';
	import { debounce } from '$utilities/debounce.js';
	import { setRootProperty } from '$utilities/set-root-property.js';
	import { classNames } from '$utilities/css.js';
	import sharedStyles from '../../index-table.module.css';
	import { browser } from '$app/environment';

	let { children }: { children: Snippet } = $props();
	const rowContext = useContext<RowContextType>(ROW_CONTEXT_KEY);
	const { position } = $derived(rowContext());
	let checkboxNode = $state<HTMLTableDataCellElement | null>(null);

	const handleResize = debounce(() => {
		if (position !== 0 || !checkboxNode) return;

		const { width } = checkboxNode.getBoundingClientRect();
		setRootProperty('--pc-checkbox-offset', `${width}px`);
	});

	onMount(() => {
		if (!browser) return;
		handleResize();
		window?.addEventListener('resize', handleResize);
	});

	onDestroy(() => {
		if (!browser) return;
		window?.removeEventListener('resize', handleResize);
	});

	const checkboxClassName = $derived(
		classNames(sharedStyles.TableCell, sharedStyles['TableCell-first'])
	);
</script>

<td class={checkboxClassName} bind:this={checkboxNode}>
	{@render children?.()}
</td>

```

# components/index-table/components/checkbox/checkbox.module.css

```css
.container {
  /* Add your styles for checkbox here */
}
```

# components/index-table/components/checkbox/checkbox.svelte

```svelte
<script lang="ts">
	import styles from './checkbox.module.css';
	import type { CheckboxProps } from './types.js';
	import { useContext } from '$utilities/contexts.js';
	import { ROW_CONTEXT_KEY } from '$utilities/index-table/context.js';
	import CheckboxWrapper from './checkbox-wrapper.svelte';
	import { noop } from '$utilities/noop.js';
	import Checkbox from '$lib/components/checkbox/checkbox.svelte';
	import { getContext } from 'svelte';
	import type { IndexContextType } from '$utilities/index-provider/context.js';
	import { INDEX_CONTEXT_KEY } from '$utilities/index-provider/hooks.js';

	let { accessibilityLabel }: CheckboxProps = $props();
	const indexContext = useContext<IndexContextType>(INDEX_CONTEXT_KEY);
	const { resourceName } = $derived(indexContext());

	const rowContext = getContext<Function>(ROW_CONTEXT_KEY);
	const { itemId, selected, disabled, onInteraction } = $derived(rowContext());
	const label = $derived(accessibilityLabel ? accessibilityLabel : `Select ${resourceName}`);
</script>

<CheckboxWrapper>
	<!-- svelte-ignore a11y_no_static_element_interactions -->
	<div class={styles.Wrapper} onclick={onInteraction} onkeyup={noop}>
		<Checkbox id={`Select-${itemId}`} {label} labelHidden checked={selected} {disabled} />
	</div>
</CheckboxWrapper>

```

# components/index-table/components/checkbox/types.ts

```ts
export interface CheckboxProps {
    accessibilityLabel?: string;
}
```

# components/index-table/components/row/row.svelte

```svelte
<script lang="ts">
	import { UseToggle } from '$lib/use/use-toggle.svelte.js';
	import { INDEX_ROW_CONTEXT_KEY, INDEX_SELECTION_CHANGE_CONTEXT_KEY } from '$utilities/index-provider/hooks.js';
	import { SelectionType, type HandleSelectionChange } from '$utilities/index-provider/types.js';
	import styles from '../../index-table.module.css';
	import type { RowProps, TableRowElementType } from './types.js';
	import type { Range } from '../../../../use/use-index-resource-state.svelte.js';
	import { classNames, variationName } from '$utilities/css.js';
	import Cell from '../cell/cell.svelte';
	import Checkbox from '../checkbox/checkbox.svelte';
	import RowContextProvider from '$lib/components/app-provider/row-context-provider.svelte';
	import RowHoveredContextProvider from '$lib/components/app-provider/row-hovered-context-provider.svelte';
	import { useContext } from '$utilities/contexts.js';
	import type { IndexRowContextType } from '$utilities/index-provider/context.js';

	let {
		children,
		hideSelectable,
		selected,
		id,
		position,
		tone,
		disabled,
		selectionRange,
		rowType = 'data',
		accessibilityLabel,
		onNavigation,
		onClick
	}: RowProps = $props();

	const useIndexRow = useContext<IndexRowContextType>(INDEX_ROW_CONTEXT_KEY);
	const { selectable: tableIsSelectable, selectMode, condensed } = $derived(useIndexRow());
	const rowIsSelectable = $derived(tableIsSelectable && !hideSelectable);
	const useIndexSelectionChange = useContext<HandleSelectionChange>(INDEX_SELECTION_CHANGE_CONTEXT_KEY);
	const onSelectionChange = $derived(useIndexSelectionChange());

	let hovered = new UseToggle(false);
	const setHoverIn = hovered.setTrue;
	const setHoverOut = hovered.setFalse;

	const handleInteraction = (event: MouseEvent | KeyboardEvent) => {
		event.stopPropagation();
		let selectionType = SelectionType.Single;

		if (disabled || !rowIsSelectable || ('key' in event && event.key !== ' ') || !onSelectionChange)
			return;

		if (event.shiftKey) {
			selectionType = SelectionType.Multi;
		} else if (selectionRange) {
			selectionType = SelectionType.Range;
		}

		const selection: string | Range = selectionRange ?? id;
		onSelectionChange(selectionType, !selected, selection, position);
	};

	const contextValue = $derived({
		itemId: id,
		selected,
		position,
		onInteraction: handleInteraction,
		disabled
	});

	let primaryLinkElement = $state<HTMLAnchorElement | null>(null);
	let isNavigating = $state<boolean>(false);
	let tableRowRef = $state<TableRowElementType | null>(null);

	let tableRowCallbackRef = (node: TableRowElementType) => {
		tableRowRef = node;

		const el = node?.querySelector('[data-primary-link]');

		if (el) {
			primaryLinkElement = el as HTMLAnchorElement;
		}
	};

	const rowClassName = $derived(
		classNames(
			styles.TableRow,
			rowType === 'subheader' && styles['TableRow-subheader'],
			rowType === 'child' && styles['TableRow-child'],
			rowIsSelectable && condensed && styles.condensedRow,
			selected && styles['TableRow-selected'],
			hovered && !condensed && styles['TableRow-hovered'],
			disabled && styles['TableRow-disabled'],
			tone && styles[variationName('tone', tone)],
			!rowIsSelectable && !onClick && !primaryLinkElement && styles['TableRow-unclickable']
		)
	);

	const RowWrapper = $derived(condensed ? 'li' : 'tr');

	const handleRowClick = (event: MouseEvent) => {
		if ((!disabled && rowIsSelectable) || onClick || primaryLinkElement) {
			if (rowType === 'subheader') return;

			if (!tableRowRef || isNavigating) {
				return;
			}
			event.stopPropagation();
			event.preventDefault();

			if (onClick) {
				onClick();
				return;
			}

			if (primaryLinkElement && !selectMode) {
				isNavigating = true;
				const { ctrlKey, metaKey } = event;

				if (onNavigation) {
					onNavigation(id);
				}

				if ((ctrlKey || metaKey) && primaryLinkElement instanceof HTMLAnchorElement) {
					isNavigating = false;
					window.open(primaryLinkElement.href, '_blank');
					return;
				}

				primaryLinkElement.dispatchEvent(new MouseEvent(event.type, event));
			} else {
				isNavigating = false;
				handleInteraction(event);
			}
		}
	};
</script>

{#snippet checkboxMarkup()}
	{#if hideSelectable}
		<Cell />
	{:else}
		<Checkbox {accessibilityLabel} />
	{/if}
{/snippet}

<RowContextProvider value={contextValue}>
	<RowHoveredContextProvider value={hovered.value}>
		<svelte:element
			this={RowWrapper}
			{id}
			use:tableRowCallbackRef
			class={rowClassName}
			onmouseenter={setHoverIn}
			onmouseleave={setHoverOut}
			onclick={handleRowClick}
			role="row"
			tabindex={rowIsSelectable ? 0 : undefined}
		>
			{#if tableIsSelectable}
				{@render checkboxMarkup?.()}
			{/if}
			{@render children?.()}
		</svelte:element>
	</RowHoveredContextProvider>
</RowContextProvider>

```

# components/index-table/components/row/types.ts

```ts
import type { Snippet } from "svelte";
import type { Range } from '../../../../use/use-index-resource-state.svelte.js';

export type RowType = 'data' | 'subheader' | 'child';
export type RowStatus = 'subdued' | 'success' | 'warning' | 'critical';
export type TableRowElementType = HTMLTableRowElement & HTMLLIElement;

export interface RowProps {
    /** Table header or data cells */
    children: Snippet;
    /** A unique identifier for the row */
    id: string;
    /** Whether the row should hide the selectable checkbox while the parent IndexTable is selectable */
    hideSelectable?: boolean;
    /** Whether the row is selected */
    selected?: boolean;
    /** The zero-indexed position of the row. Used for Shift key multi-selection */
    position: number;
    /** Whether the row should visually indicate its status with a background color */
    tone?: RowStatus;
    /** Whether the row should be disabled */
    disabled?: boolean;
    /** A tuple array with the first and last index of the range of other rows that this row describes. All rows in the range are selected when the selection range row is selected. */
    selectionRange?: Range;
    /**
     * Indicates the relationship or role of the row's contents. A "subheader" row displays the same as the table header. Rows of type "child" are indented.
     *  @default 'data' */
    rowType?: RowType;
    /** Label set on the row's checkbox
     * @default "Select {resourceName}"
     */
    accessibilityLabel?: string;
    /** Callback fired when the row is clicked and contains a data-primary-link */
    onNavigation?(id: string): void;
    /** Callback fired when the row is clicked. Overrides the default click behaviour. */
    onClick?(): void;
}

```

# components/index-table/components/scrollcontainer/scrollcontainer.module.css

```css
.ScrollContainer {
  overflow-x: auto;
  overscroll-behavior-x: contain;
  -ms-overflow-style: none;
  scrollbar-width: none;
  border-radius: inherit;
}

.ScrollContainer::-webkit-scrollbar {
  display: none;
}
```

# components/index-table/components/scrollcontainer/scrollcontainer.svelte

```svelte
<script lang="ts">
	import ScrollContextProvider from '$lib/components/app-provider/scroll-context-provider.svelte';
	import { debounce } from '$utilities/debounce.js';
	import { scrollDefaultContext, type ScrollContextType } from '$utilities/index-table/context.js';
	import styles from './scrollcontainer.module.css';
	import type { ScrollContainerProps } from './types.js';

	let { children, scrollableContainerRef = $bindable(), onScroll }: ScrollContainerProps = $props();

	$effect(() => {
		if (!scrollableContainerRef) return;
		scrollableContainerRef.dispatchEvent(new Event('scroll'));
	});

	let containerScroll = $state<ScrollContextType>(scrollDefaultContext);
	const handleScroll = debounce(
		() => {
			if (!scrollableContainerRef) {
				return;
			}

			const availableScrollAmount =
				scrollableContainerRef.scrollWidth - scrollableContainerRef.offsetWidth;

			const canScrollLeft = scrollableContainerRef.scrollLeft > 0;
			const canScrollRight = scrollableContainerRef.scrollLeft < availableScrollAmount;
			onScroll(canScrollLeft, canScrollRight);
			containerScroll = {
				scrollableContainer: scrollableContainerRef,
				canScrollLeft,
				canScrollRight
			};
		},
		40,
		{ trailing: true, leading: true, maxWait: 40 }
	);
</script>

<ScrollContextProvider value={containerScroll}>
	<div class={styles.ScrollContainer} bind:this={scrollableContainerRef} onscroll={handleScroll}>
		{@render children?.()}
	</div>
</ScrollContextProvider>

```

# components/index-table/components/scrollcontainer/types.ts

```ts
import type { Snippet } from 'svelte';

export interface ScrollContainerProps {
    children: Snippet;
    scrollableContainerRef: HTMLDivElement | undefined;
    onScroll(canScrollLeft: boolean, canScrollRight: boolean): void;
}
```

# components/index-table/index-table-base.svelte

```svelte
<script lang="ts">
	import { UseToggle } from '$lib/use/use-toggle.svelte.js';
	import { classNames } from '$utilities/css.js';
	import { debounce } from '$utilities/debounce.js';
	import {
		INDEX_CONTEXT_KEY,
		INDEX_SELECTION_CHANGE_CONTEXT_KEY
	} from '$utilities/index-provider/hooks.js';
	import {
		SELECT_ALL_ITEMS,
		SelectionType,
		type HandleSelectionChange
	} from '$utilities/index-provider/types.js';
	import styles from './index-table.module.css';
	import {
		SCROLL_BAR_DEBOUNCE_PERIOD,
		SCROLL_BAR_PADDING,
		type IndexTableBaseProps,
		type TableHeadingRect
	} from './types.js';
	import { getTableHeadingsBySelector } from './utilities/utilities.js';
	import { onMount } from 'svelte';
	import Spinner from '../spinner/spinner.svelte';
	import Sticky from '../sticky/sticky.svelte';
	import BulkActions from '../bulk-actions/bulk-actions.svelte';
	import EmptySearchResult from '../empty-search-result/empty-search-result.svelte';
	import EventListener from '../event-listener/event-listener.svelte';
	import ScrollContainer from './components/scrollcontainer/scrollcontainer.svelte';
	import Pagination from '../pagination/pagination.svelte';
	import RenderHeading from './render-heading.svelte';
	import { useContext } from '$utilities/contexts.js';
	import type { IndexContextType } from '$utilities/index-provider/context.js';
	let {
		headings,
		bulkActions = [],
		promotedBulkActions = [],
		children,
		emptyState,
		sort,
		paginatedSelectAllActionText,
		lastColumnSticky = false,
		sortable,
		sortDirection,
		defaultSortDirection = 'descending',
		sortColumnIndex,
		onSort,
		sortToggleLabels,
		hasZebraStriping,
		pagination,
		isSticky,
		...restProps
	}: IndexTableBaseProps = $props();

	/* const {
		loading,
		bulkSelectState,
		resourceName,
		bulkActionsAccessibilityLabel,
		selectMode,
		selectable = restProps.selectable,
		paginatedSelectAllText,
		itemCount,
		hasMoreItems,
		selectedItemsCount,
		condensed
	} = useIndexValue(); */

	const indexValueContext = useContext<IndexContextType>(INDEX_CONTEXT_KEY);
	const {
		loading,
		bulkSelectState,
		resourceName,
		bulkActionsAccessibilityLabel,
		selectMode,
		selectable = restProps.selectable,
		paginatedSelectAllText,
		itemCount,
		hasMoreItems,
		selectedItemsCount,
		condensed
	} = $derived(indexValueContext());

	//const handleSelectionChange = useIndexSelectionChange();
	const handleSelectionChangeContext = useContext<HandleSelectionChange>(
		INDEX_SELECTION_CHANGE_CONTEXT_KEY
	);
	const handleSelectionChange = $derived(handleSelectionChangeContext());
	const hasMoreLeftColumns = new UseToggle(false);
	const toggleHasMoreLeftColumns = hasMoreLeftColumns.toggle;

	let tablePosition = $state({ top: 0, left: 0 });
	let tableHeadingRects = $state<TableHeadingRect[]>([]);

	let scrollableContainerElement = $state<HTMLDivElement>();
	let tableElement = $state<HTMLTableElement | null>(null);
	let tableBodyElement = $state<Element | null>(null);
	let condensedListElement = $state<HTMLUListElement | null>(null);

	let tableInitialized = $state(false);
	let stickyWrapper = $state<HTMLElement | null>(null);
	let hideScrollContainer = $state<boolean>(true);

	let tableHeadings = $state<HTMLElement[]>([]);
	let stickyTableHeadings = $state<HTMLElement[]>([]);
	let stickyHeaderWrapperElement = $state<HTMLDivElement | null>(null);
	let stickyHeaderElement = $state<HTMLDivElement | null>(null);
	let scrollBarElement = $state<HTMLDivElement | null>(null);
	let scrollContainerElement = $state<HTMLDivElement | null>(null);
	let scrollingWithBar = $state(false);
	let scrollingContainer = $state(false);
	let renderAfterSelectEvent = $state(false);
	let lastSelectedItemsCount = $state<number | 'All'>(0);
	let hasSelected = $state(false);
	let selectedItemsCountValue = $derived(
		selectedItemsCount === SELECT_ALL_ITEMS ? `${itemCount}+` : selectedItemsCount
	);

	function getPaginatedSelectAllAction() {
		if (!selectable || !hasMoreItems) {
			return;
		}

		const customActionText =
			paginatedSelectAllActionText ??
			`Select all ${itemCount}+ ${resourceName.plural.toLocaleLowerCase()}`;

		const actionText = selectedItemsCount === SELECT_ALL_ITEMS ? 'Undo' : customActionText;

		return {
			content: actionText,
			onAction: handleSelectAllItemsInStore
		};
	}

	function handleSelectModeToggle() {
		handleSelectionChange(SelectionType.All, false);
	}

	let selectAllActionsLabel = $derived(`${selectedItemsCountValue} selected`);
	let paginatedSelectAllAction = $derived(getPaginatedSelectAllAction());

	const handleTogglePage = () => {
		handleSelectionChange(SelectionType.Page, Boolean(!bulkSelectState));
	};

	$effect(() => {
		if (selectedItemsCount === SELECT_ALL_ITEMS || selectedItemsCount > 0) {
			selectedItemsCountValue =
				selectedItemsCount === SELECT_ALL_ITEMS ? `${itemCount}+` : selectedItemsCount;
		}
	});

	$effect(() => {
		if (selectedItemsCount !== lastSelectedItemsCount) {
			renderAfterSelectEvent = true;
			lastSelectedItemsCount = selectedItemsCount;
		}

		if (!hasSelected && selectedItemsCount !== 0) {
			hasSelected = true;
		}
	});

	const tableBodyRef = (node: Element | null) => {
		if (node !== null && !tableInitialized) {
			tableInitialized = true;
		}
		tableBodyElement = node;
	};

	const handleSelectAllItemsInStore = () => {
		handleSelectionChange(
			selectedItemsCount === SELECT_ALL_ITEMS ? SelectionType.Page : SelectionType.All,
			true
		);
	};

	const resizeTableHeadings = debounce(() => {
		if (!tableElement || !scrollableContainerElement) {
			return;
		}

		const boundingRect = scrollableContainerElement.getBoundingClientRect();
		tablePosition = {
			top: boundingRect.top,
			left: boundingRect.left
		};

		tableHeadingRects = tableHeadings.map((heading) => ({
			offsetWidth: heading.offsetWidth || 0,
			offsetLeft: heading.offsetLeft || 0
		}));

		if (tableHeadings.length === 0) {
			return;
		}

		// update left offset for first column
		if (selectable && tableHeadings.length > 1) {
			tableHeadings[1].style.left = `${tableHeadingRects[0].offsetWidth}px`;
			if (stickyTableHeadings.length) {
				stickyTableHeadings[1].style.left = `${tableHeadingRects[0].offsetWidth}px`;
			}
		}

		// update sticky header min-widths to match table widths
		if (stickyTableHeadings.length) {
			stickyTableHeadings.forEach((heading, index) => {
				heading.style.minWidth = `${tableHeadingRects[index]?.offsetWidth || 0}px`;
			});
		}
	});

	const resizeTableScrollBar = () => {
		if (scrollBarElement && tableElement && tableInitialized) {
			scrollBarElement.style.setProperty(
				'--pc-index-table-scroll-bar-content-width',
				`${tableElement.offsetWidth - SCROLL_BAR_PADDING}px`
			);

			hideScrollContainer = scrollContainerElement?.offsetWidth === tableElement?.offsetWidth;
		}
	};

	const debounceResizeTableScrollbar = debounce(resizeTableScrollBar, SCROLL_BAR_DEBOUNCE_PERIOD, {
		trailing: true
	});

	let canScrollRight = $state(true);

	const handleCanScrollRight = debounce(() => {
		if (!lastColumnSticky || !tableElement || !scrollableContainerElement) {
			return;
		}

		const tableRect = tableElement.getBoundingClientRect();
		const scrollableRect = scrollableContainerElement.getBoundingClientRect();

		canScrollRight = tableRect.width > scrollableRect.width;
	});

	let canFitStickyColumn = $state(true);

	const handleCanFitStickyColumn = () => {
		if (!scrollableContainerElement || !tableHeadings.length) {
			return;
		}
		const scrollableRect = scrollableContainerElement.getBoundingClientRect();
		const checkboxColumnWidth = selectable ? tableHeadings[0].getBoundingClientRect().width : 0;
		const firstStickyColumnWidth = tableHeadings[selectable ? 1 : 0].getBoundingClientRect().width;
		const lastColumnIsNotTheFirst = selectable ? tableHeadings.length > 2 : 1;
		// Don't consider the last column in the calculations if it's not sticky
		const lastStickyColumnWidth =
			lastColumnSticky && lastColumnIsNotTheFirst
				? tableHeadings[tableHeadings.length - 1].getBoundingClientRect().width
				: 0;
		// Secure some space for the remaining columns to be visible
		const restOfContentMinWidth = 100;
		canFitStickyColumn =
			scrollableRect.width >
			firstStickyColumnWidth + checkboxColumnWidth + lastStickyColumnWidth + restOfContentMinWidth;
	};

	$effect(() => {
		if (tableInitialized) {
			handleCanFitStickyColumn();
		}
	});

	const handleResize = () => {
		// hide the scrollbar when resizing
		scrollBarElement?.style.setProperty('--pc-index-table-scroll-bar-content-width', `0px`);

		resizeTableHeadings();
		debounceResizeTableScrollbar();
		handleCanScrollRight();
		handleCanFitStickyColumn();
	};

	const handleScrollContainerScroll = (canScrollLeft: boolean, canScrollRight: boolean) => {
		if (!scrollableContainerElement || !scrollBarElement) {
			return;
		}

		if (!scrollingWithBar) {
			scrollingContainer = true;
			scrollBarElement.scrollLeft = scrollableContainerElement.scrollLeft;
		}
		scrollingWithBar = false;

		if (stickyHeaderElement) {
			stickyHeaderElement.scrollLeft = scrollableContainerElement.scrollLeft;
		}

		if ((canScrollLeft && !hasMoreLeftColumns) || (!canScrollLeft && hasMoreLeftColumns)) {
			toggleHasMoreLeftColumns();
		}

		canScrollRight = canScrollRight;
	};

	const handleScrollBarScroll = () => {
		if (!scrollableContainerElement || !scrollBarElement) {
			return;
		}

		if (!scrollingContainer) {
			scrollingWithBar = true;
			scrollableContainerElement.scrollLeft = scrollBarElement.scrollLeft;
		}
		scrollingContainer = false;
	};

	$effect(() => {
		resizeTableScrollBar();
		stickyWrapper = condensed ? condensedListElement : tableElement;
	});

	onMount(() => {
		tableHeadings = getTableHeadingsBySelector(tableElement, '[data-index-table-heading]');

		stickyTableHeadings = getTableHeadingsBySelector(
			stickyHeaderWrapperElement,
			'[data-index-table-sticky-heading]'
		);
		resizeTableHeadings();
	});

	function handleSelectPage(checked: boolean) {
		handleSelectionChange(SelectionType.Page, checked);
	}

	const stickyTableClassNames = $derived(
		classNames(
			styles.StickyTable,
			hasMoreLeftColumns && styles['StickyTable-scrolling'],
			condensed && styles['StickyTable-condensed']
		)
	);

	const shouldShowActions = $derived(!condensed || selectedItemsCount);
	const promotedActions = $derived(shouldShowActions ? promotedBulkActions : []);
	const actions = $derived(shouldShowActions ? bulkActions : []);

	const stickyHeaderClassNames = $derived(
		classNames(
			styles.StickyTableHeader,
			isSticky && styles['StickyTableHeader-isSticky'],
			// Has a sticky left column enabled
			canFitStickyColumn && styles['StickyTableHeader-sticky'],
			// ie; is scrolled to the right
			hasMoreLeftColumns && styles['StickyTableHeader-scrolling'],
			// Has a sticky right column enabled
			canFitStickyColumn && lastColumnSticky && styles['StickyTableHeader-sticky-last'],
			// ie; is scrolled to the left
			canFitStickyColumn &&
				lastColumnSticky &&
				canScrollRight &&
				styles['StickyTableHeader-sticky-scrolling']
		)
	);

	const bulkActionsClassName = $derived(
		classNames(
			styles.BulkActionsWrapper,
			selectMode && styles.BulkActionsWrapperVisible,
			condensed && styles['StickyTableHeader-condensed'],
			isSticky && styles['StickyTableHeader-isSticky']
		)
	);

	const scrollBarWrapperClassNames = $derived(
		classNames(
			styles.ScrollBarContainer,
			pagination && styles.ScrollBarContainerWithPagination,
			condensed && styles.scrollBarContainerCondensed,
			hideScrollContainer && styles.scrollBarContainerHidden
		)
	);

	const scrollBarClassNames = $derived(
		classNames(tableElement && tableInitialized && styles.ScrollBarContent)
	);

	onMount(() => {
		resizeTableScrollBar();
	});

	const isSortable = $derived(sortable?.some((value) => value));

	const tableClassNames = $derived(
		classNames(
			styles.Table,
			hasMoreLeftColumns && styles['Table-scrolling'],
			selectMode && styles.disableTextSelection,
			!selectable && styles['Table-unselectable'],
			canFitStickyColumn && styles['Table-sticky'],
			isSortable && styles['Table-sortable'],
			canFitStickyColumn && lastColumnSticky && styles['Table-sticky-last'],
			canFitStickyColumn && lastColumnSticky && canScrollRight && styles['Table-sticky-scrolling'],
			hasZebraStriping && styles.ZebraStriping
		)
	);

	const condensedClassNames = $derived(
		classNames(styles.CondensedList, hasZebraStriping && styles.ZebraStriping)
	);
</script>

{#snippet emptyStateMarkup()}
	{#if emptyState}
		{@render emptyState()}
	{:else}
		<EmptySearchResult
			title={`No ${resourceName.plural.toLocaleLowerCase()} found`}
			description={`Try changing the filters or search term`}
			withIllustration
		/>
	{/if}
{/snippet}

{#snippet scrollBarMarkup()}
	{#if itemCount > 0}
		<div class={scrollBarWrapperClassNames} bind:this={scrollContainerElement}>
			<div onscroll={handleScrollBarScroll} class={styles.ScrollBar} bind:this={scrollBarElement}>
				<div class={scrollBarClassNames}></div>
			</div>
		</div>
	{/if}
{/snippet}

{#snippet sharedMarkup()}
	<EventListener event="resize" handler={handleResize} />
	{@render stickyHeaderMarkup()}
{/snippet}

{#snippet bodyMarkup()}
	{#if condensed}
		{@render sharedMarkup()}
		<ul
			data-selectmode={Boolean(selectMode)}
			class={condensedClassNames}
			bind:this={condensedListElement}
		>
			{@render children?.()}
		</ul>
	{:else}
		{@render sharedMarkup()}
		<ScrollContainer
			bind:scrollableContainerRef={scrollableContainerElement}
			onScroll={handleScrollContainerScroll}
		>
			<table bind:this={tableElement} class={tableClassNames}>
				<thead>
					<tr class={styles.HeadingRow}>{@render headingsMarkup()}</tr>
				</thead>
				<tbody use:tableBodyRef>
					{@render children?.()}
				</tbody>
			</table>
		</ScrollContainer>
	{/if}
{/snippet}

{#snippet tableContentMarkup()}
	{#if itemCount > 0}
		{@render bodyMarkup()}
	{:else}
		<div class={styles.EmptySearchResultWrapper}>
			{@render emptyStateMarkup()}
		</div>
	{/if}
{/snippet}

{#snippet paginationMarkup()}
	{#if pagination}
		<div class={styles.PaginationWrapper}>
			<Pagination type="table" {...pagination} />
		</div>
	{/if}
{/snippet}

{#snippet bulkActionsMarkup()}
	{#if shouldShowActions && !condensed}
		<div class={bulkActionsClassName}>
			<BulkActions
				{selectMode}
				onToggleAll={handleTogglePage}
				{paginatedSelectAllText}
				{paginatedSelectAllAction}
				accessibilityLabel={bulkActionsAccessibilityLabel}
				selected={bulkSelectState}
				{promotedActions}
				{actions}
				onSelectModeToggle={condensed ? handleSelectModeToggle : undefined}
				label={selectAllActionsLabel}
				buttonSize="micro"
			/>
		</div>
	{/if}
{/snippet}

{#snippet headerMarkup()}
	{#if condensed}
		<div
			class={classNames(styles.HeaderWrapper, (!selectable || condensed) && styles.unselectable)}
		>
			{@render loadingMarkup()}
			{@render sort?.()}
		</div>
	{:else}
		<div class={stickyHeaderClassNames} bind:this={stickyHeaderWrapperElement}>
			{@render loadingMarkup()}
			<div class={styles.StickyTableHeadings} bind:this={stickyHeaderElement}>
				{@render stickyHeadingsMarkup()}
			</div>
		</div>
	{/if}
{/snippet}

{#snippet stickyHeaderMarkup()}
	<div class={stickyTableClassNames} role="presentation">
		<Sticky boundingElement={stickyWrapper}>
			{@render headerMarkup()}
			{@render bulkActionsMarkup()}
		</Sticky>
	</div>
{/snippet}

{#snippet loadingMarkup()}
	<div class={classNames(styles.LoadingPanel, loading && styles.LoadingPanelEntered)}>
		<div class={styles.LoadingPanelRow}>
			<Spinner size="small" />
			<span class={styles.LoadingPanelText}>
				Loading {resourceName.plural.toLocaleLowerCase()}
			</span>
		</div>
	</div>
{/snippet}

{#snippet headingsMarkup()}
	{#each headings as heading, index}
		<RenderHeading
			{heading}
			{headings}
			{index}
			Tag="th"
			tagProps={{ 'data-index-table-heading': true }}
			id={heading.id}
			{selectable}
			{sortable}
			{sortColumnIndex}
			{onSort}
			{sortDirection}
			{defaultSortDirection}
			{sortToggleLabels}
			{resourceName}
			{bulkSelectState}
			{selectMode}
			{itemCount}
			{selectedItemsCount}
		/>
		<!-- {@render renderHeading(heading, index, 'th', { 'data-index-table-heading': true }, heading.id)} -->
	{/each}
{/snippet}

{#snippet stickyHeadingsMarkup()}
	{#each headings as heading, index}
		<RenderHeading
			{heading}
			{headings}
			{index}
			Tag="div"
			tagProps={{ 'data-index-table-sticky-heading': true }}
			{selectable}
			{sortable}
			{sortColumnIndex}
			{onSort}
			{sortDirection}
			{defaultSortDirection}
			{sortToggleLabels}
			{resourceName}
			{bulkSelectState}
			{selectMode}
			{itemCount}
			{selectedItemsCount}
		/>
		<!-- {@render renderHeading(heading, index, 'div', { 'data-index-table-sticky-heading': true })} -->
	{/each}
{/snippet}

<div class={styles.IndexTable}>
	<div class={styles.IndexTableWrapper}>
		{#if !condensed}
			{@render loadingMarkup()}
		{/if}
		{@render tableContentMarkup()}
		{@render scrollBarMarkup()}
		{@render paginationMarkup()}
	</div>
</div>

```

# components/index-table/index-table.module.css

```css
.IndexTable {
  /* stylelint-disable -- Polaris component custom properties */
  --pc-index-table-translate-offset: 35px;
  --pc-index-table-table-header-offset: var(--pg-control-height);
  --pc-index-table-cell: 1;
  --pc-index-table-sticky-cell: 29;
  --pc-index-table-bulk-actions: 31;
  --pc-index-table-loading-panel: 31;
  --pc-index-table-checkbox-offset-left: var(--p-space-300);
  --pc-index-table-checkbox-offset-right: var(--p-space-200);
  /* stylelint-enable */
  position: relative;
  border-radius: 0;
  scrollbar-color: auto;

  @media (--p-breakpoints-sm-up) {
    border-radius: inherit;
    border-start-start-radius: 0;
    border-start-end-radius: 0;
  }
}

.IndexTableWrapper {
  border-radius: 0;

  .IndexTableWrapper-scrollBarHidden {
    border-radius: inherit;
  }
}

.IndexTableWrapperWithSelectAllActions {
  /* stylelint-disable-next-line -- Polaris component custom properties */
  --pc-index-table-bulk-actions-offset: 41px;
  /* stylelint-disable-next-line -- generated by polaris-migrator DO NOT COPY */
  padding-bottom: var(--pc-index-table-bulk-actions-offset);
  border-radius: 0;
}

.LoadingPanel {
  position: absolute;
  z-index: var(--p-z-index-2);
  top: 0;
  left: 0;
  display: flex;
  width: 100%;
  justify-content: center;
  align-items: center;
  background: var(--p-color-bg-surface);
  padding: var(--p-space-200) var(--p-space-400);
  box-shadow: var(--p-shadow-300);
  opacity: 0;
  transform: translateY(-100%);
  transition: opacity var(--p-motion-duration-100) var(--p-motion-ease-in),
    transform var(--p-motion-duration-100) var(--p-motion-ease-in),
    visibility var(--p-motion-duration-0) linear var(--p-motion-duration-100);
  visibility: hidden;

  &.LoadingPanelEntered {
    visibility: visible;
    opacity: 1;
    transform: translateY(0);
    transition: opacity var(--p-motion-duration-100) var(--p-motion-ease-out),
      transform var(--p-motion-duration-100) var(--p-motion-ease-out);
  }

  .LoadingPanelRow {
    display: flex;
    flex-wrap: nowrap;
    width: 100%;
    background: var(--p-color-bg-surface-info);
    padding: var(--p-space-200);
    padding-bottom: var(--p-space-100);
    border-radius: var(--p-border-radius-100);
  }
}

.LoadingPanelText {
  margin-left: var(--p-space-300);
  color: var(--p-color-text);
}

.Table {
  width: 100%;
  min-width: 100%;
  border-collapse: collapse;
}

.Table-scrolling,
.StickyTable-scrolling {

  /* stylelint-disable-next-line selector-max-class, selector-max-combinators -- generated by polaris-migrator DO NOT COPY */
  .TableCell-first,
  .TableCell-first+.TableCell,
  .TableHeading-first,
  .TableHeading-second {
    visibility: visible;
    background-color: var(--p-color-bg-surface);
  }

  .TableHeading-first,
  .TableHeading-second {
    visibility: visible;
    background-color: var(--p-color-bg-surface-secondary);
  }

  /* TODO: Delete this since mobile no longer has an action column (checkbox) */
  .TableCell-first,
  .TableHeading-first {
    filter: drop-shadow(1px 0 0 var(--p-color-border-secondary));
  }

  &.Table-sticky,
  &.StickyTable {

    /* stylelint-disable-next-line selector-max-class, selector-max-combinators, selector-max-specificity -- generated by polaris-migrator DO NOT COPY */
    .TableCell-first+.TableCell,
    .TableHeading-second {
      @media (--p-breakpoints-sm-up) {
        filter: drop-shadow(1px 0 0 var(--p-color-border-secondary));
      }
    }

    /* stylelint-disable-next-line selector-max-class -- generated by polaris-migrator DO NOT COPY */
    &.Table-unselectable {

      /* stylelint-disable-next-line selector-max-class, selector-max-specificity -- generated by polaris-migrator DO NOT COPY */
      .TableHeading-second,
      .TableCell:first-child {
        filter: drop-shadow(1px 0 0 var(--p-color-border-secondary));
      }
    }
  }

  &.Table-unselectable {

    /* stylelint-disable-next-line selector-max-class, selector-max-specificity -- generated by polaris-migrator DO NOT COPY */
    .TableHeading-second,
    .TableCell:first-child {
      visibility: visible;
    }
  }
}

.TableRow {
  background-color: var(--p-color-bg-surface);
  cursor: pointer;
  border-top: var(--p-border-width-025) solid var(--p-color-border-secondary);

  &:first-child {
    border-top: var(--p-border-width-025) solid var(--p-color-border);
  }

  &.TableRow-unclickable {
    cursor: auto;
  }

  &.toneSuccess {

    /* stylelint-disable-next-line selector-max-combinators, selector-max-class, selector-max-specificity -- generated by polaris-migrator DO NOT COPY */
    &,
    .TableCell-first,
    .TableCell-first+.TableCell,
    .TableCell:last-child {
      background-color: var(--p-color-bg-surface-success);
    }
  }

  /* stylelint-disable-next-line selector-max-class -- adds success tone for nested rows */
  &.TableRow-child.toneSuccess {

    /* stylelint-disable-next-line selector-max-class, selector-max-specificity -- adds success tone for nested rows */
    &,
    .TableCell-first {

      /* stylelint-disable-next-line -- adds success tone for nested rows */
      &::before {
        background-color: var(--p-color-bg-surface-success);
      }
    }
  }

  &.toneWarning {

    /* stylelint-disable-next-line selector-max-class, selector-max-combinators, selector-max-specificity -- adds warning tone for suspended products */
    &,
    .TableCell-first,
    .TableCell-first+.TableCell,
    .TableCell:last-child {
      background-color: var(--p-color-bg-surface-warning);
    }
  }

  /* stylelint-disable-next-line selector-max-class -- adds warning tone for nested rows */
  &.TableRow-child.toneWarning {

    /* stylelint-disable-next-line selector-max-class, selector-max-specificity -- adds warning tone for nested rows */
    &,
    .TableCell-first {

      /* stylelint-disable-next-line -- adds warning tone for nested rows */
      &::before {
        background-color: var(--p-color-bg-surface-warning);
      }
    }
  }

  &.toneCritical {

    /* stylelint-disable-next-line selector-max-class, selector-max-combinators, selector-max-specificity -- adds crtical tone for suspended products */
    &,
    .TableCell-first,
    .TableCell-first+.TableCell,
    .TableCell:last-child {
      background-color: var(--p-color-bg-surface-critical);
    }
  }

  /* stylelint-disable-next-line selector-max-class -- adds critical tone for nested rows */
  &.TableRow-child.toneCritical {

    /* stylelint-disable-next-line selector-max-class, selector-max-specificity -- adds critical tone for nested rows */
    &,
    .TableCell-first {

      /* stylelint-disable-next-line -- adds critical tone for nested rows */
      &::before {
        background-color: var(--p-color-bg-surface-critical);
      }
    }
  }

  &.toneSubdued {

    /* stylelint-disable-next-line selector-max-combinators, selector-max-class, selector-max-specificity -- generated by polaris-migrator DO NOT COPY */
    &,
    .TableCell-first,
    .TableCell-first+.TableCell,
    .TableCell:last-child {
      background-color: var(--p-color-bg-surface-secondary);
      color: var(--p-color-text-secondary);
    }
  }

  /* stylelint-disable-next-line selector-max-class -- adds secondary tone for nested rows */
  &.TableRow-child.toneSubdued {

    /* stylelint-disable-next-line selector-max-class, selector-max-specificity -- adds secondary tone for nested rows */
    &,
    .TableCell-first {

      /* stylelint-disable-next-line -- adds secondary tone for nested rows */
      &::before {
        background-color: var(--p-color-bg-surface-secondary);
      }
    }
  }

  &.TableRow-subheader {
    cursor: default;

    /* stylelint-disable-next-line selector-max-combinators, selector-max-class, selector-max-specificity -- generated by polaris-migrator DO NOT COPY */
    &,
    .TableCell:first-child,
    .TableCell-first,
    .TableCell-first+.TableCell,
    .TableCell:last-child {
      color: var(--p-color-text-secondary);
      font-weight: var(--p-font-weight-medium);
      font-size: var(--p-font-size-300);
      background-color: var(--p-color-bg-surface-secondary);
      border-top: var(--p-border-width-025) solid var(--p-color-border);
      border-bottom: var(--p-border-width-025) solid var(--p-color-border);
      border-color: var(--p-color-border);
    }
  }

  &.TableRow-child {
    /* stylelint-disable -- polaris/conventions/polaris/custom-property-allowed-list */
    --pc-index-table-checkbox-width: var(--p-space-500);
    /* checkbox width is bigger for 2px for small devices */
    --pc-index-table-checkbox-width-sm: calc(var(--pc-index-table-checkbox-width) + var(--p-width-050));
    --pc-index-table-checkbox-padding-left: var(--p-space-300);
    --pc-index-table-checkbox-padding-right: var(--p-width-150);
    --pc-index-table-checkbox-child-offset: calc(var(--pc-index-table-checkbox-width) + var(--pc-index-table-checkbox-padding-left));
    --pc-index-table-checkbox-child-offset-sm: calc(var(--pc-index-table-checkbox-width-sm) + var(--pc-index-table-checkbox-padding-left));
    --pc-table-shifted-checkbox-z-index: 30;

    .TableCell-first {
      left: var(--pc-index-table-checkbox-child-offset);
      z-index: var(--pc-table-shifted-checkbox-z-index);

      @media (--p-breakpoints-sm-down) {
        left: var(--pc-index-table-checkbox-child-offset-sm);
      }

      &::before {
        content: '';
        position: absolute;
        display: block;
        width: calc(var(--pc-index-table-checkbox-child-offset) + var(--pc-index-table-checkbox-padding-right));
        height: 100%;
        top: 0;
        right: var(--pc-index-table-checkbox-child-offset);
        background-color: var(--p-color-bg-surface);

        @media (--p-breakpoints-sm-down) {
          width: calc(var(--pc-index-table-checkbox-child-offset-sm) + var(--pc-index-table-checkbox-padding-right));
          right: var(--pc-index-table-checkbox-child-offset-sm);
        }
      }
    }

    .TableCell-first+.TableCell {
      --pc-index-table-cell-padding: var(--p-space-150);
      padding-left: calc(var(--pc-index-table-checkbox-child-offset) + var(--pc-index-table-cell-padding));

      @media (--p-breakpoints-sm-down) {
        padding-left: calc(var(--pc-index-table-checkbox-child-offset-sm) + var(--pc-index-table-cell-padding));
      }
    }

    /* stylelint-enable -- polaris/conventions/polaris/custom-property-allowed-list */
  }

  &.TableRow-selected {
    border-color: var(--p-color-border);

    /* stylelint-disable-next-line selector-max-class, selector-max-combinators, selector-max-specificity -- generated by polaris-migrator DO NOT COPY */
    &,
    .TableHeading-first,
    .TableHeading-second,
    .TableCell-first,
    .TableCell-first+.TableCell,
    .TableCell:last-child {
      background-color: var(--p-color-bg-surface-selected);
    }

    /* stylelint-disable-next-line selector-max-class -- adds selected tone for nested rows */
    &.TableRow-child {

      /* stylelint-disable-next-line selector-max-class, selector-max-specificity -- adds selected tone for nested rows */
      &,
      .TableCell-first {

        /* stylelint-disable-next-line -- adds selected tone for nested rows */
        &::before {
          background-color: var(--p-color-bg-surface-selected);
        }
      }
    }

    /* stylelint-disable-next-line selector-max-class -- generated by polaris-migrator DO NOT COPY */
    &.toneSuccess {

      /* stylelint-disable-next-line selector-max-combinators, selector-max-class, selector-max-specificity -- generated by polaris-migrator DO NOT COPY */
      &,
      .TableCell:first-child,
      .TableCell-first,
      .TableCell-first+.TableCell,
      .TableCell:last-child {
        background-color: var(--p-color-bg-surface-success-active);
      }
    }

    /* stylelint-disable-next-line selector-max-class, selector-max-specificity -- adds success active tone for nested rows */
    &.TableRow-child.toneSuccess {

      /* stylelint-disable-next-line selector-max-class, selector-max-specificity -- adds success active tone for nested rows */
      &,
      .TableCell-first {

        /* stylelint-disable-next-line -- adds success active tone for nested rows */
        &::before {
          background-color: var(--p-color-bg-surface-success-active);
        }
      }
    }

    /* stylelint-disable-next-line selector-max-class -- generated by polaris-migrator DO NOT COPY */
    &.toneWarning {

      /* stylelint-disable-next-line selector-max-class, selector-max-combinators, selector-max-specificity -- added crtical tone for suspended products */
      &,
      .TableCell:first-child,
      .TableCell-first,
      .TableCell-first+.TableCell,
      .TableCell:last-child {
        background-color: var(--p-color-bg-surface-warning-active);
      }
    }

    /* stylelint-disable-next-line selector-max-class, selector-max-specificity -- adds warning active tone for nested rows */
    &.TableRow-child.toneWarning {

      /* stylelint-disable-next-line selector-max-class, selector-max-specificity -- adds warning active tone for nested rows */
      &,
      .TableCell-first {

        /* stylelint-disable-next-line -- adds warning active tone for nested rows */
        &::before {
          background-color: var(--p-color-bg-surface-warning-active);
        }
      }
    }

    /* stylelint-disable-next-line selector-max-class -- generated by polaris-migrator DO NOT COPY */
    &.toneCritical {

      /* stylelint-disable-next-line selector-max-class, selector-max-combinators, selector-max-specificity -- added crtical tone for suspended products */
      &,
      .TableCell:first-child,
      .TableCell-first,
      .TableCell-first+.TableCell,
      .TableCell:last-child {
        background-color: var(--p-color-bg-surface-critical-active);
      }
    }

    /* stylelint-disable-next-line selector-max-class, selector-max-specificity -- adds critical active tone for nested rows */
    &.TableRow-child.toneCritical {

      /* stylelint-disable-next-line selector-max-class, selector-max-specificity -- adds critical active tone for nested rows */
      &,
      .TableCell-first {

        /* stylelint-disable-next-line -- adds critical active tone for nested rows */
        &::before {
          background-color: var(--p-color-bg-surface-critical-active);
        }
      }
    }

    /* stylelint-disable-next-line selector-max-class -- generated by polaris-migrator DO NOT COPY */
    &.toneSubdued {

      /* stylelint-disable-next-line selector-max-combinators, selector-max-class, selector-max-specificity -- generated by polaris-migrator DO NOT COPY */
      &,
      .TableCell:first-child,
      .TableCell-first,
      .TableCell-first+.TableCell,
      .TableCell:last-child {
        background-color: var(--p-color-bg-surface-secondary-active);
      }
    }

    /* stylelint-disable-next-line selector-max-class, selector-max-specificity -- adds secondary active tone for nested rows */
    &.TableRow-child.toneSubdued {

      /* stylelint-disable-next-line selector-max-class, selector-max-specificity -- adds secondary active tone for nested rows */
      &,
      .TableCell-first {

        /* stylelint-disable-next-line -- adds secondary active tone for nested rows */
        &::before {
          background-color: var(--p-color-bg-surface-secondary-active);
        }
      }
    }

    /* stylelint-disable-next-line selector-max-class -- generated by polaris-migrator DO NOT COPY */
    &.TableRow-subheader {

      /* stylelint-disable-next-line selector-max-class, selector-max-combinators, selector-max-specificity -- generated by polaris-migrator DO NOT COPY */
      &,
      .TableCell:first-child,
      .TableCell-first,
      .TableCell-first+.TableCell,
      .TableCell:last-child {
        background-color: var(--p-color-bg-surface-secondary);
      }
    }
  }

  /* NOTE: `-hovered` must come after `-selected` so elements don't appear to lose their interactivity when selected. */
  &.TableRow-hovered:not(.TableRow-disabled) {

    /* stylelint-disable-next-line selector-max-class, selector-max-combinators, selector-max-specificity -- generated by polaris-migrator DO NOT COPY */
    &,
    .TableCell-first,
    .TableCell-first+.TableCell,
    .TableCell:last-child {
      background-color: var(--p-color-bg-surface-hover);
    }

    /* stylelint-disable-next-line selector-max-class, selector-max-specificity -- adds hover tone for nested rows */
    &.TableRow-child {

      /* stylelint-disable-next-line selector-max-class, selector-max-specificity -- adds hover tone for nested rows */
      &,
      .TableCell-first {

        /* stylelint-disable-next-line -- adds hover tone for nested rows */
        &::before {
          background-color: var(--p-color-bg-surface-hover);
        }
      }
    }

    /* stylelint-disable-next-line selector-max-class, selector-max-specificity -- generated by polaris-migrator DO NOT COPY */
    &.toneSuccess {

      /* stylelint-disable-next-line selector-max-class, selector-max-combinators, selector-max-specificity -- generated by polaris-migrator DO NOT COPY */
      &,
      .TableCell-first,
      .TableCell-first+.TableCell,
      .TableCell:last-child {
        background-color: var(--p-color-bg-surface-success-hover);
      }
    }

    /* stylelint-disable-next-line selector-max-class, selector-max-specificity -- adds success tone for nested rows */
    &.TableRow-child.toneSuccess {

      /* stylelint-disable-next-line selector-max-class, selector-max-specificity -- adds success tone for nested rows */
      &,
      .TableCell-first {

        /* stylelint-disable-next-line -- adds success tone for nested rows */
        &::before {
          background-color: var(--p-color-bg-surface-success-hover);
        }
      }
    }

    /* stylelint-disable-next-line selector-max-class, selector-max-specificity -- generated by polaris-migrator DO NOT COPY */
    &.toneCritical {

      /* stylelint-disable-next-line selector-max-class, selector-max-combinators, selector-max-specificity -- generated by polaris-migrator DO NOT COPY */
      &,
      .TableCell-first,
      .TableCell-first+.TableCell,
      .TableCell:last-child {
        background-color: var(--p-color-bg-surface-critical-hover);
      }
    }

    /* stylelint-disable-next-line selector-max-class, selector-max-specificity -- adds critical tone for nested rows */
    &.TableRow-child.toneCritical {

      /* stylelint-disable-next-line selector-max-class, selector-max-specificity -- adds critical tone for nested rows */
      &,
      .TableCell-first {

        /* stylelint-disable-next-line -- adds critical tone for nested rows */
        &::before {
          background-color: var(--p-color-bg-surface-critical-hover);
        }
      }
    }

    /* stylelint-disable-next-line -- tone table override */
    &.toneWarning {

      /* stylelint-disable-next-line -- tone table override */
      &,
      .TableCell-first,
      .TableCell-first+.TableCell,
      .TableCell:last-child {
        background-color: var(--p-color-bg-surface-warning-hover);
      }
    }

    /* stylelint-disable-next-line selector-max-class, selector-max-specificity -- adds warning tone for nested rows */
    &.TableRow-child.toneWarning {

      /* stylelint-disable-next-line selector-max-class, selector-max-specificity -- adds warning tone for nested rows */
      &,
      .TableCell-first {

        /* stylelint-disable-next-line -- adds warning tone for nested rows */
        &::before {
          background-color: var(--p-color-bg-surface-warning-hover);
        }
      }
    }

    /* stylelint-disable-next-line selector-max-class, selector-max-specificity -- generated by polaris-migrator DO NOT COPY */
    &.toneSubdued {

      /* stylelint-disable-next-line selector-max-class, selector-max-combinators, selector-max-specificity -- generated by polaris-migrator DO NOT COPY */
      &,
      .TableCell-first,
      .TableCell-first+.TableCell,
      .TableCell:last-child {
        background-color: var(--p-color-bg-surface-secondary-hover);
      }
    }

    /* stylelint-disable-next-line selector-max-class, selector-max-specificity -- adds secondary tone for nested rows */
    &.TableRow-child.toneSubdued {

      /* stylelint-disable-next-line selector-max-class, selector-max-specificity -- adds secondary tone for nested rows */
      &,
      .TableCell-first {

        /* stylelint-disable-next-line -- adds secondary tone for nested rows */
        &::before {
          background-color: var(--p-color-bg-surface-secondary-hover);
        }
      }
    }

    /* stylelint-disable-next-line selector-max-class, selector-max-specificity --  subheader bg color override */
    &.TableRow-subheader {

      /* stylelint-disable-next-line selector-max-class, selector-max-combinators, selector-max-specificity -- generated by polaris-migrator DO NOT COPY */
      &,
      .TableCell:first-child,
      .TableCell-first,
      .TableCell-first+.TableCell,
      .TableCell:last-child {
        background-color: var(--p-color-bg-surface-secondary);
      }
    }
  }

  /* stylelint-disable-next-line selector-max-class -- generated by polaris-migrator DO NOT COPY */
  &.TableRow-hovered.TableRow-selected {

    /* stylelint-disable-next-line selector-max-class, selector-max-combinators, selector-max-specificity -- generated by polaris-migrator DO NOT COPY */
    &,
    .TableCell-first,
    .TableCell-first+.TableCell,
    .TableCell:last-child {
      background-color: var(--p-color-bg-surface-brand-hover);

      /* stylelint-disable-next-line selector-max-class, selector-max-combinators, selector-max-specificity -- background color for selected nested rows */
      &::before {
        background-color: var(--p-color-bg-surface-brand-hover);
      }
    }

    /* stylelint-disable-next-line selector-max-class, selector-max-specificity -- adds hover tone for nested rows */
    &.TableRow-child {

      /* stylelint-disable-next-line selector-max-class, selector-max-specificity -- adds hover tone for nested rows */
      &,
      .TableCell-first {

        /* stylelint-disable-next-line -- adds hover tone for nested rows */
        &::before {
          background-color: var(--p-color-bg-surface-brand-hover);
        }
      }
    }

    /* stylelint-disable-next-line selector-max-class, selector-max-specificity -- generated by polaris-migrator DO NOT COPY */
    &.toneSuccess {

      /* stylelint-disable-next-line selector-max-combinators, selector-max-class, selector-max-specificity -- generated by polaris-migrator DO NOT COPY */
      &,
      .TableCell:first-child,
      .TableCell-first,
      .TableCell-first+.TableCell,
      .TableCell:last-child {
        background-color: var(--p-color-bg-surface-success-hover);
      }
    }

    /* stylelint-disable-next-line selector-max-class, selector-max-specificity -- adds success hover tone for nested rows */
    &.TableRow-child.toneSuccess {

      /* stylelint-disable-next-line selector-max-class, selector-max-specificity -- adds success hover tone for nested rows */
      &,
      .TableCell-first {

        /* stylelint-disable-next-line -- adds success hover tone for nested rows */
        &::before {
          background-color: var(--p-color-bg-surface-success-hover);
        }
      }
    }

    /* stylelint-disable-next-line selector-max-class, selector-max-specificity -- generated by polaris-migrator DO NOT COPY */
    &.toneWarning {

      /* stylelint-disable-next-line selector-max-class, selector-max-combinators, selector-max-specificity -- added crtical tone for suspended products */
      &,
      .TableCell:first-child,
      .TableCell-first,
      .TableCell-first+.TableCell,
      .TableCell:last-child {
        background-color: var(--p-color-bg-surface-warning-hover);
      }
    }

    /* stylelint-disable-next-line selector-max-class, selector-max-specificity -- generated by polaris-migrator DO NOT COPY */
    &.toneCritical {

      /* stylelint-disable-next-line selector-max-class, selector-max-combinators, selector-max-specificity -- added crtical tone for suspended products */
      &,
      .TableCell:first-child,
      .TableCell-first,
      .TableCell-first+.TableCell,
      .TableCell:last-child {
        background-color: var(--p-color-bg-surface-critical-hover);
      }
    }

    /* stylelint-disable-next-line selector-max-class, selector-max-specificity -- generated by polaris-migrator DO NOT COPY */
    &.toneSubdued {

      /* stylelint-disable-next-line selector-max-combinators, selector-max-class, selector-max-specificity  -- generated by polaris-migrator DO NOT COPY */
      &,
      .TableCell:first-child,
      .TableCell-first,
      .TableCell-first+.TableCell,
      .TableCell:last-child {
        background-color: var(--p-color-bg-surface-secondary-hover);
      }
    }

    /* stylelint-disable-next-line selector-max-class, selector-max-specificity -- generated by polaris-migrator DO NOT COPY */
    &.TableRow-subheader {

      /* stylelint-disable-next-line selector-max-class, selector-max-combinators, selector-max-specificity -- generated by polaris-migrator DO NOT COPY */
      &,
      .TableCell:first-child,
      .TableCell-first,
      .TableCell-first+.TableCell,
      .TableCell:last-child {
        background-color: var(--p-color-bg-surface-secondary);
      }
    }
  }
}

.TableRow-disabled {
  cursor: default;
  color: var(--p-color-text-secondary);
}

/* Extra specificity is needed to address edge cases where the zebra striping is combined with other options */
/* stylelint-disable selector-max-specificity, selector-max-class, selector-max-combinators -- extra specificity needed for when combining props */
.ZebraStriping {

  .Table-scrolling .TableRow:nth-child(2n + 1),
  .TableRow:nth-child(2n + 1) {

    /* stylelint-disable-next-line selector-max-compound-selectors -- extra specificity needed for when combining props */
    &,
    .TableCell:first-child,
    .TableCell-first,
    .TableCell-first+.TableCell,
    .TableCell:last-child {
      background-color: var(--p-color-bg-surface);
    }
  }

  .Table-scrolling .TableRow:nth-child(2n),
  .TableRow:nth-child(2n) {

    /* stylelint-disable-next-line selector-max-compound-selectors -- extra specificity needed for when combining props */
    &,
    .TableCell:first-child,
    .TableCell-first,
    .TableCell-first+.TableCell,
    .TableCell:last-child {
      background: var(--p-color-bg-surface-secondary);
    }
  }

  .TableRow-child:nth-child(2n) {

    /* stylelint-disable-next-line  -- adds secondary tone for nested rows */
    &,
    .TableCell-first {

      /* stylelint-disable-next-line -- adds secondary tone for nested rows */
      &::before {
        background-color: var(--p-color-bg-surface-secondary);
      }
    }
  }

  .Table-scrolling .TableRow-hovered:not(.TableRow-disabled):nth-child(2n + 1),
  .TableRow-hovered:not(.TableRow-disabled):nth-child(2n + 1),
  .Table-scrolling .TableRow-hovered:not(.TableRow-disabled):nth-child(2n),
  .TableRow-hovered:not(.TableRow-disabled):nth-child(2n) {

    /* stylelint-disable-next-line selector-max-compound-selectors -- extra specificity needed for when combining props */
    &,
    .TableCell:first-child,
    .TableCell-first,
    .TableCell-first+.TableCell,
    .TableCell:last-child {
      background-color: var(--p-color-bg-surface-hover);
    }
  }

  .Table-scrolling .TableRow-selected:nth-child(2n + 1),
  .TableRow-selected:nth-child(2n + 1),
  .Table-scrolling .TableRow-selected:nth-child(2n),
  .TableRow-selected:nth-child(2n) {

    /* stylelint-disable-next-line selector-max-compound-selectors -- extra specificity needed for when combining props */
    &,
    .TableCell:first-child,
    .TableCell-first,
    .TableCell-first+.TableCell,
    .TableCell:last-child {
      background-color: var(--p-color-bg-surface-brand-selected);
    }
  }

  .TableRow-child.TableRow-selected:nth-child(2n),
  .TableRow-child.TableRow-selected:nth-child(2n + 1) {

    /* stylelint-disable-next-line  -- adds selected tone for nested rows */
    &,
    .TableCell-first {

      /* stylelint-disable-next-line -- adds selected tone for nested rows */
      &::before {
        background-color: var(--p-color-bg-surface-brand-selected);
      }
    }
  }

  .Table-scrolling .TableRow-hovered.TableRow-selected:nth-child(2n + 1),
  .TableRow-hovered.TableRow-selected:nth-child(2n + 1),
  .Table-scrolling .TableRow-hovered.TableRow-selected:nth-child(2n),
  .TableRow-hovered.TableRow-selected:nth-child(2n) {

    /* stylelint-disable-next-line selector-max-compound-selectors -- extra specificity needed for when combining props */
    &,
    .TableCell:first-child,
    .TableCell-first,
    .TableCell-first+.TableCell,
    .TableCell:last-child {
      background-color: var(--p-color-bg-surface-brand-hover);
    }
  }

  .TableRow-hovered.TableRow-selected:nth-child(2n),
  .TableRow-hovered.TableRow-selected:nth-child(2n + 1) {

    /* stylelint-disable-next-line  -- adds hover tone for nested rows */
    &,
    .TableCell-first {

      /* stylelint-disable-next-line -- adds hover tone for nested rows */
      &::before {
        background-color: var(--p-color-bg-surface-brand-hover);
      }
    }
  }
}

/* stylelint-enable selector-max-specificity, selector-max-class, selector-max-combinators */

.TableHeading {
  /* stylelint-disable -- Polaris component custom properties */
  --pc-index-table-heading-padding-x: var(--p-space-150);
  --pc-index-table-heading-padding-y: var(--p-space-200);
  background: var(--p-color-bg-surface-secondary);
  padding: var(--pc-index-table-heading-padding-y) var(--pc-index-table-heading-padding-x);
  /* stylelint-enable */
  text-align: left;
  font-weight: var(--p-font-weight-medium);
  color: var(--p-color-text-secondary);
  font-size: var(--p-font-size-300);
  white-space: nowrap;
  border: 0;

  &:first-child:not(.TableHeading-flush) {
    padding-left: var(--p-space-300);
  }

  &:last-child:not(.TableHeading-flush) {
    padding-right: var(--p-space-300);
    overflow-x: hidden;
  }
}

.TableHeading-align-center {
  text-align: center;

  [class*='TooltipContainer'] {
    justify-content: center;
  }
}

.TableHeading-align-end {
  text-align: right;

  [class*='TooltipContainer'],
  [class*='SortableTableHeadingWithCustomMarkup'] {
    justify-content: end;
  }
}

.TableHeading-extra-padding-right {
  /* stylelint-disable -- polaris component custom properties */
  --pc-index-table-heading-extra-padding-right: 0rem;
  padding-right: var(--pc-index-table-heading-extra-padding-right);
  /* stylelint-enable */
}

.TableHeading-sortable {
  background: var(--p-color-bg-surface-secondary);
}

.TableHeading-flush {
  /* stylelint-disable -- polaris component custom properties */
  /*
      We specify 0rem here because our bundle process uses postcss-pxtorem.
      This forceable converts 0px to 0 which is invalid for calcs but leaves rems alone.
      See https://github.com/cuth/postcss-pxtorem/blob/122649015322214f8e9d1ac852eb11c0791b634b/index.js#L52
    */
  --pc-index-table-heading-padding-x: 0rem;
  padding: var(--pc-index-table-heading-padding-y) var(--pc-index-table-heading-padding-x);
  /* stylelint-enable */
}

.TableHeading-first {
  position: sticky;
  left: 0;
  /* stylelint-disable-next-line -- specificity overrides */
  padding-left: var(--pc-index-table-checkbox-offset-left);
  /* stylelint-disable-next-line -- specificity overrides */
  padding-right: var(--pc-index-table-checkbox-offset-right);
  width: var(--p-space-500);
  /* stylelint-disable-next-line -- first column (checkbox) overlaps other headings on horizontal scroll */
  z-index: var(--pc-index-table-sticky-cell);
}

.TableHeadingSortButton {
  position: relative;
  background: none;
  padding: 0;
  border: 0;
  cursor: pointer;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  font-weight: var(--p-font-weight-medium);
  color: var(--p-color-text-secondary);
  font-size: var(--p-font-size-300);
  line-height: var(--p-font-line-height-500);

  &:hover,
  &:focus {
    .TableHeadingSortIcon {
      opacity: 1;
    }
  }
}

.TableHeadingSortButton-heading-align-end {
  transform: translateX(var(--p-space-500));
  transition-delay: var(--p-motion-duration-50);

  &:hover,
  &:focus {
    transition-delay: none;
    transform: translateX(var(--p-space-100));
  }
}

/* expands button area to retain hover after button slides to the left */
.TableHeadingSortButton-heading-align-end:hover::before {
  content: '';
  position: absolute;
  top: 0;
  left: calc(100% - var(--p-space-200));
  height: 100%;
  width: var(--p-space-600);
  display: block;
  animation: none;
  transition: none;
}

.TableHeadingSortButton-heading-align-end-currently-sorted {
  transform: translateX(var(--p-space-100));

  .TableHeadingSortIcon-heading-align-end {
    animation: none;
  }
}

.TableHeadingSortButton-heading-align-end-previously-sorted {
  animation: right-aligned-sort-button-slide-out var(--p-motion-duration-50) var(--p-motion-ease);
}

.TableHeadingSortIcon {
  order: 1;
  opacity: 0;
  height: var(--p-space-500);
  width: var(--p-space-500);

  &:not(.TableHeadingSortIcon-heading-align-end:hover),
  &:not(.TableHeadingSortButton-heading-align-end-previously-sorted) {
    transition: opacity var(--p-motion-duration-50) var(--p-motion-ease);
  }
}

.TableHeadingSortButton:hover {
  .TableHeadingSortIcon-heading-align-end {
    animation: reveal-right-aligned-sort-button-icon var(--p-motion-duration-200) var(--p-motion-ease);
  }
}

.TableHeadingSortButton-heading-align-end-currently-sorted:hover {
  .TableHeadingSortIcon-heading-align-end {
    animation: none;
  }
}

.TableHeadingUnderline::after {
  content: '';
  position: absolute;
  left: 0;
  bottom: calc(-1 * var(--p-border-width-050));
  width: 100%;
  height: var(--p-border-width-050);
  border-bottom: var(--p-border-width-050) dotted var(--p-color-border-tertiary);
}

.TableHeadingTooltipUnderlinePlaceholder {
  border-bottom: var(--p-border-width-050) dotted transparent;
}

.TableHeadingSortIcon-visible {
  opacity: 1;
}

.TableHeadingSortSvg {
  display: block;
  width: 100%;
  max-width: 100%;
  max-height: 100%;
}

.SortableTableHeadingWithCustomMarkup {
  display: flex;
  flex-wrap: nowrap;
}

.SortableTableHeaderWrapper {
  cursor: pointer;
}

.ColumnHeaderCheckboxWrapper {
  display: flex;
}

.FirstStickyHeaderElement {
  padding-right: 0;
}

.TableHeading-second:not(.TableHeading-unselectable) {
  padding-left: 0;

  &:not(.TableHeading-flush) {
    /* stylelint-disable-next-line -- Polaris custom property */
    padding-left: var(--pc-index-table-heading-padding-x);
  }
}

.TableCell {
  /* stylelint-disable-next-line -- generated by polaris-migrator DO NOT COPY */
  z-index: var(--pc-index-table-cell);
  text-align: left;
  padding: var(--p-space-200) var(--p-space-400);
  white-space: nowrap;

  &:not(.TableCell-flush) {
    padding: var(--p-space-150);

    &:first-child {
      padding-left: var(--p-space-300);

      /* stylelint-disable-next-line selector-max-specificity -- This is a valid selector */
      .Table:not(.Table-unselectable) & {
        /* stylelint-disable-next-line -- specificity overrides */
        padding-right: var(--pc-index-table-checkbox-offset-right);
      }
    }

    &:last-child {
      padding-right: var(--p-space-300);
    }
  }
}

.TableCell-flush {
  padding: 0;

  &:first-child {
    padding: 0;
  }
}

.TableCell-first {
  position: sticky;
  left: 0;
  /* stylelint-disable-next-line -- generated by polaris-migrator DO NOT COPY */
  z-index: var(--pc-index-table-sticky-cell);
  padding: var(--p-space-150) 0;
  vertical-align: middle;
}

.TableCell-first+.TableCell {
  /* stylelint-disable-next-line -- generated by polaris-migrator DO NOT COPY */
  left: var(--pc-checkbox-offset);
}

.Table-sticky,
.StickyTable {

  /* stylelint-disable-next-line selector-max-combinators, selector-max-class -- generated by polaris-migrator DO NOT COPY */
  .TableCell-first+.TableCell {
    @media (--p-breakpoints-sm-up) {
      position: sticky;
      /* stylelint-disable-next-line -- generated by polaris-migrator DO NOT COPY */
      z-index: var(--pc-index-table-sticky-cell);
    }
  }

  .TableHeading-second {
    &:not(.TableHeading-unselectable) {
      @media (--p-breakpoints-sm-up) {
        position: sticky;
        left: 0;
        /* stylelint-disable-next-line -- second column (first heading item) overlaps other headings on horizontal scroll */
        z-index: var(--pc-index-table-sticky-cell);
      }
    }

    /* stylelint-disable-next-line selector-max-class -- generated by polaris-migrator DO NOT COPY */
    &.TableHeading-unselectable {
      position: sticky;
      left: 0;
      /* stylelint-disable-next-line -- second column (first heading item) overlaps other headings on horizontal scroll */
      z-index: var(--pc-index-table-sticky-cell);
    }
  }
}

.Table-unselectable {
  /* for a consistency we calculate indentation for nested rows the same way as for selectable table */
  /* stylelint-disable -- Polaris component custom properties */
  --pc-index-table-checkbox-width: var(--p-space-500);
  /* checkbox width is bigger for 2px for small devices */
  --pc-index-table-checkbox-width-sm: calc(var(--pc-index-table-checkbox-width) + var(--p-width-050));
  --pc-index-table-checkbox-padding-left: var(--p-space-300);
  --pc-index-table-checkbox-child-offset: calc(var(--pc-index-table-checkbox-width) + var(--pc-index-table-checkbox-padding-left));
  --pc-index-table-checkbox-child-offset-sm: calc(var(--pc-index-table-checkbox-width-sm) + var(--pc-index-table-checkbox-padding-left));

  /* stylelint-enable -- Polaris component custom properties */
  &.Table-sticky {

    /* stylelint-disable-next-line selector-max-class, selector-max-specificity -- makes first column sticky when table is unselectable */
    .TableCell:first-child {
      left: 0;
      background-color: var(--p-color-bg-surface);
      /* stylelint-disable-next-line -- first column (checkbox) overlaps other headings on horizontal scroll */
      z-index: var(--pc-index-table-sticky-cell);
      position: sticky;
    }

    /* stylelint-disable-next-line selector-max-class -- makes first column background secondary for subheader row type */
    .TableRow-subheader {

      /* stylelint-disable-next-line selector-max-combinators, selector-max-class, selector-max-specificity -- makes first column background secondary for subheader row type */
      .TableCell:first-child {
        background-color: var(--p-color-bg-surface-secondary);
      }
    }
  }

  /* stylelint-disable -- Polaris component custom properties */
  &.Table-sticky .TableRow-child .TableCell:first-child {
    padding-left: var(--pc-index-table-checkbox-child-offset);

    @media (--p-breakpoints-sm-down) {
      padding-left: var(--pc-index-table-checkbox-child-offset-sm);
    }
  }

  .TableRow-child .TableCell {
    &:not(.TableCell-flush) {
      &:first-child {
        padding-left: var(--pc-index-table-checkbox-child-offset);
      }
    }
  }

  /* stylelint-enable -- Polaris component custom properties */

  .TableRow-hovered:not(.TableRow-disabled) {

    /* stylelint-disable-next-line selector-max-combinators, selector-max-class, selector-max-specificity, selector-max-compound-selectors -- generated by polaris-migrator DO NOT COPY */
    &,
    .TableCell:first-child,
    .TableCell-first,
    .TableCell-first+.TableCell,
    .TableCell:last-child {
      background-color: var(--p-color-bg-surface-hover);
    }

    /* stylelint-disable-next-line selector-max-class, selector-max-specificity -- fixed hover state for nonselected indexTable */
    &.toneSuccess {

      /* stylelint-disable-next-line selector-max-combinators, selector-max-class, selector-max-specificity, selector-max-compound-selectors -- fixed hover state for nonselected indexTable */
      &,
      .TableCell:first-child,
      .TableCell-first,
      .TableCell-first+.TableCell,
      .TableCell:last-child {
        background-color: var(--p-color-bg-surface-success-hover);
      }
    }

    /* stylelint-disable-next-line selector-max-class, selector-max-specificity -- fixed hover state for nonselected indexTable */
    &.toneWarning {

      /* stylelint-disable-next-line selector-max-combinators, selector-max-class, selector-max-specificity, selector-max-compound-selectors -- fixed hover state for nonselected indexTable */
      &,
      .TableCell:first-child,
      .TableCell-first,
      .TableCell-first+.TableCell,
      .TableCell:last-child {
        background-color: var(--p-color-bg-surface-warning-hover);
      }
    }

    /* stylelint-disable-next-line selector-max-class, selector-max-specificity -- fixed hover state for nonselected indexTable */
    &.toneCritical {

      /* stylelint-disable-next-line selector-max-combinators, selector-max-class, selector-max-specificity, selector-max-compound-selectors -- fixed hover state for nonselected indexTable */
      &,
      .TableCell:first-child,
      .TableCell-first,
      .TableCell-first+.TableCell,
      .TableCell:last-child {
        background-color: var(--p-color-bg-surface-critical-hover);
      }
    }

    /* stylelint-disable-next-line selector-max-class, selector-max-specificity -- fixed hover state for nonselected indexTable */
    &.toneSubdued {

      /* stylelint-disable-next-line selector-max-combinators, selector-max-class, selector-max-specificity, selector-max-compound-selectors -- fixed hover state for nonselected indexTable */
      &,
      .TableCell:first-child,
      .TableCell-first,
      .TableCell-first+.TableCell,
      .TableCell:last-child {
        background-color: var(--p-color-bg-surface-secondary-hover);
      }
    }

    /* stylelint-disable-next-line selector-max-class, selector-max-specificity -- fixed hover state for nonselected indexTable */
    &.TableRow-subheader {

      /* stylelint-disable-next-line selector-max-class, selector-max-combinators, selector-max-specificity, selector-max-compound-selectors -- fixed hover state for nonselected indexTable */
      &,
      .TableCell:first-child,
      .TableCell-first,
      .TableCell-first+.TableCell,
      .TableCell:last-child {
        background-color: var(--p-color-bg-surface-secondary);
      }
    }
  }

  .toneSuccess {

    /* stylelint-disable-next-line selector-max-combinators, selector-max-class, selector-max-specificity -- generated by polaris-migrator DO NOT COPY */
    .TableCell:first-child {
      background-color: var(--p-color-bg-surface-success);
    }
  }

  .toneWarning {

    /* stylelint-disable-next-line selector-max-combinators, selector-max-class, selector-max-specificity -- generated by polaris-migrator DO NOT COPY */
    .TableCell:first-child {
      background-color: var(--p-color-bg-surface-warning);
    }
  }

  .toneCritical {

    /* stylelint-disable-next-line selector-max-combinators, selector-max-class, selector-max-specificity -- added crtical tone for suspended products */
    .TableCell:first-child {
      background-color: var(--p-color-bg-surface-critical);
    }
  }

  .toneSubdued {

    /* stylelint-disable-next-line selector-max-combinators, selector-max-class, selector-max-specificity -- generated by polaris-migrator DO NOT COPY */
    .TableCell:first-child {
      background-color: var(--p-color-bg-surface-secondary);
      color: var(--p-color-text-secondary);
    }
  }
}

.Table-sticky-scrolling,
.StickyTableHeader-sticky-scrolling {

  .TableCell:last-child,
  .TableHeading-last {
    @media (--p-breakpoints-sm-up) {
      filter: drop-shadow(-1px 0 0 var(--p-color-border));
    }
  }
}

.Table-sticky-last,
.StickyTableHeader-sticky-last {
  .TableCell:last-child {
    @media (--p-breakpoints-sm-up) {
      position: sticky;
      right: 0;
      background-color: var(--p-color-bg-surface);
      /* stylelint-disable-next-line -- generated by polaris-migrator DO NOT COPY */
      z-index: var(--pc-index-table-sticky-cell);
    }
  }

  .TableHeading-last {
    @media (--p-breakpoints-sm-up) {
      position: sticky;
      right: 0;
      background-color: var(--p-color-bg-surface-secondary);
      /* stylelint-disable-next-line -- generated by polaris-migrator DO NOT COPY */
      z-index: auto;
    }
  }
}

.Table-sortable {
  .TableHeading {
    background-color: var(--p-color-bg-surface-secondary);
  }
}

.StickyTable {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  visibility: hidden;
  /* stylelint-disable-next-line -- generated by polaris-migrator DO NOT COPY */
  z-index: var(--pc-index-table-loading-panel);
}

.StickyTableHeader {
  position: absolute;
  display: flex;
  width: 100%;

  &:not(.StickyTableHeader-isSticky) {
    top: -1000px;
    left: -1000px;
  }
}

.StickyTableHeadings {
  overflow: hidden;
  flex: 1 1 auto;
  display: flex;
}

.StickyTableHeading-second {
  padding-left: 0;

  @media (--p-breakpoints-sm-up) {
    display: none;
  }

  &.unselectable {
    display: none;
  }
}

.StickyTableHeading-second-scrolling {
  /* stylelint-disable-next-line -- Polaris custom property */
  padding: 0 var(--p-space-025) 0 calc(var(--pc-index-table-checkbox-offset-right) + var(--pc-index-table-heading-padding-x));
  display: none;

  @media (--p-breakpoints-sm-up) {
    display: block;
  }
}

.StickyTableHeader-isSticky {
  visibility: visible;
  box-shadow: var(--p-shadow-100);
  background-color: var(--p-color-bg-surface-secondary);
}

.IndexTable:hover {
  .ScrollLeft {
    display: block;
  }

  .ScrollRight {
    display: block;
  }
}

.IndexTable .ScrollRight-onboarding {
  display: block;
}

.SelectAllActionsWrapper {
  visibility: visible;
  position: absolute;
  /* stylelint-disable-next-line -- generated by polaris-migrator DO NOT COPY */
  z-index: var(--pc-index-table-bulk-actions);
  left: 0;
  width: 100%;
  display: flex;
  align-items: center;
  justify-content: flex-start;
}

.SelectAllActionsWrapperWithPagination {
  width: 100%;

  @media (--p-breakpoints-md-up) {
    width: calc(100% - 56px - var(--p-space-200));
  }
}

.SelectAllActionsWrapperSticky {
  position: fixed;
  top: auto;
  bottom: 0;
}

.SelectAllActionsWrapperAtEnd {
  opacity: 0;
  transition: opacity var(--p-motion-duration-100) var(--p-motion-ease);
}

.SelectAllActionsWrapperAtEndAppear {
  opacity: 1;
}

.BulkActionsWrapper {
  visibility: hidden;
  opacity: 0;
  position: relative;
  /* stylelint-disable-next-line -- generated by polaris-migrator DO NOT COPY */
  z-index: var(--pc-index-table-bulk-actions);
  padding: var(--p-space-150) var(--p-space-200) var(--p-space-150) var(--p-space-300);
  line-height: var(--p-font-line-height-500);
  background-color: var(--p-color-bg-surface);
  transition: opacity var(--p-motion-duration-100) var(--p-motion-ease),
    visibility var(--p-motion-duration-100) var(--p-motion-ease);

  &.BulkActionsWrapperVisible {
    visibility: visible;
    opacity: 1;
  }
}

.PaginationWrapper {
  /* stylelint-disable-next-line -- custom z index to work with the z-indexes in the IndexTable */
  --pc-pagination-index: 30;
  /* stylelint-disable-next-line -- sets the z-index created above */
  z-index: var(--pc-pagination-index);

  @media (--p-breakpoints-md-up) {
    position: sticky;
    bottom: 0;
  }
}

.PaginationWrapperScrolledPastTop {
  @media (--p-breakpoints-md-up) {
    position: absolute;
    bottom: auto;
    /* stylelint-disable-next-line -- set from the use-is-select-all-actions-sticky hook */
    top: var(--pc-index-table-pagination-top-offset);
    width: 100%;
  }
}

.ScrollBarContainer {
  /* stylelint-disable-next-line -- Polaris component custom properties */
  --pc-index-table-scroll-bar: 30;
  /* stylelint-disable-next-line -- Polaris component custom properties */
  --pc-index-table-scroll-bar-height-offset: 41px;
  position: sticky;
  /* stylelint-disable-next-line -- generated by polaris-migrator DO NOT COPY */
  z-index: var(--pc-index-table-scroll-bar);
  bottom: 0;
  padding: var(--p-space-050);
  background-color: var(--p-color-bg-surface);
  transition: bottom var(--p-motion-duration-100) var(--p-motion-ease);

  @media (--p-breakpoints-sm-up) {
    border-bottom-right-radius: var(--p-border-radius-200);
    border-bottom-left-radius: var(--p-border-radius-200);
    padding: var(--p-space-050) var(--p-space-200);
  }
}

.ScrollBarContainerWithPagination {
  @media (--p-breakpoints-md-up) {
    /* stylelint-disable-next-line -- Polaris component custom properties */
    bottom: var(--pc-index-table-scroll-bar-height-offset);

    &.ScrollBarContainerScrolledPastTop {
      position: absolute;
      /* stylelint-disable-next-line -- set from the use-is-select-all-actions-sticky hook */
      top: var(--pc-index-table-scroll-bar-top-offset);
      bottom: auto;
      width: 100%;
    }
  }

  @media (--p-breakpoints-sm-up) {
    border-bottom-right-radius: 0;
    border-bottom-left-radius: 0;
  }

  &.ScrollBarContainerWithSelectAllActions {
    /* stylelint-disable-next-line -- Polaris component custom properties */
    bottom: var(--pc-index-table-scroll-bar-height-offset);
  }
}

.ScrollBarContainerWithSelectAllActions {
  &.ScrollBarContainerScrolledPastTop {
    position: absolute;
    /* stylelint-disable-next-line -- set from the use-is-select-all-actions-sticky hook */
    top: var(--pc-index-table-scroll-bar-top-offset);
    bottom: auto;
    width: 100%;
  }

  @media (--p-breakpoints-sm-up) {
    border-bottom-right-radius: 0;
    border-bottom-left-radius: 0;
  }
}

.ScrollBarContainerSelectAllActionsSticky {
  /* stylelint-disable-next-line -- Polaris component custom properties */
  bottom: var(--pc-index-table-scroll-bar-height-offset);
}

.scrollBarContainerCondensed {
  visibility: hidden;
  pointer-events: none;
}

.scrollBarContainerHidden {
  height: 0;
  padding: 0;
}

.ScrollBar {
  overflow-x: scroll;
  width: 100%;
  margin: 0;
  padding: 0;
}

.ScrollBar::-webkit-scrollbar-track {
  border-radius: var(--p-border-radius-100);
  background-color: transparent;
}

.ScrollBar::-webkit-scrollbar {
  appearance: none;
  height: var(--p-space-200);
  width: var(--p-space-200);
  background-color: transparent;
}

.ScrollBar::-webkit-scrollbar-thumb {
  border-radius: var(--p-border-radius-100);
  background-color: var(--p-color-border-tertiary);
  transition: background-color var(--p-motion-duration-100) var(--p-motion-ease-out);
}

.ScrollBar:hover::-webkit-scrollbar-thumb {
  background-color: var(--p-color-border-inverse);
}

.disableTextSelection {
  user-select: none;
}

.EmptySearchResultWrapper {
  padding: var(--p-space-400);
}

.condensedRow {
  /* stylelint-disable-next-line -- generated by polaris-migrator DO NOT COPY */
  width: calc(100% + var(--pc-index-table-translate-offset));
  /* stylelint-disable-next-line -- generated by polaris-migrator DO NOT COPY */
  transform: translateX(calc(-1 * var(--pc-index-table-translate-offset)));
  transition: transform var(--p-motion-ease) var(--p-motion-duration-200);
  display: flex;
  border-top: var(--p-border-width-025) solid var(--p-color-border-secondary);
  filter: none;
  align-items: center;
}

[data-selectmode='true'] {
  .condensedRow {
    transform: none;
  }
}

.CondensedList {
  list-style-type: none;
  margin: 0;
  padding: 0;
  overflow: hidden;
  border-top: 0;

  .TableRow:first-child {
    border-top: 0;
  }
}

.HeaderWrapper {
  position: relative;
  display: flex;
  align-items: center;
  width: 100%;
  min-height: 56px;
  padding: var(--p-space-200) var(--p-space-400);
  background-color: var(--p-color-bg-surface);

  &.unselectable {
    min-height: auto;
    padding: 0;
  }
}

.StickyTable-condensed {
  visibility: visible;
}

.StickyTableHeader-condensed {
  padding: var(--p-space-400) var(--p-space-400) var(--p-space-200);
}

.ScrollBarContent {
  height: 1px;
  /* stylelint-disable-next-line -- generated by polaris-migrator DO NOT COPY */
  width: var(--pc-index-table-scroll-bar-content-width);
}

/* stylelint-disable-next-line polaris/motion/at-rule-disallowed-list -- custom reset animation for right-aligned header */
@keyframes right-aligned-sort-button-slide-out {
  0% {
    transform: translateX(var(--p-space-100));
  }

  80% {
    transform: translateX(var(--p-space-100));
  }

  100% {
    transform: translateX(var(--p-space-500));
  }
}

/* stylelint-disable-next-line polaris/motion/at-rule-disallowed-list -- custom animation for right-aligned header */
@keyframes reveal-right-aligned-sort-button-icon {
  0% {
    transform: translateX(calc(var(--p-space-500) * -1));
    opacity: 0;
  }

  40% {
    opacity: 0;
  }

  50% {
    transform: translateX(0);
  }

  100% {
    opacity: 1;
  }
}
```

# components/index-table/index-table.svelte

```svelte
<script lang="ts">
	import IndexProvider from '../index-provider/index-provider.svelte';
	import IndexTableBase from './index-table-base.svelte';
	import type { IndexTableProps } from './types.js';
	let {
		children,
		selectable = true,
		itemCount,
		selectedItemsCount = 0,
		resourceName: passedResourceName,
		loading,
		hasMoreItems,
		condensed = $bindable(),
		onSelectionChange,
		paginatedSelectAllText,
		...restProps
	}: IndexTableProps = $props();
</script>

<IndexProvider
	selectable={selectable && !condensed}
	{itemCount}
	{selectedItemsCount}
	resourceName={passedResourceName}
	{loading}
	{hasMoreItems}
	{condensed}
	{onSelectionChange}
	{paginatedSelectAllText}
>
	<IndexTableBase {...restProps}>
		{@render children?.()}
	</IndexTableBase>
</IndexProvider>

```

# components/index-table/index.ts

```ts
import IndexTableComponent from './index-table.svelte';
import RowComponent from './components/row/row.svelte';
import CellComponent from './components/cell/cell.svelte';

type IndexTableCompoundType = typeof IndexTableComponent & {
	Row: typeof RowComponent;
	Cell: typeof CellComponent;
};

const IndexTable = IndexTableComponent as IndexTableCompoundType;
IndexTable.Row = RowComponent;
IndexTable.Cell = CellComponent;

export default IndexTable;
```

# components/index-table/render-heading-content.svelte

```svelte
<script lang="ts">
	import type { TooltipOverlayProps } from '../tooltip/components/tooltip-overlay/types.js';
	import type { BorderRadius, Padding } from '../tooltip/types.js';
	import type { IndexTableBaseProps, IndexTableHeading, IndexTableSortDirection } from './types.js';
	import Text from '../text/text.svelte';
	import InlineStack from '../inline-stack/inline-stack.svelte';
	import Badge from '../badge/badge.svelte';
	import { applyStyles, classNames } from '$utilities/css.js';
	import styles from './index-table.module.css';
	import Tooltip from '../tooltip/tooltip.svelte';
	import UnstyledButton from '../button/unstyled-button.svelte';
	import SortAscendingIcon from '@shopify/polaris-icons/dist/svg/SortAscendingIcon.svg?component';
	import SortDescendingIcon from '@shopify/polaris-icons/dist/svg/SortDescendingIcon.svg?component';
	import { useContext } from '$utilities/contexts.js';
	import { INDEX_CONTEXT_KEY } from '$utilities/index-provider/hooks.js';
	import type { IndexContextType } from '$utilities/index-provider/context.js';

	interface Props {
		heading: IndexTableHeading;
		index: number;
		sortColumnIndex?: IndexTableBaseProps['sortColumnIndex'];
		onSort?: IndexTableBaseProps['onSort'];
		sortDirection?: IndexTableBaseProps['sortDirection'];
		defaultSortDirection?: IndexTableBaseProps['defaultSortDirection'];
		sortToggleLabels?: IndexTableBaseProps['sortToggleLabels'];
		selectable?: IndexTableBaseProps['selectable'];
		sortable?: IndexTableBaseProps['sortable'];
	}

	let {
		heading,
		index,
		sortColumnIndex,
		onSort,
		sortDirection,
		defaultSortDirection = 'descending',
		sortToggleLabels,
		sortable
	}: Props = $props();
	let renderAfterSelectEvent = $state(false);
	let hasSelected = $state(false);
	let lastSortedColumnIndex = $state<number | undefined>(sortColumnIndex);
	let newDirection: IndexTableSortDirection = heading.defaultSortDirection ?? defaultSortDirection;

	const defaultTooltipProps = $derived({
		width: heading.tooltipWidth ?? 'default',
		activatorWrapper: 'div',
		dismissOnMouseOut: true,
		persistOnClick: heading.tooltipPersistsOnClick
	});

	const defaultHeaderTooltipProps = $derived({
		...defaultTooltipProps,
		padding: '400' as Padding,
		borderRadius: '200' as BorderRadius,
		content: heading.tooltipContent ?? '',
		preferredPosition: 'above' as TooltipOverlayProps['preferredPosition']
	});

	const style = $derived({
		'--pc-index-table-heading-extra-padding-right': heading.paddingBlockEnd
			? `var(--p-space-${heading.paddingBlockEnd})`
			: '0'
	});

	function handleSortHeadingClick(index: number, direction: IndexTableSortDirection) {
		renderAfterSelectEvent = false;
		hasSelected = false;
		lastSortedColumnIndex = sortColumnIndex;
		onSort?.(index, direction);
	}

	const useIndexValue = useContext<IndexContextType>(INDEX_CONTEXT_KEY);
	const {
		loading,
		bulkSelectState,
		resourceName,
		bulkActionsAccessibilityLabel,
		selectMode,
		selectable,
		paginatedSelectAllText,
		itemCount,
		hasMoreItems,
		selectedItemsCount,
		condensed
	} = $derived(useIndexValue());
	const isCurrentlySorted = index === sortColumnIndex;
	const tooltipDirection = isCurrentlySorted ? sortDirection! : newDirection;
	const sortTooltipContent = sortToggleLabels?.[index][tooltipDirection];
	const isPreviouslySorted = $derived(!isCurrentlySorted && index === lastSortedColumnIndex);
	const isRenderAfterSelectEvent = $derived(
		renderAfterSelectEvent || (!hasSelected && selectedItemsCount !== 0)
	);

	const defaultSortButtonProps = $derived({
		onClick: () => handleSortHeadingClick(index, newDirection),
		className: classNames(
			styles.TableHeadingSortButton,
			!isCurrentlySorted &&
				heading?.alignment === 'end' &&
				styles['TableHeadingSortButton-heading-align-end'],
			isCurrentlySorted &&
				heading?.alignment === 'end' &&
				styles['TableHeadingSortButton-heading-align-end-currently-sorted'],
			isPreviouslySorted &&
				!isRenderAfterSelectEvent &&
				heading?.alignment === 'end' &&
				styles['TableHeadingSortButton-heading-align-end-previously-sorted']
		),
		tabIndex: selectMode ? -1 : 0
	});

	const isAscending = sortDirection === 'ascending';

	let SourceComponent = $derived.by(() => {
		let component = newDirection === 'ascending' ? SortAscendingIcon : SortDescendingIcon;
		if (isCurrentlySorted) {
			newDirection = isAscending ? 'descending' : 'ascending';
			component = sortDirection === 'ascending' ? SortAscendingIcon : SortDescendingIcon;
		}
		return component;
	});
</script>

{#snippet headingTitle()}
	<Text as="span" variant="bodySm" fontWeight="medium" visuallyHidden={heading.hidden}>
		{heading.title}
	</Text>
{/snippet}

{#snippet headingContent()}
	{#if heading.new}
		<InlineStack wrap={false} align="center">
			{@render headingTitle()}
			<Badge tone="new">New</Badge>
		</InlineStack>
	{:else}
		{@render headingTitle()}
	{/if}
{/snippet}

{#snippet iconMarkup()}
	<span
		class={classNames(
			styles.TableHeadingSortIcon,
			heading?.alignment === 'end' && styles['TableHeadingSortIcon-heading-align-end'],
			isCurrentlySorted && styles['TableHeadingSortIcon-visible']
		)}
	>
		<SourceComponent focusable="false" aria-hidden="true" className={styles.TableHeadingSortSvg} />
	</span>
{/snippet}

{#snippet sortMarkup()}
	<UnstyledButton {...defaultSortButtonProps}>
		{@render iconMarkup()}
		<span
			class={classNames(
				sortToggleLabels &&
					selectMode &&
					heading.tooltipContent &&
					styles.TableHeadingTooltipUnderlinePlaceholder
			)}
		>
			{@render headingContent()}
		</span>
	</UnstyledButton>
{/snippet}

{#if sortable?.[index]}
	{#if !sortToggleLabels || selectMode}
		<div class={styles.SortableTableHeadingWithCustomMarkup}>
			{@render sortMarkup()}
		</div>
	{:else if !heading.tooltipContent}
		{#if sortTooltipContent}
			<div
				style={applyStyles(style)}
				class={classNames(heading.paddingBlockEnd && styles['TableHeading-extra-padding-right'])}
			>
				<Tooltip {...defaultTooltipProps} content={sortTooltipContent} preferredPosition="above">
					{@render sortMarkup()}
				</Tooltip>
			</div>
		{/if}
	{:else}
		<div
			class={classNames(
				styles.SortableTableHeadingWithCustomMarkup,
				heading.paddingBlockEnd && styles['TableHeading-extra-padding-right']
			)}
			style={applyStyles(style)}
		>
			<UnstyledButton {...defaultSortButtonProps}>
				<Tooltip {...defaultHeaderTooltipProps}>
					<span class={styles.TableHeadingUnderline}>
						{@render headingContent()}
					</span>
				</Tooltip>

				{#if sortTooltipContent}
					<Tooltip {...defaultTooltipProps} content={sortTooltipContent} preferredPosition="above">
						{@render iconMarkup()}
					</Tooltip>
				{/if}
			</UnstyledButton>
		</div>
	{/if}
{:else if heading.tooltipContent}
	<div
		style={applyStyles(style)}
		class={classNames(heading.paddingBlockEnd && styles['TableHeading-extra-padding-right'])}
	>
		<Tooltip {...defaultHeaderTooltipProps} activatorWrapper="span">
			<span class={classNames(styles.TableHeadingUnderline, styles.SortableTableHeaderWrapper)}>
				{@render headingContent()}
			</span>
		</Tooltip>
	</div>
{:else}
	<div
		style={applyStyles(style)}
		class={classNames(heading.paddingBlockEnd && styles['TableHeading-extra-padding-right'])}
	>
		{@render headingContent()}
	</div>
{/if}

```

# components/index-table/render-heading.svelte

```svelte
<script lang="ts">
	import { applyStyles, classNames } from '$utilities/css.js';
	import type { NonEmptyArray } from '$utilities/types.js';
	import RenderHeadingContent from './render-heading-content.svelte';
	import type { IndexTableBaseProps, IndexTableHeading, TableHeadingRect } from './types.js';
	import styles from './index-table.module.css';
	import Checkbox from '../checkbox/checkbox.svelte';
	import type { IndexContextType } from '$utilities/index-provider/context.js';
	import { SelectionType, type HandleSelectionChange } from '$utilities/index-provider/types.js';
	import { useContext } from '$utilities/contexts.js';
	import { INDEX_SELECTION_CHANGE_CONTEXT_KEY } from '$utilities/index-provider/hooks.js';

	interface Props extends IndexContextType {
		heading: IndexTableHeading;
		index: number;
		Tag: any;
		tagProps: { [x: string]: unknown };
		id?: string;
		headings: NonEmptyArray<IndexTableHeading>;
		sortable?: IndexTableBaseProps['sortable'];
		selectable?: IndexTableBaseProps['selectable'];
		sortColumnIndex?: IndexTableBaseProps['sortColumnIndex'];
		onSort?: IndexTableBaseProps['onSort'];
		sortDirection?: IndexTableBaseProps['sortDirection'];
		defaultSortDirection?: IndexTableBaseProps['defaultSortDirection'];
		sortToggleLabels?: IndexTableBaseProps['sortToggleLabels'];
	}

	let {
		heading,
		index,
		Tag,
		tagProps,
		id,
		headings,
		sortable,
		selectable,
		sortColumnIndex,
		onSort,
		sortDirection,
		defaultSortDirection,
		sortToggleLabels,
		resourceName,
		bulkSelectState
	}: Props = $props();

	let tableHeadingRects = $state<TableHeadingRect[]>([]);
	const isSecond = index === 0;
	const isLast = index === headings.length - 1;
	const hasSortable = sortable?.some((value) => value === true);
	const headingAlignment = heading.alignment || 'start';
	const headingContentClassName = classNames(
		styles.TableHeading,
		headingAlignment === 'center' && styles['TableHeading-align-center'],
		headingAlignment === 'end' && styles['TableHeading-align-end'],
		hasSortable && styles['TableHeading-sortable'],
		isSecond && styles['TableHeading-second'],
		isLast && !heading.hidden && styles['TableHeading-last'],
		!selectable && styles['TableHeading-unselectable'],
		heading.flush && styles['TableHeading-flush']
	);

	const stickyPositioningStyle =
		selectable !== false && isSecond && tableHeadingRects && tableHeadingRects.length > 0
			? { left: tableHeadingRects[0].offsetWidth }
			: undefined;

	const checkboxClassName = $derived(
		classNames(styles.TableHeading, hasSortable && styles['TableHeading-sortable'], index === 0 && styles['TableHeading-first'])
	);

	const useIndexSelectionChange = useContext<HandleSelectionChange>(INDEX_SELECTION_CHANGE_CONTEXT_KEY);
	const handleSelectionChange = $derived(useIndexSelectionChange());

	function handleSelectPage(checked: boolean) {
		handleSelectionChange(SelectionType.Page, checked);
	}

</script>

{#snippet headingContent()}
	<svelte:element
		this={Tag}
		{id}
		class={headingContentClassName}
		style={applyStyles(stickyPositioningStyle)}
		{...tagProps}
	>
		<RenderHeadingContent
			{heading}
			{index}
			{sortColumnIndex}
			{onSort}
			{sortDirection}
			{defaultSortDirection}
			{sortToggleLabels}
			{selectable}
			{sortable}
		/>
	</svelte:element>
{/snippet}

{#snippet renderCheckboxContent()}
	<div class={styles.ColumnHeaderCheckboxWrapper}>
		<Checkbox
			label={`Select all ${resourceName.plural}`}
			labelHidden
			onChange={handleSelectPage}
			checked={bulkSelectState}
		/>
	</div>
{/snippet}

{#snippet checkboxContent()}
	<svelte:element this={Tag} class={checkboxClassName} {...tagProps}>
		{@render renderCheckboxContent()}
	</svelte:element>
{/snippet}

{#if index !== 0 || !selectable}
	{@render headingContent()}
{:else}
	{@render checkboxContent()}
	{@render headingContent()}
{/if}

```

# components/index-table/types.ts

```ts
import type { Snippet } from "svelte";
import type { Width } from "../tooltip/types.js";
import type { SpaceScale } from "@shopify/polaris-tokens";
import type { NonEmptyArray } from "$utilities/types.js";
import type { PaginationProps } from "../pagination/types.js";
import type { BulkActionsProps } from "../bulk-actions/types.js";
import type { IndexProviderProps } from "$utilities/index-provider/types.js";

interface IndexTableHeadingBase {
    id?: string;
    /**
     * Adjust horizontal alignment of header content.
     * @default 'start'
     */
    alignment?: 'start' | 'center' | 'end';
    flush?: boolean;
    new?: boolean;
    hidden?: boolean;
    tooltipContent?: Snippet;
    tooltipWidth?: Width;
    tooltipPersistsOnClick?: boolean;
    /**
     * The direction to sort the table rows on first click or keypress of this column heading.
     * When not specified, the value from IndexTable.defaultSortDirection will be used.
     */
    defaultSortDirection?: IndexTableSortDirection;
    /** Horizontal end spacing around title. Accepts a spacing token. */
    paddingBlockEnd?: SpaceScale;
}

interface IndexTableHeadingTitleString extends IndexTableHeadingBase {
    title: string;
    id?: string;
}

interface IndexTableHeadingTitleNode extends IndexTableHeadingBase {
    title: Snippet;
    id: string;
}

export type IndexTableHeading =
    | IndexTableHeadingTitleString
    | IndexTableHeadingTitleNode;

export type IndexTableSortDirection = 'ascending' | 'descending';

type IndexTableSortToggleLabel = {
    [key in IndexTableSortDirection]: string;
};

interface IndexTableSortToggleLabels {
    [key: number]: IndexTableSortToggleLabel;
}

export type IndexTablePaginationProps = Omit<PaginationProps, 'type'>;

export interface IndexTableBaseProps {
    headings: NonEmptyArray<IndexTableHeading>;
    promotedBulkActions?: BulkActionsProps['promotedActions'];
    bulkActions?: BulkActionsProps['actions'];
    children?: Snippet;
    emptyState?: Snippet;
    sort?: Snippet;
    paginatedSelectAllActionText?: string;
    paginatedSelectAllText?: string;
    lastColumnSticky?: boolean;
    selectable?: boolean;
    /** List of booleans, which maps to whether sorting is enabled or not for each column. Defaults to false for all columns.  */
    sortable?: boolean[];
    /**
     * The direction to sort the table rows on first click or keypress of a sortable column heading. Defaults to descending.
     * @default 'descending'
     */
    defaultSortDirection?: IndexTableSortDirection;
    /** The current sorting direction. */
    sortDirection?: IndexTableSortDirection;
    /**
     * The index of the heading that the table rows are sorted by.
     */
    sortColumnIndex?: number;
    /** Callback fired on click or keypress of a sortable column heading. */
    onSort?(headingIndex: number, direction: IndexTableSortDirection): void;
    /** Optional dictionary of sort toggle labels for each sortable column, with ascending and descending label,
     * with the key as the index of the column */
    sortToggleLabels?: IndexTableSortToggleLabels;
    /** Add zebra striping to table rows */
    hasZebraStriping?: boolean;
    /** Properties to enable pagination at the bottom of the table. */
    pagination?: IndexTablePaginationProps;
    isSticky?: boolean;
}

export interface TableHeadingRect {
    offsetWidth: number;
    offsetLeft: number;
}

export const SCROLL_BAR_PADDING = 16;
export const SCROLL_BAR_DEBOUNCE_PERIOD = 300;

export interface IndexTableProps extends IndexTableBaseProps, IndexProviderProps {}
```

# components/index-table/utilities/utilities.ts

```ts
export function getTableHeadingsBySelector(
    wrapperElement: HTMLElement | null,
    selector: string,
) {
    return wrapperElement
        ? Array.from(wrapperElement.querySelectorAll<HTMLElement>(selector))
        : [];
}
```

# components/indicator/indicator.module.css

```css
.Indicator {
  /* stylelint-disable -- Polaris component custom properties */
  --pc-indicator-size: 10px;
  --pc-indicator-base-position: calc(-1 * var(--p-space-100));
  /* stylelint-enable */

  &::before,
  &::after {
    content: '';
    position: absolute;
    background-color: var(--p-color-border-info);
    /* stylelint-disable-next-line -- generated by polaris-migrator DO NOT COPY */
    right: var(--pc-indicator-base-position);
    /* stylelint-disable-next-line -- generated by polaris-migrator DO NOT COPY */
    top: var(--pc-indicator-base-position);
    /* stylelint-disable-next-line -- generated by polaris-migrator DO NOT COPY */
    width: var(--pc-indicator-size);
    /* stylelint-disable-next-line -- generated by polaris-migrator DO NOT COPY */
    height: var(--pc-indicator-size);
    border-radius: var(--p-border-radius-full);
    /* stylelint-disable-next-line -- generated by polaris-migrator DO NOT COPY */
    border: calc(var(--pc-indicator-size) / 2) solid transparent;
  }
}

.pulseIndicator::before {
  /* stylelint-disable-next-line -- generated by polaris-migrator DO NOT COPY */
  z-index: 1;
  animation: var(--p-motion-keyframes-bounce) var(--p-motion-duration-5000) ease infinite;
}

.pulseIndicator::after {
  /* stylelint-disable-next-line -- generated by polaris-migrator DO NOT COPY */
  right: var(--pc-indicator-base-position);
  /* stylelint-disable-next-line -- generated by polaris-migrator DO NOT COPY */
  top: var(--pc-indicator-base-position);
  animation: var(--p-motion-keyframes-pulse) var(--p-motion-duration-5000) ease infinite;
}
```

# components/indicator/indicator.svelte

```svelte
<script lang="ts">
	import { classNames } from '$utilities/css.js';
	import styles from './indicator.module.css';
	import type { IndicatorProps } from './types.js';

	let { pulse }: IndicatorProps = $props();

	const className = $derived(classNames(styles.Indicator, pulse && styles.pulseIndicator));
</script>

<span class={className}></span>

```

# components/indicator/types.ts

```ts
export interface IndicatorProps {
    pulse?: boolean;
}
```

# components/inline-error/inline-error.module.css

```css
.InlineError {
  display: flex;
  color: var(--p-color-text-critical);
  fill: var(--p-color-text-critical);
}

.Icon {
  fill: var(--p-color-text-critical);
  margin-left: calc(-1 * var(--p-space-100));
  margin-right: var(--p-space-200);

  svg {
    margin-left: var(--p-space-050);
    margin-right: var(--p-space-050);
  }
}
```

# components/inline-error/inline-error.svelte

```svelte
<script lang="ts">
	import Icon from '../icon/icon.svelte';
	import styles from './inline-error.module.css';
	import AlertCircleIcon from '@shopify/polaris-icons/dist/svg/AlertCircleIcon.svg?component';
	import Text from '../text/text.svelte';
	import { errorTextID, type InlineErrorProps } from './types.js';
	let { message, fieldID }: InlineErrorProps = $props();
</script>

{#if message}
	<div id={errorTextID(fieldID)} class={styles.InlineError}>
		<div class={styles.Icon}>
			<Icon source={AlertCircleIcon} />
		</div>
		<Text as="span" variant="bodyMd">
			{message}
		</Text>
	</div>
{/if}

```

# components/inline-error/types.ts

```ts
import type { Error } from "$utilities/types.js";

export interface InlineErrorProps {
  /** Content briefly explaining how to resolve the invalid form field input. */
  message: Error;
  /** Unique identifier of the invalid form field that the message describes */
  fieldID: string;
}

export function errorTextID(id: string) {
  return `${id}Error`;
}
```

# components/inline-grid/inline-grid.module.css

```css
.InlineGrid {
  @mixin responsive-props inline-grid, gap, gap;
  @mixin responsive-props inline-grid, grid-template-columns,
  grid-template-columns;

  /* stylelint-disable -- Polaris component custom properties */
  --pc-inline-grid-align-items: initial;
  /* stylelint-enable */
  display: grid;
  /* stylelint-disable-next-line -- Polaris component custom properties */
  align-items: var(--pc-inline-grid-align-items);
}
```

# components/inline-grid/inline-grid.svelte

```svelte
<script lang="ts">
	import { applyStyles, getResponsiveProps, getResponsiveValue, type ResponsiveValue } from '$utilities/css.js';
	import styles from './inline-grid.module.css';
	import type { Columns, ColumnsType, InlineGridProps } from './types.js';

	let { children, columns, gap, alignItems }: InlineGridProps = $props();

	function formatInlineGrid(columns?: Columns): ResponsiveValue {
		if (typeof columns === 'object' && columns !== null && !Array.isArray(columns)) {
			return Object.fromEntries(
				Object.entries(columns).map(([breakpointAlias, breakpointInlineGrid]) => [
					breakpointAlias,
					getColumnValue(breakpointInlineGrid)
				])
			);
		}

		return getColumnValue(columns);
	}

	function getColumnValue(columns?: ColumnsType) {
		if (!columns) return undefined;

		if (typeof columns === 'number' || !isNaN(Number(columns))) {
			return `repeat(${Number(columns)}, minmax(0, 1fr))`;
		}

		if (typeof columns === 'string') return columns;

		return columns
			.map((column) => {
				switch (column) {
					case 'oneThird':
						return 'minmax(0, 1fr)';
					case 'oneHalf':
						return 'minmax(0, 1fr)';
					case 'twoThirds':
						return 'minmax(0, 2fr)';
				}
			})
			.join(' ');
	}

	const style = $derived({
		...getResponsiveValue('inline-grid', 'grid-template-columns', formatInlineGrid(columns)),
		...getResponsiveProps('inline-grid', 'gap', 'space', gap),
		'--pc-inline-grid-align-items': alignItems
	});
</script>

<div class={styles.InlineGrid} style={applyStyles(style)}>
  {@render children?.()}
</div>

```

# components/inline-grid/types.ts

```ts
import type { ResponsiveProp } from "$utilities/css.js";
import type { SpaceScale } from "@shopify/polaris-tokens";
import type { Snippet } from "svelte";

export type ColumnsAlias = 'oneThird' | 'oneHalf' | 'twoThirds';
export type ColumnsType = number | string | ColumnsAlias[];
export type Columns = ResponsiveProp<ColumnsType>;
export type Gap = ResponsiveProp<SpaceScale>;
export type InlineGridAlignItems = 'start' | 'end' | 'center';

export interface InlineGridProps {
  children?: Snippet;
  /** The number of columns to display. Accepts either a single value or an object of values for different screen sizes.
   * @example
   * columns={6}
   * columns={{xs: 1, sm: 2, md: 3, lg: 4, xl: 6}}
   */
  columns?: Columns;
  /** The spacing between children. Accepts a spacing token or an object of spacing tokens for different screen sizes.
   * @example
   * gap='200'
   * gap={{xs: '100', sm: '200', md: '300', lg: '400', xl: '500'}}
   */
  gap?: Gap;
  /** Vertical alignment of children. If not set, inline elements will stretch to the height of the parent.
   * @example
   * alignItems='start'
   */
  alignItems?: InlineGridAlignItems;
}
```

# components/inline-stack/inline-stack.module.css

```css
.InlineStack {
  @mixin responsive-props inline-stack, gap, gap;
  @mixin responsive-props inline-stack, flex-direction, flex-direction;
  display: flex;
  /* stylelint-disable-next-line -- Necessary for layout components */
  flex-wrap: var(--pc-inline-stack-wrap);
  /* stylelint-disable-next-line -- Necessary for layout components */
  align-items: var(--pc-inline-stack-block-align);
  /* stylelint-disable-next-line -- Necessary for layout components */
  justify-content: var(--pc-inline-stack-align);
}
```

# components/inline-stack/inline-stack.svelte

```svelte
<script lang="ts">
	import { applyStyles, getResponsiveProps, getResponsiveValue } from '$utilities/css.js';
	import styles from './inline-stack.module.css';
	import type { InlineStackProps } from './types.js';
	let {
		as: Element = 'div',
		align,
		direction = 'row',
		blockAlign,
		gap,
		wrap = true,
		children
	}: InlineStackProps = $props();

	const style = $derived({
		'--pc-inline-stack-align': align,
		'--pc-inline-stack-block-align': blockAlign,
		'--pc-inline-stack-wrap': wrap ? 'wrap' : 'nowrap',
		...getResponsiveProps('inline-stack', 'gap', 'space', gap),
		...getResponsiveValue('inline-stack', 'flex-direction', direction)
	});
</script>

<svelte:element this={Element} class={styles.InlineStack} style={applyStyles(style)}>
	{@render children?.()}
</svelte:element>

```

# components/inline-stack/types.ts

```ts
import type { ResponsiveProp } from "$utilities/css.js";
import type { SpaceScale } from "@shopify/polaris-tokens";
import type { Snippet } from "svelte";

export type Align =
  | 'start'
  | 'center'
  | 'end'
  | 'space-around'
  | 'space-between'
  | 'space-evenly';
export type BlockAlign = 'start' | 'center' | 'end' | 'baseline' | 'stretch';
export type Gap = ResponsiveProp<SpaceScale>;
export type Direction = ResponsiveProp<'row' | 'row-reverse'>;
export type Element = 'div' | 'span' | 'li' | 'ol' | 'ul';
export interface InlineStackProps {
  children?: Snippet;
  /** HTML Element type
   * @default 'div'
   */
  as?: Element;
  /** Horizontal alignment of children */
  align?: Align;
  /** Horizontal direction in which children are laid out */
  direction?: Direction;
  /** Vertical alignment of children */
  blockAlign?: BlockAlign;
  /** The spacing between elements. Accepts a spacing token or an object of spacing tokens for different screen sizes.
   * @example
   * gap='200'
   * gap={{xs: '200', sm: '300', md: '400', lg: '500', xl: '600'}}
   */
  gap?: Gap;
  /** Wrap stack elements to additional rows as needed on small screens
   * @default true
   */
  wrap?: boolean;
}
```

# components/keypress-listener/keypress-listener.svelte

```svelte
<script lang="ts">
	import { onMount } from 'svelte';
	import type { KeypressListenerProps } from './types.js';
	let {
		keyCode,
		handler,
		keyEvent = 'keyup',
		options,
		useCapture,
		document: ownerDocument = globalThis.document
	}: KeypressListenerProps = $props();

	const tracked = $state({ handler, keyCode });

	const handleKeyEvent = (event: KeyboardEvent) => {
		const { handler, keyCode } = tracked;
		if (event.keyCode === keyCode) {
			handler(event);
		}
	};

	onMount(() => {
		ownerDocument.addEventListener(keyEvent, handleKeyEvent, useCapture || options);
		return () => {
			ownerDocument.removeEventListener(keyEvent, handleKeyEvent, useCapture || options);
		};
	});
</script>

```

# components/keypress-listener/types.ts

```ts
import type { Key } from "$utilities/types.js";

// Type definitions for keypress-listener
export interface NonMutuallyExclusiveProps {
    keyCode: Key;
    handler(event: KeyboardEvent): void;
    keyEvent?: KeyEvent;
    document?: Document;
}

export type KeypressListenerProps = NonMutuallyExclusiveProps &
    (
        | { useCapture?: boolean; options?: undefined }
        | { useCapture?: undefined; options?: AddEventListenerOptions }
    );

export type KeyEvent = 'keydown' | 'keyup';

```

# components/label/label.module.css

```css
.Label {
    -webkit-tap-highlight-color: transparent;
}

.hidden {
    /* stylelint-disable-next-line -- generated by polaris-migrator DO NOT COPY */
    @mixin visually-hidden;
}

.Text {
    display: block;
    flex: 1 1 auto;
    color: currentColor;
    -webkit-tap-highlight-color: transparent;
}

.RequiredIndicator::after {
    content: '*';
    color: var(--p-color-text-critical);
    margin-left: var(--p-space-100);
}
```

# components/label/label.svelte

```svelte
<script lang="ts">
	import { classNames } from '$utilities/css.js';
	import styles from './label.module.css';
	import { labelID, type LabelProps } from './types.js';
	import Text from '../text/text.svelte';
	let { children, id, hidden, requiredIndicator }: LabelProps = $props();
	const className = $derived(classNames(styles.Label, hidden && styles.hidden));
	const labelClassName = $derived(
		classNames(styles.Text, requiredIndicator && styles.RequiredIndicator)
	);
</script>

<div class={className}>
	<label {id} for={labelID(id)} class={labelClassName}>
		<Text as="span" variant="bodyMd">
			{@render children?.()}
		</Text>
	</label>
</div>

```

# components/label/types.ts

```ts
import type { Snippet } from "svelte";

export interface LabelProps {
    /** Label content */
    children?: Snippet;
    /** A unique identifier for the label */
    id: string;
    /** Visually hide the label */
    hidden?: boolean;
    /** Visual required indicator for the label */
    requiredIndicator?: boolean;
}

export function labelID(id: string) {
    return `${id}Label`;
}
```

# components/labelled/labelled.module.css

```css
.hidden>.LabelWrapper {
    /* stylelint-disable-next-line -- generated by polaris-migrator DO NOT COPY */
    @mixin visually-hidden;
}

.disabled>.LabelWrapper {
    color: var(--p-color-text-disabled);
}

/* stylelint-disable-next-line -- color override since Text component doesn't support this color token */
.disabled>.HelpText>span {
    color: var(--p-color-text-disabled);
}

.readOnly>.LabelWrapper {
    color: var(--p-color-text-secondary);
}

.LabelWrapper {
    /* stylelint-disable-next-line -- generated by polaris-migrator DO NOT COPY */
    @mixin text-breakword;
    display: flex;
    flex-wrap: wrap;
    justify-content: space-between;
    align-items: baseline;
    margin-bottom: var(--p-space-100);
}

.HelpText {
    margin-top: var(--p-space-100);
}

.Error {
    /* stylelint-disable-next-line -- generated by polaris-migrator DO NOT COPY */
    @mixin text-breakword;
    margin-top: var(--p-space-100);
}

.Action {
    flex: 0 0 auto;
}
```

# components/labelled/labelled.svelte

```svelte
<script lang="ts">
	import { classNames } from '$utilities/css.js';
	import ButtonFrom from '../button/button-from.svelte';
	import styles from './labelled.module.css';
	import type { LabelledProps } from './types.js';
	import Text from '../text/text.svelte';
	import Label from '../label/label.svelte';
	import InlineError from '../inline-error/inline-error.svelte';

	let {
		id,
		label,
		error,
		action,
		helpText,
		children,
		labelHidden,
		requiredIndicator,
		disabled,
		readOnly,
		...rest
	}: LabelledProps = $props();

	const className = $derived(
		classNames(
			labelHidden && styles.hidden,
			disabled && styles.disabled,
			readOnly && styles.readOnly
		)
	);

	const helpTextID = (id: string) => `${id}-help-text`;
</script>

{#snippet actionMarkup()}
	{#if action}
		<div class={styles.Action}>
			<ButtonFrom {action} overrides={{ variant: 'plain' }} />
		</div>
	{/if}
{/snippet}

{#snippet helpTextMarkup()}
	{#if typeof helpText === 'string'}
		<div class={styles.HelpText} id={helpTextID(id)} aria-disabled={disabled}>
			<Text as="span" tone="subdued" variant="bodyMd" breakWord>
				{helpText}
			</Text>
		</div>
	{:else}
		{@render helpText?.()}
	{/if}
{/snippet}

{#snippet errorMarkup()}
	{#if error && typeof error !== 'boolean'}
		<div class={styles.Error}>
			<InlineError message={error} fieldID={id} />
		</div>
	{/if}
{/snippet}

{#snippet labelMarkup()}
	{#if label}
		<div class={styles.LabelWrapper}>
			<Label {id} {requiredIndicator} {...rest} hidden={false}>
				{label}
			</Label>

			{@render actionMarkup()}
		</div>
	{/if}
{/snippet}

<div class={className}>
	{@render labelMarkup()}
	{@render children?.()}
	{@render errorMarkup()}
	{@render helpTextMarkup()}
</div>

```

# components/labelled/types.ts

```ts
import type { Snippet } from "svelte";
import type { LabelProps } from "../label/types.js";
import type { Action } from "$utilities/types.js";
import type { Error } from "$utilities/types.js";

export interface LabelledProps {
    /** A unique identifier for the label */
    id: LabelProps['id'];
    /** Text for the label */
    label: string;
    /** Error to display beneath the label */
    error?: Error | boolean;
    /** An action */
    action?: Action;
    /** Additional hint text to display */
    helpText?: Snippet | string;
    /** Content to display inside the connected */
    children?: Snippet;
    /** Visually hide the label */
    labelHidden?: boolean;
    /** Visual required indicator for the label */
    requiredIndicator?: boolean;
    /** Labels signify a disabled control */
    disabled?: boolean;
    /** Labels signify a readOnly control */
    readOnly?: boolean;
}
```

# components/layout/components/annotated-layout-section/annotated-layout-section.svelte

```svelte
<script lang="ts">
	import styles from '../../layout.module.css';
	import type { AnnotatedSectionProps } from '../../types.js';
	import Text from '../../../text/text.svelte';
	import Box from '../../../box/box.svelte';
	import TextContainer from '$lib/components/text-container/text-container.svelte';
	let { children, title, description, id }: AnnotatedSectionProps = $props();
</script>

{#snippet descriptionMarkup()}
	{#if typeof description === 'string'}
		<Text as="p" variant="bodyMd">
			{description}
		</Text>
	{:else}
		{@render description?.()}
	{/if}
{/snippet}

<div class={styles.AnnotatedSection}>
	<div class={styles.AnnotationWrapper}>
		<div class={styles.Annotation}>
			<TextContainer spacing="tight">
				<Text {id} variant="headingMd" as="h2">
					{title}
				</Text>
				<Box color="text-secondary">{@render descriptionMarkup()}</Box>
			</TextContainer>
		</div>

		<div class={styles.AnnotationContent}>{@render children?.()}</div>
	</div>
</div>

```

# components/layout/components/layout-section/layout-section.svelte

```svelte
<script lang='ts'>
	import { classNames } from '$utilities/css.js';
    import styles from '../../layout.module.css';
    import type { SectionProps } from '../../types.ts';
    let { children, variant }: SectionProps = $props();

    const className = $derived(classNames(styles.Section, styles[`Section-${variant}`]));
</script>

<div class={className}>{@render children?.()}</div>
```

# components/layout/index.ts

```ts
import LayoutSectionComponent from "./components/layout-section/layout-section.svelte";
import AnnotatedLayoutSectionComponent from "./components/annotated-layout-section/annotated-layout-section.svelte";
import LayoutComponent from "./layout.svelte";

type LayoutCompoundType = typeof LayoutComponent & {
    Section: typeof LayoutSectionComponent;
    AnnotatedSection: typeof AnnotatedLayoutSectionComponent;
};

const Layout = LayoutComponent as LayoutCompoundType;
Layout.Section = LayoutSectionComponent;
Layout.AnnotatedSection = AnnotatedLayoutSectionComponent;

export default Layout;

    
```

# components/layout/layout.module.css

```css
.Layout {
    display: flex;
    flex-wrap: wrap;
    justify-content: center;
    align-items: flex-start;
    margin-top: calc(-1 * var(--p-space-400));
    margin-left: calc(-1 * var(--p-space-400));

    @media print {
        body & {
            font-size: var(--p-font-size-300);
            line-height: var(--p-font-line-height-400);
        }

        a,
        button {
            color: var(--p-color-text);
        }
    }
}

.Section {
    /* stylelint-disable-next-line -- Polaris component custom properties */
    flex: var(--pg-layout-relative-size) var(--pg-layout-relative-size) var(--pg-layout-width-primary-min);
    min-width: 51%;

    @media print {
        flex: 2 2 360px;
    }
}

.Section-fullWidth {
    flex: 1 1 100%;
}

.Section-oneHalf {
    /* stylelint-disable-next-line -- polaris custom global property */
    flex: 1 1 var(--pg-layout-width-one-half-width-base);
    min-width: 0;
}

.Section-oneThird {
    /* stylelint-disable-next-line -- polaris custom global property */
    flex: 1 1 var(--pg-layout-width-one-third-width-base);
    min-width: 0;
}

.AnnotatedSection {
    min-width: 0;
    flex: 1 1 100%;
}

.Section,
.AnnotatedSection {
    max-width: calc(100% - var(--p-space-400));
    margin-top: var(--p-space-400);
    margin-left: var(--p-space-400);

    +.AnnotatedSection {
        border-top: var(--p-border-width-025) solid var(--p-color-border-secondary);
        padding-top: var(--p-space-400);
    }
}

.AnnotationWrapper {
    display: flex;
    flex-wrap: wrap;
    margin-top: calc(-1 * var(--p-space-400));
    margin-left: calc(-1 * var(--p-space-400));
}

.AnnotationContent {
    /* stylelint-disable-next-line -- Polaris component custom properties */
    flex: var(--pg-layout-relative-size) var(--pg-layout-relative-size) var(--pg-layout-width-primary-min);
}

.Annotation {
    /* stylelint-disable-next-line -- polaris custom global property */
    flex: 1 1 var(--pg-layout-width-secondary-min);
    padding: var(--p-space-400) var(--p-space-400) 0 0;

    @media (--p-breakpoints-md-up) {
        padding-bottom: var(--p-space-400);
    }
}

.Annotation,
.AnnotationContent {
    min-width: 0;
    max-width: calc(100% - var(--p-space-400));
    margin-top: var(--p-space-400);
    margin-left: var(--p-space-400);
}
```

# components/layout/layout.svelte

```svelte
<script lang="ts">
	import LayoutSection from './components/layout-section/layout-section.svelte';
  import styles from './layout.module.css';
  import type { LayoutProps } from './types.ts';
  let { children, sectioned }: LayoutProps = $props();

</script>

<div class={styles.Layout}>
  {#if sectioned}
    <LayoutSection>
      {@render children?.()}
    </LayoutSection>
  {:else}
    {@render children?.()}
  {/if}
</div>

```

# components/layout/types.ts

```ts
import type { Snippet } from "svelte";

export interface AnnotatedSectionProps {
    children?: Snippet;
    title?: Snippet | string;
    description?: Snippet | string;
    id?: string;
}

export interface SectionProps {
    children?: Snippet;
    variant?: 'oneHalf' | 'oneThird' | 'fullWidth';
}

export interface LayoutProps {
    /** Automatically adds sections to layout. */
    sectioned?: boolean;
    /** The content to display inside the layout. */
    children?: Snippet;
}

```

# components/legacy-card/components/header/legacy-card-header.svelte

```svelte
<script lang="ts">
	import styles from '../../legacy-card.module.css';
	import InlineStack from '$lib/components/inline-stack/inline-stack.svelte';
	import Text from '$lib/components/text/text.svelte';
	import ButtonGroup from '$lib/components/button-group/index.js';
	import ButtonFrom from '$lib/components/button/button-from.svelte';
	import type { LegacyCardHeaderProps } from './types.ts';

	let { title, actions, children }: LegacyCardHeaderProps = $props();
</script>

<div class={styles.Header}>
	{#if actions || children}
		<InlineStack wrap={false} gap="200" align="space-between" blockAlign="center">
			{#if title}
				<Text as="h2" variant="headingSm">{title}</Text>
			{/if}
			{#if actions}
				<InlineStack wrap={false} gap="400" blockAlign="center">
					<ButtonGroup>
						{#each actions as action}
							<ButtonGroup.Item>
								<ButtonFrom overrides={{ variant: 'plain' }} {action} />
							</ButtonGroup.Item>
						{/each}
					</ButtonGroup>
				</InlineStack>
			{/if}
			{#if children}
				{@render children?.()}
			{/if}
		</InlineStack>
	{:else if title}
		<Text as="h2" variant="headingSm">{title}</Text>
	{/if}
</div>

```

# components/legacy-card/components/header/types.ts

```ts
import type { DisableableAction } from '$utilities/types.js';
import type { Snippet } from 'svelte';

export interface LegacyCardHeaderProps {
    title?: string;
    actions?: DisableableAction[];
    children?: Snippet;
}
```

# components/legacy-card/components/section/legacy-card-section.svelte

```svelte
<script lang="ts">
	import styles from '../../legacy-card.module.css';
	import { classNames } from '$utilities/css.js';
	import Text from '$lib/components/text/text.svelte';
	import InlineStack from '$lib/components/inline-stack/inline-stack.svelte';
	import ButtonFrom from '$lib/components/button/button-from.svelte';
	import ButtonGroup from '$lib/components/button-group/index.js';
	import type { LegacyCardSectionProps } from './types.js';

	

	let { children, title, subdued, flush, fullWidth, actions, hideOnPrint }: LegacyCardSectionProps =
		$props();

	const className = $derived(
		classNames(
			styles.Section,
			flush && styles['Section-flush'],
			subdued && styles['Section-subdued'],
			fullWidth && styles['Section-fullWidth'],
			hideOnPrint && styles['Section-hideOnPrint']
		)
	);
</script>

<div class={className}>
	{#if title || actions}
		<div class={styles.SectionHeader}>
            <InlineStack blockAlign="baseline">
                {#if title}
                    <Text as="h3" variant="headingSm" fontWeight="medium">{title}</Text>
                {/if}
                {#if actions}
                    <InlineStack wrap={false} gap="400" blockAlign="center">
                        <ButtonGroup>
                            {#each actions as action}
							<ButtonGroup.Item>
								<ButtonFrom overrides={{ variant: 'plain' }} {action} />
							</ButtonGroup.Item>
                            {/each}
                        </ButtonGroup>
                    </InlineStack>
                {/if}
            </InlineStack>
		</div>
	{/if}
	{@render children?.()}
</div>

```

# components/legacy-card/components/section/types.ts

```ts
import type { ComplexAction } from '$utilities/types.js';
import type { Snippet } from 'svelte';

export interface LegacyCardSectionProps {
    title?: string;
    children?: Snippet;
    subdued?: boolean;
    flush?: boolean;
    fullWidth?: boolean;
    /** Allow the card to be hidden when printing */
    hideOnPrint?: boolean;
    actions?: ComplexAction[];
}
```

# components/legacy-card/components/sub-section/legacy-card-sub-section.svelte

```svelte
<script lang='ts'>
    import styles from '../../legacy-card.module.css';
    import type { LegacyCardSubsectionProps } from './types.ts';

    let { children }: LegacyCardSubsectionProps = $props();
</script>

<div class={styles.Subsection}>
    {@render children?.()}
</div>
```

# components/legacy-card/components/sub-section/types.ts

```ts
import type { Snippet } from "svelte";

export interface LegacyCardSubsectionProps {
    children?: Snippet;
}
```

# components/legacy-card/index.ts

```ts
import LegacyCardSvelte from './legacy-card.svelte';
import LegacyCardSectionSvelte from './components/section/legacy-card-section.svelte';

type LegacyCardCompoundComponent = typeof LegacyCardSvelte & {
	Section: typeof LegacyCardSectionSvelte;
};

const LegacyCard = LegacyCardSvelte as LegacyCardCompoundComponent;
LegacyCard.Section = LegacyCardSectionSvelte;

export default LegacyCard;

```

# components/legacy-card/legacy-card.module.css

```css
.LegacyCard {
    background-color: var(--p-color-bg-surface);
    box-shadow: var(--p-shadow-300);
    outline: var(--p-border-width-025) solid transparent;
    overflow: clip;

    @mixin shadow-bevel var(--p-shadow-100), var(--p-border-radius-0), null, '',
    101;

    +.LegacyCard {
        margin-top: var(--p-space-400);

        @media print {
            margin-top: calc(-1 * var(--p-space-200));
        }
    }

    @media (--p-breakpoints-sm-up) {
        border-radius: var(--p-border-radius-200);

        @mixin shadow-bevel var(--p-shadow-100), var(--p-border-radius-300), null,
        '', 101;

        .Section:first-child {
            border-top-left-radius: var(--p-border-radius-300);
            border-top-right-radius: var(--p-border-radius-300);
        }

        .Section:last-child {
            border-bottom-left-radius: var(--p-border-radius-300);
            border-bottom-right-radius: var(--p-border-radius-300);
        }
    }

    @media print {
        box-shadow: none;

        @mixin shadow-bevel none, var(--p-border-radius-0), none, none;
    }
}

.subdued {
    background-color: var(--p-color-bg-surface-secondary);
}

.Section-hideOnPrint,
.hideOnPrint {
    @media print {
        /* stylelint-disable-next-line declaration-no-important -- Enforce print styles */
        display: none !important;
    }
}

.Header {
    padding: var(--p-space-400) var(--p-space-400) 0;

    @media (--p-breakpoints-sm-up) {
        padding: var(--p-space-200) var(--p-space-400) 0;
    }
}

@media print and (--p-breakpoints-sm-up) {
    .Header {
        padding: var(--p-space-200) var(--p-space-400) 0;
    }
}

.Section {
    padding: var(--p-space-200) var(--p-space-400);

    @media (--p-breakpoints-sm-up) {
        padding: var(--p-space-200) var(--p-space-400);
    }

    +.Section {
        border-top: 0;

        @media print {
            border-top: 0;
        }
    }

    @media print {
        padding-top: var(--p-space-100);
        padding-bottom: var(--p-space-100);
    }
}

.Section-fullWidth {
    padding: var(--p-space-400) 0;

    @media (--p-breakpoints-sm-up) {
        padding: var(--p-space-400) 0;
    }
}

.Section-flush {
    padding: 0;

    @media (--p-breakpoints-sm-up) {
        padding: 0;
    }
}

.Section-subdued {
    background-color: var(--p-color-bg-surface-secondary);
    padding: var(--p-space-300) var(--p-space-400);

    @media (-ms-high-contrast: active) {
        background-color: transparent;
    }

    .Header+& {
        border-top: 0;
        margin-top: 0;
    }
}

.Section-subdued:last-child {
    padding: var(--p-space-400);

    @media print {
        padding-top: var(--p-space-200);
        padding-bottom: var(--p-space-200);
    }
}

.SectionHeader {
    padding-bottom: var(--p-space-200);

    .Section-fullWidth & {
        padding-left: var(--p-space-400);
        padding-right: var(--p-space-400);

        @media (--p-breakpoints-sm-up) {
            padding-left: var(--p-space-400);
            padding-right: var(--p-space-400);
        }
    }
}

.Subsection {
    +.Subsection {
        border-top: 0;
        margin-top: 0;
        padding-top: var(--p-space-200);

        @media print {
            border-top: 0;
        }
    }

    @media print {
        padding-top: var(--p-space-100);
        padding-bottom: var(--p-space-100);
    }
}

.Footer {
    display: flex;
    justify-content: flex-end;

    padding: 0 var(--p-space-400) var(--p-space-400);

    @media (--p-breakpoints-sm-up) {
        padding: 0 var(--p-space-400) var(--p-space-400);
    }

    &.LeftJustified {
        justify-content: flex-start;
    }

    .Section-subdued+& {
        padding: var(--p-space-400);
        border-top: 0;
    }
}

.FirstSectionPadding {
    padding-top: var(--p-space-400);
}

.LastSectionPadding {
    padding-bottom: var(--p-space-400);
}
```

# components/legacy-card/legacy-card.svelte

```svelte
<script lang="ts">
	import { UseToggle } from '$lib/use/use-toggle.svelte.js';
	import { classNames } from '$utilities/css.js';
	import styles from './legacy-card.module.css';
	import LegacyCardHeader from './components/header/legacy-card-header.svelte';
	import LegacyCardSection from './components/section/legacy-card-section.svelte';
	import ButtonFrom from '../button/button-from.svelte';
	import ActionList from '../action-list/action-list.svelte';
	import InlineStack from '../inline-stack/inline-stack.svelte';
	import Popover from '../popover/index.js';
	import Button from '../button/button.svelte';
	import type { LegacyCardProps } from './types.js';

	let {
		children,
		hideOnPrint,
		title,
		subdued,
		sectioned,
		actions,
		primaryFooterAction,
		secondaryFooterActions,
		secondaryFooterActionsDisclosureText,
		footerActionAlignment = 'right'
	}: LegacyCardProps = $props();

	const secondaryActionsPopoverOpen = new UseToggle(false);
	const toggleSecondaryActionsPopoverOpen = secondaryActionsPopoverOpen.toggle;

	const className = $derived(
		classNames(styles.LegacyCard, subdued && styles.subdued, hideOnPrint && styles.hideOnPrint)
	);
</script>

{#snippet primaryFooterActionMarkup()}
	{#if primaryFooterAction}
		<ButtonFrom action={primaryFooterAction} overrides={{ variant: 'primary' }} />
	{/if}
{/snippet}

{#snippet secondaryFooterActionMarkup()}
	{#if secondaryFooterActions?.length}
		{#if secondaryFooterActions.length === 1}
			<ButtonFrom action={secondaryFooterActions[0]} overrides={{ variant: 'secondary' }} />
		{:else}
			<Popover active={secondaryActionsPopoverOpen.value} onClose={toggleSecondaryActionsPopoverOpen}>
				{#snippet trigger()}
					<Button disclosure onClick={toggleSecondaryActionsPopoverOpen}>
						{secondaryFooterActionsDisclosureText || 'More'}
					</Button>
				{/snippet}
				<ActionList items={secondaryFooterActions} />
			</Popover>
		{/if}
	{/if}
{/snippet}

{#snippet footerMarkup()}
	{#if primaryFooterAction || secondaryFooterActions?.length}
		<div
			class={classNames(styles.Footer, footerActionAlignment === 'left' && styles.LeftJustified)}
		>
			{#if footerActionAlignment === 'right'}
				<InlineStack gap="200">
					{@render secondaryFooterActionMarkup()}
					{@render primaryFooterActionMarkup()}
				</InlineStack>
			{:else}
				<InlineStack gap="200">
					{@render primaryFooterActionMarkup()}
					{@render secondaryFooterActionMarkup()}
				</InlineStack>
			{/if}
		</div>
	{/if}
{/snippet}

<div class={className}>
	{#if title || actions}
		<LegacyCardHeader {title} {actions} />
	{/if}
	{#if sectioned}
		<LegacyCardSection {children} />
	{:else}
		{@render children?.()}
	{/if}
	{@render footerMarkup()}
</div>

```

# components/legacy-card/types.ts

```ts
import type { ComplexAction, DisableableAction } from '$utilities/types.js';
import type { Snippet } from 'svelte';

export interface LegacyCardProps {
    /** Title content for the card */
    title?: string;
    /** Inner content of the card */
    children?: Snippet;
    /** A less prominent card */
    subdued?: boolean;
    /** Auto wrap content in section */
    sectioned?: boolean;
    /** Card header actions */
    actions?: DisableableAction[];
    /** Primary action in the card footer */
    primaryFooterAction?: ComplexAction;
    /** Secondary actions in the card footer */
    secondaryFooterActions?: ComplexAction[];
    /** The content of the disclosure button rendered when there is more than one secondary footer action */
    secondaryFooterActionsDisclosureText?: string;
    /** Alignment of the footer actions on the card, defaults to right */
    footerActionAlignment?: 'right' | 'left';
    /** Allow the card to be hidden when printing */
    hideOnPrint?: boolean;
}
```

# components/link/link.module.css

```css
.Link {
    appearance: none;
    display: inline;
    text-align: inherit;
    padding: 0;
    background: none;
    border: 0;
    font-size: inherit;
    font-weight: inherit;
    color: var(--p-color-text-link);
    text-decoration: underline;
    cursor: pointer;
    touch-action: manipulation;

    &:hover {
        color: var(--p-color-text-link-hover);
        text-decoration: underline;
    }

    &:focus,
    &:focus-visible {
        outline: var(--p-color-border-focus) auto var(--p-border-width-050);
        outline-offset: var(--p-space-050);
        border-radius: var(--p-border-radius-150);
    }

    &:active {
        position: relative;
        color: var(--p-color-text-link-active);
    }

    @media print {
        text-decoration-color: var(--p-color-border-tertiary);
    }
}

.monochrome {
    color: inherit;

    &:hover,
    &:focus,
    &:active {
        color: inherit;
    }
}

.removeUnderline {
    text-decoration: none;

    &:hover {
        text-decoration: underline;
    }
}
```

# components/link/link.svelte

```svelte
<script lang="ts">
	import { classNames } from '$utilities/css.js';
	import UnstyledLink from '../button/unstyled-link.svelte';
	import styles from './link.module.css';
	import type { LinkProps } from './types.js';

	let {
		url,
		children,
		onClick,
		external,
		target,
		id,
		monochrome,
		removeUnderline,
		accessibilityLabel,
		dataPrimaryLink
	}: LinkProps = $props();

	const shouldBeMonochrome = monochrome;

	const className = $derived(
		classNames(
			styles.Link,
			shouldBeMonochrome && styles.monochrome,
			removeUnderline && styles.removeUnderline
		)
	);
</script>

{#if url}
	<UnstyledLink {className} {url} {external} {target}>
		{@render children?.()}
	</UnstyledLink>
{:else}
	<button
		type="button"
		onclick={onClick}
		class={className}
		{id}
		aria-label={accessibilityLabel}
		data-primary-link={dataPrimaryLink}
	>
		{@render children?.()}
	</button>
{/if}

```

# components/link/types.ts

```ts
import type { Target } from "$utilities/types.js";
import type { Snippet } from "svelte";

export interface LinkProps {
    /** ID for the link */
    id?: string;
    /** The url to link to */
    url?: string;
    /** The content to display inside the link */
    children?: Snippet;
    /** Makes the link open in a new tab
     * @deprecated use `target` set to `_blank` instead
     */
    external?: boolean;
    /** Where to display the url */
    target?: Target;
    /** Makes the link color the same as the current text color and adds an underline */
    monochrome?: boolean;
    /** Removes text decoration underline to the link */
    removeUnderline?: boolean;
    /** Callback when a link is clicked */
    onClick?(): void;
    /** Descriptive text to be read to screenreaders */
    accessibilityLabel?: string;
    /** Indicates whether or not the link is the primary navigation link when rendered inside of an `IndexTable.Row` */
    dataPrimaryLink?: boolean;
}

```

# components/list/components/item/item.svelte

```svelte
<script lang="ts">
	import styles from '../../list.module.css';
	import type { ItemProps } from './types.js';

	let { children }: ItemProps = $props();
</script>

<li class={styles.Item}>
	{@render children?.()}
</li>
```

# components/list/components/item/types.ts

```ts
import type { Snippet } from "svelte";

export interface ItemProps {
    /** Content to display inside the item */
    children?: Snippet;
}
```

# components/list/index.ts

```ts
import ListComponent from "./list.svelte";
import ItemComponent from "./components/item/item.svelte";

type ListComponentCompundType = typeof ListComponent & {
	Item: typeof ItemComponent;
};

const List = ListComponent as ListComponentCompundType;
List.Item = ItemComponent;

export default List;
```

# components/list/list.module.css

```css
.List {
  padding-left: var(--p-space-500);
  margin-top: 0;
  margin-bottom: 0;
  list-style: disc outside none;

  +.List {
    margin-top: var(--p-space-400);
  }
}

.typeNumber {
  padding-left: var(--p-space-800);
  list-style: decimal outside none;
}

.Item {
  .List:first-child {
    margin-top: var(--p-space-200);
  }
}

.spacingLoose {
  .Item {
    margin-bottom: var(--p-space-100);
  }
}
```

# components/list/list.svelte

```svelte
<script lang="ts">
	import { classNames, variationName } from '$utilities/css.js';
  import styles from './list.module.css';
	import type { ListProps } from './types.js';

  let {children, gap = 'loose', type = 'bullet'}: ListProps = $props();

  const className = $derived(
    classNames(
      styles.List,
      gap && styles[variationName('spacing', gap)],
      type && styles[variationName('type', type)],
    )
  );
</script>

<svelte:element this={type === 'bullet' ? 'ul' : 'ol'} class={className}>
	{@render children?.()}
</svelte:element>
	
```

# components/list/types.ts

```ts
import type { Snippet } from "svelte";

export type Type = 'bullet' | 'number';

export type Spacing = 'extraTight' | 'loose';

export interface ListProps {
  /**
   * Determines the space between list items
   * @default 'loose'
   */
  gap?: Spacing;
  /**
   * Type of list to display
   * @default 'bullet'
   */
  type?: Type;
  /** List item elements */
  children?: Snippet;
}
```

# components/listbox/components/action/action.module.css

```css
.Action {
    display: flex;
    flex: 1;
}

.ActionDivider {
    margin-bottom: var(--p-space-100);
}

.Icon {
    padding-right: var(--p-space-200);
}
```

# components/listbox/components/action/action.svelte

```svelte
<script lang="ts">
	import Icon from '$lib/components/icon/icon.svelte';
	import type { IconProps } from '$lib/components/icon/types.js';
	import type { OptionProps } from '../option/types.js';
	import styles from './action.module.css';
	import { classNames } from '$utilities/css.js';
	import ActionContextProvider from '$lib/components/app-provider/action-context-provider.svelte';
	import TextOption from '../text-option/text-option.svelte';
    import Option from '../option/option.svelte';

	interface ActionProps extends OptionProps {
		icon?: IconProps['source'];
	}

	let { selected, disabled, children, icon, divider, value, accessibilityLabel }: ActionProps =
		$props();
	let className = $derived(classNames(styles.Action, divider && styles.ActionDivider));
</script>

{#snippet iconMarkup()}
	{#if icon}
		<div class={styles.Icon}>
			<Icon tone="subdued" source={icon} />
		</div>
	{/if}
{/snippet}

<ActionContextProvider value>
	<Option accessibilityLabel={accessibilityLabel} value={value} selected={selected} disabled={disabled} divider={divider}>
		<div class={className}>
			<TextOption {selected} {disabled}>
				{@render iconMarkup()}
				{#if typeof children === 'string'}
					{children}
				{:else}
					{@render children?.()}
				{/if}
			</TextOption>
		</div>
	</Option>
</ActionContextProvider>

```

# components/listbox/components/header/header.svelte

```svelte
<script lang="ts">
	import type { Snippet } from 'svelte';
	import { useSection } from '../section/hooks.js';
	import Box from '$lib/components/box/box.svelte';
	import Text from '$lib/components/text/text.svelte';

	let { children }: { children?: Snippet | string } = $props();
	const sectionId = useSection() || '';
</script>

<div aria-hidden={true} id={sectionId}>
	{#if typeof children === 'string'}
		<Box
			paddingBlockStart="200"
			paddingInlineStart="400"
			paddingBlockEnd="200"
			paddingInlineEnd="400"
		>
			<Text as="span" variant="headingSm" tone="subdued">
				{children}
			</Text>
		</Box>
	{/if}
</div>

```

# components/listbox/components/loading/loading.module.css

```css
.ListItem {
    padding: 0;
    margin: 0;
}

.Loading {
    padding: var(--p-space-200) var(--p-space-400);
    display: grid;
    place-items: center;
}
```

# components/listbox/components/loading/loading.svelte

```svelte
<script lang="ts">
	import Spinner from '$lib/components/spinner/spinner.svelte';
	import { useListbox } from '$utilities/listbox/hooks.js';
	import styles from './loading.module.css';
	import type { LoadingProps } from './types.js';
	let { children, accessibilityLabel: label }: LoadingProps = $props();
	const { setLoading } = $derived(useListbox()());

	$effect(() => {
		setLoading(label);

		return () => {
			setLoading(undefined);
		};
	});
</script>

<li class={styles.ListItem} role="presentation">
	{#if children}
		{@render children()}
	{:else}
		<div class={styles.Loading}>
			<Spinner size="small" accessibilityLabel={label} />
		</div>
	{/if}
</li>

```

# components/listbox/components/loading/types.ts

```ts
import type { Snippet } from "svelte";

export interface LoadingProps {
    children?: Snippet;
    accessibilityLabel: string;
}

```

# components/listbox/components/option/option.module.css

```css
.Option {
    display: flex;
    margin: 0;
    padding: 0;

    &:focus {
        outline: none;
    }
}

.divider {
    border-bottom: var(--p-border-width-025) solid var(--p-color-border-secondary);
}
```

# components/listbox/components/option/option.svelte

```svelte
<script lang="ts">
	import {
		MAPPED_ACTION_CONTEXT_KEY,
		type MappedActionContextType
	} from '$lib/utilities/listbox/types.js';
	import UnstyledLink from '$lib/components/button/unstyled-link.svelte';
	import { useContext } from '$utilities/contexts.js';
	import { classNames } from '$utilities/css.js';
	import {
		ACTION_CONTEXT_KEY,
		LISTBOX_CONTEXT_KEY,
		type ListboxContextType
	} from '$utilities/listbox/types.js';
	import { useSection } from '../section/hooks.js';
	import { listboxWithinSectionDataSelector } from '../section/selectors.js';
	import TextOption from '../text-option/text-option.svelte';
	import styles from './option.module.css';
	import type { OptionProps } from './types.js';
	let {
		value,
		children,
		selected,
		disabled = false,
		accessibilityLabel,
		divider
	}: OptionProps = $props();

	const isAction = useContext<boolean>(ACTION_CONTEXT_KEY);
	//const { onOptionSelect } = useContext<ListboxContextType>(LISTBOX_CONTEXT_KEY) || {};
	const listBoxContext = useContext<ListboxContextType>(LISTBOX_CONTEXT_KEY) || {};
	//const { role, url, external, onAction, destructive } = useContext<MappedActionContextType>(MAPPED_ACTION_CONTEXT_KEY) || {};
	const mappedActionContext = useContext<MappedActionContextType>(MAPPED_ACTION_CONTEXT_KEY) || {};
	
	let listItemRef = $state<HTMLLIElement>();
	let domId = $props.id();
	const sectionId = useSection();
	const isWithinSection = $derived(Boolean(sectionId));

	const handleOptionSelect = (event: KeyboardEvent | MouseEvent) => {
		event.preventDefault();
		event.stopPropagation();
		mappedActionContext()?.onAction && mappedActionContext()?.onAction?.();

		if (listItemRef && !mappedActionContext()?.onAction) {
			listBoxContext()?.onOptionSelect({
				domId,
				value,
				element: listItemRef,
				disabled
			});
		}
	};

	const handleMouseDown = (event: MouseEvent) => {
		event.preventDefault();
	};

	const sectionAttributes = $derived({
		[listboxWithinSectionDataSelector.attribute]: isWithinSection
	});

	const legacyRoleSupport = mappedActionContext()?.role || 'option';
</script>

{#snippet content()}
	{#if typeof children === 'string'}
		<TextOption {selected} {disabled}>
			{children}
		</TextOption>
	{:else}
		{@render children?.()}
	{/if}
{/snippet}

{#snippet contentMarkup()}
	{#if mappedActionContext()?.url}
		<UnstyledLink url={mappedActionContext()?.url} external={mappedActionContext()?.external}>
			{@render content()}
		</UnstyledLink>
	{:else}
		{@render content()}
	{/if}
{/snippet}

<li
	{...sectionAttributes}
	data-listbox-option
	data-listbox-option-action={isAction}
	data-listbox-option-value={value}
	data-listbox-option-destructive={mappedActionContext()?.destructive}
	data-within-section={isWithinSection}
	class={classNames(styles.Option, divider && styles.divider)}
	id={domId}
	bind:this={listItemRef}
	tabIndex={-1}
	role={legacyRoleSupport}
	aria-label={accessibilityLabel}
	aria-selected={selected}
	aria-disabled={disabled}
	onclick={disabled ? undefined : handleOptionSelect}
	onkeydown={disabled ? undefined : handleOptionSelect}
	onmousedown={handleMouseDown}
>
	{@render contentMarkup()}
</li>

```

# components/listbox/components/option/types.ts

```ts
import type { Snippet } from "svelte";

export interface OptionProps {
    // Unique item value
    value: string;
    // Visually hidden text for screen readers
    accessibilityLabel?: string;
    // Children. When a string, children are rendered in a styled TextOption
    children?: string | Snippet;
    // Option is selected
    selected?: boolean;
    // Option is disabled
    disabled?: boolean;
    // Adds a border-bottom to the Option
    divider?: boolean;
}
```

# components/listbox/components/section/hooks.ts

```ts
import { useContext } from "$utilities/contexts.js";
import { SECTION_CONTEXT_KEY } from "./types.js";

export function useSection() {
    const context = useContext<string|null>(SECTION_CONTEXT_KEY);
    return context;
}
```

# components/listbox/components/section/section-context-provider.svelte

```svelte
<script lang='ts'>
    import { setContext, type Snippet } from "svelte";
	import { SECTION_CONTEXT_KEY } from "./types.js";
    let { children, value }: { children?: Snippet, value: string } = $props();
    setContext<string|null>(SECTION_CONTEXT_KEY, value);
</script>

{@render children?.()}
```

# components/listbox/components/section/section.module.css

```css
.SectionGroup {
    list-style-type: none;
    padding: 0;
    margin: 0;
    border-bottom: var(--p-border-width-025) solid var(--p-color-border-secondary);
}

.noDivider {
    border-bottom: none;
}
```

# components/listbox/components/section/section.svelte

```svelte
<script lang="ts">
	import type { Snippet } from 'svelte';
	import type { SectionProps } from './types.js';
	import SectionContextProvider from './section-context-provider.svelte';
	import { classNames } from '$utilities/css.js';
	import styles from './section.module.css';
	import { listboxSectionDataSelector } from './selectors.js';

	const id = $props.id();

	let { children, divider = true, title }: SectionProps = $props();
</script>

<SectionContextProvider value={id}>
	<li role="presentation" {...listboxSectionDataSelector.props}>
		{#if typeof title === 'string'}
			{title}
		{:else}
			{@render title()}
		{/if}
		
		<ul
			role="group"
			aria-labelledby={id}
			class={classNames(styles.SectionGroup, !divider && styles.noDivider)}>
			{@render children?.()}
		</ul>
	</li>
</SectionContextProvider>

```

# components/listbox/components/section/selectors.ts

```ts
export const listboxSectionDataSelector = {
    props: { 'data-polaris-listbox-section-item': true },
    selector: '[data-polaris-listbox-section-item]',
};

export const listboxWithinSectionDataSelector = {
    attribute: 'data-polaris-listbox-within-section-item',
};
```

# components/listbox/components/section/types.ts

```ts
import type { Snippet } from "svelte";

export interface SectionProps {
    divider?: boolean;
    children?: Snippet;
    title: string|Snippet;
}

export const SECTION_CONTEXT_KEY = 'polaris-section-context';
```

# components/listbox/components/text-option/text-option.module.css

```css
.TextOption {
    margin: var(--p-space-100) var(--p-space-200) 0;
    flex: 1;
    border-radius: var(--p-border-radius-200);
    padding: var(--p-space-150) var(--p-space-300);
    cursor: pointer;
    display: flex;
    /* stylelint-disable-next-line -- generated by polaris-migrator DO NOT COPY */
    @mixin focus-ring base, 0, base;

    &.allowMultiple {
        margin: var(--p-space-100) var(--p-space-200) 0;
        padding: var(--p-space-100) var(--p-space-200);
    }

    &.isAction {
        margin-top: var(--p-space-100);
    }

    &:hover {
        background-color: var(--p-color-bg-surface-hover);

        &:not(.disabled) {
            background-color: var(--p-color-bg-surface-secondary-hover);
        }
    }

    &:focus {
        outline: none;
    }

    &:active {
        background-color: var(--p-color-bg-surface-active);

        &:not(.disabled) {
            background-color: var(--p-color-bg-surface-secondary-active);
        }
    }

    &.selected {
        background-color: var(--p-color-bg-surface-secondary-selected);
        font-weight: var(--p-font-weight-semibold);

        svg {
            fill: var(--p-color-icon-active);
        }
    }

    &.selected::before {
        content: none;
        position: absolute;
        top: 0;
        bottom: 0;
        left: calc(-1 * var(--p-space-100));
        height: 100%;
        width: var(--p-border-radius-100);
        background-color: var(--p-color-bg-fill-brand);
        border-top-right-radius: var(--p-border-radius-100);
        border-bottom-right-radius: var(--p-border-radius-100);
        transform: translateX(-100%);
    }

    &.disabled {
        background-color: transparent;
        color: var(--p-color-text-disabled);
        cursor: default;
    }
}

li:first-of-type>.TextOption {
    margin-top: 0;
}

/* Focused by click */
[data-focused] .TextOption:not(.disabled) {
    outline: none;
    background-color: var(--p-color-bg-surface-secondary-selected);
    transition: background-color var(--p-motion-duration-400);
}

.Content {
    flex: 1 1 auto;
    display: flex;
}

.Checkbox {
    pointer-events: none;
}
```

# components/listbox/components/text-option/text-option.svelte

```svelte
<script lang="ts">
	import type { TextOptionProps } from './types.js';
	import styles from './text-option.module.css';
	import { classNames } from '$utilities/css.js';
	import { useContext } from '$utilities/contexts.js';
	import { ACTION_CONTEXT_KEY } from '$utilities/listbox/types.js';
	import Box from '$lib/components/box/box.svelte';
	import InlineStack from '$lib/components/inline-stack/inline-stack.svelte';
	import Icon from '$lib/components/icon/icon.svelte';
	import CheckIcon from '@shopify/polaris-icons/dist/svg/CheckIcon.svg?component';
	import Checkbox from '$lib/components/checkbox/checkbox.svelte';
	import { COMBOBOX_LIST_BOX_OPTION_CONTEXT_KEY, type ComboboxListboxOptionType } from '$utilities/combobox/types.js';

	let { children, selected, disabled }: TextOptionProps = $props();

	//const { allowMultiple } = useContext<ComboboxListboxOptionType>(COMBOBOX_LIST_BOX_OPTION_CONTEXT_KEY) || {};
	const comboboxListboxOptionContext = useContext<ComboboxListboxOptionType>(COMBOBOX_LIST_BOX_OPTION_CONTEXT_KEY) || {};
	const actionContext = useContext<boolean>(ACTION_CONTEXT_KEY) || false;

	const textOptionClassName = $derived(
		classNames(
			styles.TextOption,
			selected && !comboboxListboxOptionContext()?.allowMultiple && styles.selected,
			disabled && styles.disabled,
			comboboxListboxOptionContext()?.allowMultiple && styles.allowMultiple,
			actionContext() && styles.isAction
		)
	);
</script>

{#snippet renderChildren()}
    {#if typeof children === 'string'}
        {children}
    {:else}
        {@render children()}
    {/if}
{/snippet}

{#snippet optionMarkup()}
	{#if selected}
		<Box width="100%">
			<InlineStack wrap={false} align="space-between" gap="200">
				{@render renderChildren()}
				<InlineStack align="end">
					<Icon source={CheckIcon} />
				</InlineStack>
			</InlineStack>
		</Box>
	{:else}
		{@render renderChildren()}
	{/if}
{/snippet}

<div class={textOptionClassName}>
	<div class={styles.Content}>
		{#if comboboxListboxOptionContext()?.allowMultiple && !actionContext()}
			<div class={styles.Checkbox}>
				{#if typeof children === 'string'}
					<Checkbox {disabled} checked={selected} label={children} />
				{/if}
			</div>
		{:else}
			{@render optionMarkup()}
		{/if}
	</div>
</div>

```

# components/listbox/components/text-option/types.ts

```ts
import type { Snippet } from "svelte";

export interface TextOptionProps {
    children: Snippet|string;
    // Whether the option is selected
    selected?: boolean;
    // Whether the option is disabled
    disabled?: boolean;
}
```

# components/listbox/index.ts

```ts
import ListboxComponent from './listbox.svelte';
import OptionComponent from './components/option/option.svelte';
import LoadingComponent from './components/loading/loading.svelte';
import TextOptionComponent from './components/text-option/text-option.svelte';
import SectionComponent from './components/section/section.svelte';
import HeaderComponent from './components/header/header.svelte';
import ActionComponent from './components/action/action.svelte';

type ListboxCompoundType = typeof ListboxComponent & {
    Option: typeof OptionComponent;
    Loading: typeof LoadingComponent;
    TextOption: typeof TextOptionComponent;
    Section: typeof SectionComponent;
    Header: typeof HeaderComponent;
    Action: typeof ActionComponent;
};

const Listbox = ListboxComponent as ListboxCompoundType;
Listbox.Option = OptionComponent;
Listbox.Loading = LoadingComponent;
Listbox.TextOption = TextOptionComponent;
Listbox.Section = SectionComponent;
Listbox.Header = HeaderComponent;
Listbox.Action = ActionComponent;

export default Listbox;

```

# components/listbox/listbox.module.css

```css
.Listbox {
    padding: 0;
    margin: 0;
    list-style: none;
    max-width: 100%;

    &:focus {
        outline: none;
    }
}
```

# components/listbox/listbox.svelte

```svelte
<script lang="ts">
	import { UseToggle } from '$lib/use/use-toggle.svelte.js';
	import { debounce } from '$utilities/debounce.js';
	import { scrollOptionIntoView } from '$utilities/listbox/utilities.js';
	import { scrollable } from '$utilities/shared.js';
	import { Key, type ComboboxListboxType, type NavigableOption } from '$utilities/types.js';
	import KeypressListener from '../keypress-listener/keypress-listener.svelte';
	import styles from './listbox.module.css';
	import Text from '../text/text.svelte';
	import {
		AutoSelection,
		OPTION_ACTION_ATTRIBUTE,
		OPTION_FOCUS_ATTRIBUTE,
		OPTION_SELECTOR,
		OPTION_VALUE_ATTRIBUTE,
		type ArrowKeys,
		type ListboxProps
	} from './types.js';
	import ListboxContentProvider from '../app-provider/list-box-content-provider.svelte';
	import WithinListBoxContextProvider from '../app-provider/within-list-box-context-provider.svelte';
	import { useContext } from '$utilities/contexts.js';
	import { COMBOBOX_LIST_BOX_CONTEXT_KEY } from '$utilities/combobox/types.js';
	let {
		children,
		autoSelection = AutoSelection.FirstSelected,
		enableKeyboardControl,
		accessibilityLabel,
		customListId,
		onSelect,
		onActiveOptionChange
	}: ListboxProps = $props();

	let loading = $state<string | undefined>();
	let activeOption = $state<NavigableOption | undefined>();
	let lazyLoading = $state(false);
	let currentOptions = $state<HTMLElement[]>([]);
	const uniqueId = $props.id();
	const listId = customListId || uniqueId;
	let scrollableRef = $state<HTMLElement | null>(null);
	let listboxRef = $state<HTMLUListElement | null>(null);

	const keyboardEventsEnabled = new UseToggle(Boolean(enableKeyboardControl));
	const enableKeyboardEvents = keyboardEventsEnabled.setTrue;
	const disableKeyboardEvents = keyboardEventsEnabled.setFalse;

	/* const {
		listboxId,
		textFieldLabelId,
		textFieldFocused,
		willLoadMoreOptions,
		setActiveOptionId,
		setListboxId,
		onOptionSelected,
		onKeyToBottom
	} = useContext<ComboboxListboxType>(COMBOBOX_LIST_BOX_CONTEXT_KEY) || {}; */

	const comboboxListBoxContext = useContext<ComboboxListboxType>(COMBOBOX_LIST_BOX_CONTEXT_KEY) || {};

	const inCombobox = Boolean(comboboxListBoxContext()?.setActiveOptionId);

	$effect(() => {
		if (comboboxListBoxContext()?.setListboxId && !comboboxListBoxContext()?.listboxId) {
			comboboxListBoxContext()?.setListboxId?.(listId);
		}
	});

	const getNavigableOptions = () => {
		if (!listboxRef) {
			return [];
		}

		return [...new Set(listboxRef.querySelectorAll<HTMLElement>(OPTION_SELECTOR))];
	};

	const getFirstNavigableOption = (currentOptions: HTMLElement[]) => {
		const hasSelectedOptions = currentOptions.some(
			(option) => option.getAttribute('aria-selected') === 'true'
		);

		let elementIndex = 0;
		const element = currentOptions.find((option, index) => {
			const isInteractable = option.getAttribute('aria-disabled') !== 'true';
			let isFirstNavigableOption;

			if (hasSelectedOptions && autoSelection === AutoSelection.FirstSelected) {
				const isSelected = option.getAttribute('aria-selected') === 'true';
				isFirstNavigableOption = isSelected && isInteractable;
			} else {
				isFirstNavigableOption = isInteractable;
			}

			if (isFirstNavigableOption) elementIndex = index;

			return isFirstNavigableOption;
		});

		if (!element) return;

		return { element, index: elementIndex };
	};

	const handleScrollIntoView = (option: NavigableOption) => {
		if (!scrollableRef) return;
		const scrollable = scrollableRef;

		if (scrollable) {
			scrollOptionIntoView(option.element, scrollable);
		}
	};

	const handleScrollIntoViewDebounced = debounce(handleScrollIntoView, 50);
	const handleKeyToBottom = () => {
		if (comboboxListBoxContext()?.onKeyToBottom) {
			lazyLoading = true;
			return Promise.resolve(comboboxListBoxContext()?.onKeyToBottom?.());
		}
	};

	const handleChangeActiveOption = (nextOption?: NavigableOption) => {
		if (!nextOption) return;
		activeOption?.element?.removeAttribute(OPTION_FOCUS_ATTRIBUTE);
		nextOption.element?.setAttribute(OPTION_FOCUS_ATTRIBUTE, 'true');
		handleScrollIntoViewDebounced(nextOption);
		activeOption = nextOption;
		comboboxListBoxContext()?.setActiveOptionId?.(nextOption.domId);
		onActiveOptionChange?.(nextOption.value, nextOption.domId);
	};

	const getFormattedOption = (element: HTMLElement, index: number) => {
		return {
			element,
			index,
			domId: element.id,
			value: element.getAttribute(OPTION_VALUE_ATTRIBUTE) || '',
			disabled: element.getAttribute('aria-disabled') === 'true',
			isAction: element.getAttribute(OPTION_ACTION_ATTRIBUTE) === 'true'
		};
	};

	const resetActiveOption = () => {
		let nextOption;
		const nextOptions = getNavigableOptions();
		const nextActiveOption = getFirstNavigableOption(nextOptions);
		if (nextOptions.length === 0 && currentOptions.length > 0) {
			currentOptions = nextOptions;
			handleChangeActiveOption();
			return;
		}

		if (nextActiveOption) {
			const { element, index } = nextActiveOption;
			nextOption = getFormattedOption(element, index);
		}

		const optionIsAlreadyActive =
			activeOption !== undefined && nextOption?.domId === activeOption?.domId;

		const actionContentHasUpdated =
			activeOption?.isAction && nextOption?.isAction && nextOption?.value !== activeOption?.value;

		const currentValues = currentOptions.map((option) =>
			option.getAttribute(OPTION_VALUE_ATTRIBUTE)
		);

		const nextValues = nextOptions.map((option) => option.getAttribute(OPTION_VALUE_ATTRIBUTE));

		const listIsUnchanged =
			nextValues.length === currentValues.length &&
			nextValues.every((value, index) => {
				return currentValues[index] === value;
			});

		const listIsAppended =
			currentValues.length !== 0 &&
			nextValues.length > currentValues.length &&
			currentValues.every((value, index) => {
				return nextValues[index] === value;
			});

		if (listIsUnchanged) {
			if (optionIsAlreadyActive && actionContentHasUpdated) {
				currentOptions = nextOptions;
				handleChangeActiveOption(nextOption);
			}

			return;
		}

		if (listIsAppended) {
			currentOptions = nextOptions;
			return;
		}

		currentOptions = nextOptions;

		if (lazyLoading) {
			lazyLoading = false;
			return;
		}

		handleChangeActiveOption(nextOption);
	};

	$effect(() => {
		if (autoSelection !== AutoSelection.None && !loading) {
			resetActiveOption();
		}
	});

	$effect(() => {
		if (listboxRef) {
			scrollableRef = listboxRef.closest(scrollable.selector);
		}
	});

	$effect(() => {
		if (enableKeyboardControl && !keyboardEventsEnabled) {
			enableKeyboardEvents();
		}
	});

	const onOptionSelect = (option: NavigableOption) => {
		handleChangeActiveOption(option);

		if (comboboxListBoxContext()?.onOptionSelected) comboboxListBoxContext()?.onOptionSelected?.();
		if (onSelect) onSelect(option.value);
	};

	const getNextIndex = (currentIndex: number, lastIndex: number, direction: string) => {
		let nextIndex;

		if (direction === 'down') {
			if (currentIndex === lastIndex) {
				nextIndex = comboboxListBoxContext()?.willLoadMoreOptions ? currentIndex + 1 : 0;
			} else {
				nextIndex = currentIndex + 1;
			}
		} else {
			nextIndex = currentIndex === 0 ? lastIndex : currentIndex - 1;
		}

		return nextIndex;
	};

	const getNextValidOption = async (key: ArrowKeys) => {
		const lastIndex = currentOptions.length - 1;
		let currentIndex = activeOption?.index || 0;
		let nextIndex = 0;
		let element = activeOption?.element;
		let totalOptions = -1;

		if (!activeOption && autoSelection === AutoSelection.None) {
			const nextOptions = getNavigableOptions();
			const nextActiveOption = getFirstNavigableOption(nextOptions);
			currentOptions = nextOptions;
			return {
				element: nextActiveOption?.element,
				nextIndex: nextActiveOption?.index || 0
			};
		}

		while (totalOptions++ < lastIndex) {
			nextIndex = getNextIndex(currentIndex, lastIndex, key);
			element = currentOptions[nextIndex];
			const triggerLazyLoad = nextIndex >= lastIndex;
			const isDisabled = element?.getAttribute('aria-disabled') === 'true';

			if (triggerLazyLoad && comboboxListBoxContext()?.willLoadMoreOptions) {
				await handleKeyToBottom();
			}

			if (isDisabled) {
				currentIndex = nextIndex;
				element = undefined;
				continue;
			}

			break;
		}
		return { element, nextIndex };
	};

	const handleArrow = async (type: ArrowKeys, event: KeyboardEvent) => {
		event.preventDefault();
		const { element, nextIndex } = await getNextValidOption(type);
		if (!element) return;
		const nextOption = getFormattedOption(element, nextIndex);
		handleChangeActiveOption(nextOption);
	};

	const handleDownArrow = (event: KeyboardEvent) => {
		handleArrow('down', event);
	};

	const handleUpArrow = (event: KeyboardEvent) => {
		handleArrow('up', event);
	};

	const handleEnter = (event: KeyboardEvent) => {
		event.preventDefault();
		event.stopPropagation();
		if (activeOption) {
			onOptionSelect(activeOption);
		}
	};

	const handleFocus = () => {
		if (enableKeyboardControl) return;
		enableKeyboardEvents();
	};

	const handleBlur = (event: FocusEvent) => {
		event.stopPropagation();
		if (keyboardEventsEnabled) {
			const nextActiveOption = getFirstNavigableOption(currentOptions);

			if (nextActiveOption) {
				const { element, index } = nextActiveOption;
				const nextOption = getFormattedOption(element, index);
				handleChangeActiveOption(nextOption);
			}
		}
		if (enableKeyboardControl) return;
		disableKeyboardEvents();
	};

	const setLoading = (label?: string) => {
		loading = label;
	};

	const listboxContext = $derived({
		onOptionSelect,
		setLoading
	});
</script>

{#snippet listeners()}
	{#if keyboardEventsEnabled || comboboxListBoxContext()?.textFieldFocused}
		<KeypressListener keyEvent="keydown" keyCode={Key.DownArrow} handler={handleDownArrow} />
		<KeypressListener keyEvent="keydown" keyCode={Key.UpArrow} handler={handleUpArrow} />
		<KeypressListener keyEvent="keydown" keyCode={Key.Enter} handler={handleEnter} />
	{/if}
{/snippet}

{@render listeners()}

<Text as="span" visuallyHidden>
	<div aria-live="polite">{loading ? loading : null}</div>
</Text>

<ListboxContentProvider value={listboxContext}>
	<WithinListBoxContextProvider value>
		<ul
			role="listbox"
			class={styles.Listbox}
			aria-label={inCombobox ? undefined : accessibilityLabel}
			aria-labelledby={comboboxListBoxContext()?.textFieldLabelId}
			aria-busy={Boolean(loading)}
			aria-activedescendant={activeOption && activeOption.domId}
			tabindex="0"
			id={listId}
			onfocus={inCombobox ? undefined : handleFocus}
			onblur={inCombobox ? undefined : handleBlur}
			bind:this={listboxRef}
		>
			{@render children?.()}
		</ul>
	</WithinListBoxContextProvider>
</ListboxContentProvider>

```

# components/listbox/types.ts

```ts
import type { Snippet } from "svelte";

export enum AutoSelection {
    /** Default active option is the first selected option. If no options are selected, defaults to first interactive option. */
    FirstSelected = 'FIRST_SELECTED',
    /** Default active option is always the first interactive option. */
    First = 'FIRST',
    /** Default to the manual selection pattern. */
    None = 'NONE',
}

export interface ListboxProps {
    /** Inner content of the listbox */
    children: Snippet;
    /** Indicates the default active option in the list. Patterns that support option creation should default the active option to the first option.
     * @default AutoSelection.FirstSelected
     */
    autoSelection?: AutoSelection;
    /** Explicitly enable keyboard control */
    enableKeyboardControl?: boolean;
    /** Visually hidden text for screen readers */
    accessibilityLabel?: string;
    /** Provide a custom ID for the list element */
    customListId?: string;
    /** Callback fired when an option is selected */
    onSelect?(value: string): void;
    /** Callback fired when an option becomes active */
    onActiveOptionChange?(value: string, domId: string): void;
}

export type ArrowKeys = 'up' | 'down';

export const OPTION_SELECTOR = '[data-listbox-option]';
export const OPTION_VALUE_ATTRIBUTE = 'data-listbox-option-value';
export const OPTION_ACTION_ATTRIBUTE = 'data-listbox-option-action';
export const OPTION_FOCUS_ATTRIBUTE = 'data-focused';
```

# components/media-card/media-card.module.css

```css
.MediaCard {
    height: 100%;
    width: 100%;
    display: flex;
    flex-flow: row wrap;

    &.portrait {
        flex-flow: column nowrap;
    }

    @media (--p-breakpoints-md-down) {
        flex-flow: column nowrap;
    }
}

.MediaContainer {
    overflow: hidden;

    &:not(.portrait) {
        flex-basis: 40%;

        @media (--p-breakpoints-md-up) {
            border-top-right-radius: 0;
            border-top-left-radius: var(--p-border-radius-200);
            border-bottom-left-radius: var(--p-border-radius-200);
        }

        &.sizeSmall {
            flex-basis: 33%;
        }
    }

    @media (--p-breakpoints-sm-up) {
        border-top-left-radius: var(--p-border-radius-200);
        border-top-right-radius: var(--p-border-radius-200);
    }
}

.InfoContainer {
    position: relative;

    &:not(.portrait) {
        flex-basis: 60%;

        &.sizeSmall {
            flex-basis: 67%;
        }
    }
}

.ActionContainer {
    padding-top: var(--p-space-200);

    &.portrait {
        padding-top: var(--p-space-200);
    }

    @media (--p-breakpoints-md-down) {
        padding-top: var(--p-space-200);
    }
}
```

# components/media-card/media-card.svelte

```svelte
<script lang="ts">
	import { UseToggle } from '$lib/use/use-toggle.svelte.js';
	import styles from './media-card.module.css';
	import type { MediaCardProps } from './types.js';
	import Text from '$lib/components/text/text.svelte';
	import XIcon from '@shopify/polaris-icons/dist/svg/XIcon.svg?component';
	import Button from '../button/button.svelte';
	import InlineStack from '../inline-stack/inline-stack.svelte';
	import MenuHorizontalIcon from '@shopify/polaris-icons/dist/svg/MenuHorizontalIcon.svg?component';
	import ActionList from '../action-list/action-list.svelte';
	import ButtonFrom from '../button/button-from.svelte';
	import { classNames } from '$utilities/css.js';
	import ButtonGroup from '../button-group/index.js';
	import Box from '../box/box.svelte';
	import LegacyCard from '../legacy-card/index.js';
	import BlockStack from '../block-stack/block-stack.svelte';
	import Popover from '../popover/index.js';

	let {
		title,
		children,
		primaryAction,
		secondaryAction,
		description,
		popoverActions = [],
		portrait = false,
		size = 'medium',
		onDismiss
	}: MediaCardProps = $props();

	const popoverActive = new UseToggle(false);
	const togglePopoverActive = popoverActive.toggle;
	const actionClassName = $derived(classNames(styles.ActionContainer, portrait && styles.portrait));
	const mediaCardClassName = $derived(classNames(styles.MediaCard, portrait && styles.portrait));

	const mediaContainerClassName = $derived(
		classNames(
			styles.MediaContainer,
			portrait && styles.portrait,
			size === 'small' && styles.sizeSmall
		)
	);

	const infoContainerClassName = $derived(
		classNames(
			styles.InfoContainer,
			portrait && styles.portrait,
			size === 'small' && styles.sizeSmall
		)
	);
</script>

{#snippet headerMarkup()}
	{#if title}
		{#snippet headerContent()}
			{#if typeof title === 'string'}
				<Text variant="headingSm" as="h2">
					{title}
				</Text>
			{:else}
				{@render title()}
			{/if}
		{/snippet}

		{@render headerContent()}
	{/if}
{/snippet}

{#snippet dismissButtonMarkup()}
	{#if onDismiss}
		<Button
			icon={XIcon}
			onClick={onDismiss}
			size="slim"
			accessibilityLabel="Dismiss"
			variant="tertiary"
		/>
	{/if}
{/snippet}

{#snippet popoverActivator()}
	<InlineStack blockAlign="center">
		<Button
			icon={MenuHorizontalIcon}
			onClick={togglePopoverActive}
			size="slim"
			accessibilityLabel="Actions"
			variant="tertiary"
		/>
	</InlineStack>
{/snippet}

{#snippet popoverActionsMarkup()}
	{#if popoverActions.length > 0}
		<Popover
			active={popoverActive.value}
			onClose={togglePopoverActive}
			preferredAlignment="left"
			preferredPosition="below"
		>
			{#snippet trigger()}
				  {@render popoverActivator()}
			{/snippet}
			<ActionList items={popoverActions} onActionAnyItem={togglePopoverActive} />
		</Popover>
	{/if}
{/snippet}

{#snippet primaryActionMarkup()}
	{#if primaryAction}
		<div>
			<ButtonFrom action={primaryAction} overrides={{ variant: 'primary' }} />
		</div>
	{/if}
{/snippet}

{#snippet secondaryActionMarkup()}
	{#if secondaryAction}
		<div>
			<ButtonFrom action={secondaryAction} overrides={{ variant: 'secondary' }} />
		</div>
	{/if}
{/snippet}

{#snippet actionMarkup()}
	<div class={actionClassName}>
		<ButtonGroup>
			<ButtonGroup.Item>
				{@render primaryActionMarkup()}
			</ButtonGroup.Item>
			<ButtonGroup.Item>
				{@render secondaryActionMarkup()}
			</ButtonGroup.Item>
		</ButtonGroup>
	</div>
{/snippet}

{#snippet popoverOrDismissMarkup()}
	<Box position="absolute" insetInlineEnd="500" zIndex="var(--p-z-index-2)">
		<InlineStack gap="100" wrap={false}>
			{@render popoverActionsMarkup()}
			{@render dismissButtonMarkup()}
		</InlineStack>
	</Box>
{/snippet}

<LegacyCard>
	<div class={mediaCardClassName}>
		<div class={mediaContainerClassName}>{@render children()}</div>
		<div class={infoContainerClassName}>
			<Box padding="500">
				<BlockStack gap="200">
					<InlineStack wrap={false} align="space-between" gap="200">
						{@render headerMarkup()}
						{@render popoverOrDismissMarkup()}
					</InlineStack>
					<Text as="p" variant="bodySm">
						{description}
					</Text>
					{@render actionMarkup()}
				</BlockStack>
			</Box>
		</div>
	</div>
</LegacyCard>

```

# components/media-card/types.ts

```ts
import type { ActionListItemDescriptor, ComplexAction } from "$utilities/types.js";
import type { Snippet } from "svelte";

// Type definitions for media-card
export type Size = 'small' | 'medium';

export interface MediaCardProps {
    /** The visual media to display in the card */
    children: Snippet;
    /** Heading content */
    title: Snippet | string;
    /** Body content */
    description: string;
    /** Main call to action, rendered as a basic button */
    primaryAction?: ComplexAction;
    /** Secondary call to action, rendered as a plain button */
    secondaryAction?: ComplexAction;
    /** Action list items to render in ellipsis popover */
    popoverActions?: ActionListItemDescriptor[];
    /** Whether or not card content should be laid out vertically
     * @default false
     */
    portrait?: boolean;
    /** Size of the visual media in the card
     * @default 'medium'
     */
    size?: Size;
    /** Callback when MediaCard is dismissed */
    onDismiss?: () => void;
}
```

# components/option-list/components/option/option.module.css

```css
.Option {
  /* stylelint-disable-next-line -- generated by polaris-migrator DO NOT COPY */
  @mixin unstyled-button;
  width: 100%;
  /* stylelint-disable-next-line -- polaris custom global property */
  min-height: var(--pg-control-height);
  text-align: left;
  text-decoration: none;
  border-radius: var(--p-border-radius-100);
  margin-top: var(--p-space-100);
  color: inherit;

  &:visited {
    color: inherit;
  }

  &:first-child {
    margin-top: 0;
  }
}

.SingleSelectOption {
  /* stylelint-disable-next-line -- generated by polaris-migrator DO NOT COPY */
  @mixin unstyled-button;
  text-align: left;

  display: flex;
  flex-wrap: nowrap;
  justify-content: space-between;

  /* stylelint-disable-next-line selector-max-specificity -- required for focus-visible support */
  &.focused:focus-visible:not(:active) {
    outline: var(--p-border-width-050) solid var(--p-color-border-focus);
    outline-offset: var(--p-space-025);
    background-color: var(--p-color-bg-surface-secondary-hover);
  }

  &.active {
    background: var(--p-color-bg-surface-secondary-selected);
  }

  &:not(.disabled) {
    color: inherit;
  }

  /* stylelint-disable-next-line selector-max-specificity -- specificity buster */
  &.select,
  &.select:hover:not(.disabled),
  &.active {
    font-weight: var(--p-font-weight-semibold);
    background: var(--p-color-bg-surface-secondary-active);
  }

  .Media {
    padding: 0 var(--p-space-200) 0 0;
  }
}

.Label,
.SingleSelectOption,
.MultiSelectOption {
  display: flex;
  align-items: flex-start;
  width: 100%;
  cursor: pointer;
  border-radius: var(--p-border-radius-200);
  padding: var(--p-space-150);
  /* stylelint-disable-next-line -- generated by polaris-migrator DO NOT COPY */
  @mixin text-breakword;

  &:hover:not(.disabled) {
    background-color: var(--p-color-bg-surface-secondary-hover);
  }

  &:active:not(.disabled) {
    background: var(--p-color-bg-surface-secondary-active);
  }

  /* stylelint-disable-next-line selector-max-specificity -- style consolidation */
  &:hover:not(.disabled),
  &:active:not(.disabled),
  &.select,
  &.select:hover:not(.disabled) {
    outline: var(--p-border-width-025) solid transparent;
  }

  .Media {
    padding: 0 var(--p-space-200) 0 0;
  }

  &.disabled {
    background: transparent;
    cursor: default;
    color: var(--p-color-text-disabled);
  }
}

.MultiSelectOption {
  &.select {

    /* stylelint-disable-next-line -- no way to select parent Checkbox class without :has() */
    &.CheckboxLabel {
      background-color: transparent;
    }

    svg {
      fill: var(--p-color-icon-active);
    }
  }

  /* stylelint-disable-next-line selector-max-specificity -- specificity buster */
  &.select:hover:not(.disabled) {
    background-color: var(--p-color-bg-surface-secondary-hover);
  }
}

/* stylelint-disable-next-line -- generated by polaris-migrator DO NOT COPY */
.disabled .Media svg {
  fill: var(--p-color-icon-disabled);
}

.Media svg {
  fill: var(--p-color-icon);
}

.verticalAlignTop {
  align-items: flex-start;
}

.verticalAlignCenter {
  align-items: center;
}

.verticalAlignBottom {
  align-items: flex-end;
}

.Icon {
  margin-left: var(--p-space-200);

  svg {
    fill: var(--p-color-icon-brand);
  }
}

.Checkbox {
  box-sizing: border-box;
  display: flex;
  flex-shrink: 0;
  width: 20px;
  height: 20px;
  margin-right: var(--p-space-200);
  align-items: center;
}
```

# components/option-list/components/option/option.svelte

```svelte
<script lang="ts">
	import Checkbox from '$lib/components/checkbox/checkbox.svelte';
	import Icon from '$lib/components/icon/icon.svelte';
	import InlineStack from '$lib/components/inline-stack/inline-stack.svelte';
	import { UseToggle } from '$lib/use/use-toggle.svelte.js';
	import { classNames, variationName } from '$utilities/css.js';
	import CheckIcon from '@shopify/polaris-icons/dist/svg/CheckIcon.svg?component';
	import styles from './option.module.css';
	import type { Alignment, OptionProps } from './types.js';
	import type { InlineStackProps } from '$lib/components/inline-stack/types.js';
	import Scrollable from '$lib/components/scrollable/index.js';

	let {
		label,
		value,
		id,
		select,
		active,
		allowMultiple,
		disabled,
		media,
		onClick,
		section,
		index,
		verticalAlign,
		onPointerEnter,
		onFocus
	}: OptionProps = $props();

	const focused = new UseToggle(false);
	const toggleFocused = focused.toggle;

	const handleClick = () => {
		if (disabled) {
			return;
		}

		onClick(section, index);
	};

	const handlePointerEnter = () => {
		if (disabled) {
			return;
		}

		onPointerEnter(section, index);
	};

	const handleFocus = () => {
		toggleFocused();

		onFocus(section, index);
	};

	const singleSelectClassName = $derived(
		classNames(
			styles.SingleSelectOption,
			focused && styles.focused,
			disabled && styles.disabled,
			select && styles.select,
			active && styles.active,
			verticalAlign && styles[variationName('verticalAlign', verticalAlign)]
		)
	);

	const multiSelectClassName = $derived(
		classNames(
			styles.Label,
			disabled && styles.disabled,
			active && styles.active,
			select && styles.select,
			verticalAlign && styles[variationName('verticalAlign', verticalAlign)],
			allowMultiple && styles.CheckboxLabel,
			allowMultiple && styles.MultiSelectOption
		)
	);

	function verticalAlignToBlockAlign(verticalAlign?: Alignment): InlineStackProps['blockAlign'] {
		switch (verticalAlign) {
			case 'top':
				return 'start';
			case 'center':
				return 'center';
			case 'bottom':
				return 'end';
			default:
				return 'start';
		}
	}
</script>

{#snippet mediaMarkup()}
	{#if media}
		<div class={styles.Media}>
			<media></media>
		</div>
	{/if}
{/snippet}

{#snippet optionMarkup()}
	{#if allowMultiple}
		<label for={id} class={multiSelectClassName}>
			<div class={styles.Checkbox}>
				<Checkbox
					{id}
					label=""
					ariaDescribedBy={`${id}-label`}
					{value}
					checked={select}
					{disabled}
					onChange={handleClick}
				/>
			</div>
			{@render mediaMarkup()}
			<span id={`${id}-label`}>{label}</span>
		</label>
	{:else}
		<button
			{id}
			type="button"
			class={singleSelectClassName}
			onclick={handleClick}
			{disabled}
			onfocus={handleFocus}
			onblur={toggleFocused}
			aria-pressed={active || select}
		>
			<InlineStack wrap={false} blockAlign={verticalAlignToBlockAlign(verticalAlign)}>
				{@render mediaMarkup()}
				{label}
			</InlineStack>
			{#if select || active}
				<span class={styles.Icon}>
					<Icon source={CheckIcon} />
				</span>
			{/if}
		</button>
	{/if}
{/snippet}

{#snippet scrollMarkup()}
	{#if active}
		<Scrollable.ScrollTo />
	{/if}
{/snippet}

<!-- svelte-ignore a11y_no_noninteractive_tabindex -->
<li class={styles.Option} tabindex={-1} onpointerenter={handlePointerEnter}>
	{@render scrollMarkup()}
	{@render optionMarkup()}
</li>

```

# components/option-list/components/option/types.ts

```ts
import type { AvatarProps } from "$lib/components/avatar/types.js";
import type { IconProps } from "$lib/components/icon/types.js";
import type { Component, Snippet } from "svelte";
import type { ThumbnailProps } from "$lib/components/thumbnail/types.js";
import type { VueNode } from "$utilities/types.js";

export type Alignment = 'top' | 'center' | 'bottom';

export interface OptionProps {
  id: string;
  label: string | Snippet;
  value: string;
  section: number;
  index: number;
  media?: VueNode;
  disabled?: boolean;
  active?: boolean;
  select?: boolean;
  allowMultiple?: boolean;
  verticalAlign?: Alignment;
  onClick(section: number, option: number): void;
  /** Callback when pointer enters the option */
  onPointerEnter(section: number, option: number): void;
  /** Callback when option is focused */
  onFocus(section: number, option: number): void;
}
```

# components/option-list/option-list.svelte

```svelte
<script lang="ts">
	import { arraysAreEqual } from '$utilities/arrays.js';
	import { isSection } from '$utilities/options.js';
	import type { Descriptor, OptionDescriptor, SectionDescriptor } from '$utilities/types.js';
	import Box from '../box/box.svelte';
	import Text from '../text/text.svelte';
	import type { OptionListProps } from './types.js';
	import Option from './components/option/option.svelte';
	import type { BoxProps } from '../box/types.js';
	import BlockStack from '../block-stack/block-stack.svelte';

	let {
		options,
		sections,
		title,
		selected,
		allowMultiple,
		role,
		verticalAlign,
		onChange,
		id: idProp,
		onPointerEnterOption,
		onFocusOption
	}: OptionListProps = $props();

	function createNormalizedOptions(
		options?: OptionDescriptor[],
		sections?: SectionDescriptor[],
		title?: string
	): SectionDescriptor[] {
		if (options == null) {
			const section = { options: [], title };
			return sections == null ? [] : [section, ...sections];
		}
		if (sections == null) {
			return [
				{
					title,
					options
				}
			];
		}
		return [
			{
				title,
				options
			},
			...sections
		];
	}

	function optionArraysAreEqual(firstArray: Descriptor[], secondArray: Descriptor[]) {
		if (isSection(firstArray) && isSection(secondArray)) {
			return arraysAreEqual<SectionDescriptor>(firstArray, secondArray, testSectionsPropEquality);
		}

		return arraysAreEqual(firstArray, secondArray);
	}

	function testSectionsPropEquality(
		previousSection: SectionDescriptor,
		currentSection: SectionDescriptor
	) {
		const { options: previousOptions } = previousSection;
		const { options: currentOptions } = currentSection;
		const optionsAreEqual = arraysAreEqual(previousOptions, currentOptions);
		const titlesAreEqual = previousSection.title === currentSection.title;
		return optionsAreEqual && titlesAreEqual;
	}

	let normalizedOptions = $state(createNormalizedOptions(options, sections, title));

	$effect(() => {
		if (!optionArraysAreEqual(options ?? [], sections ?? [])) {
			normalizedOptions = createNormalizedOptions(options, sections, title);
		}
	});

	const handleClick = (sectionIndex: number, optionIndex: number) => {
		const selectedValue = normalizedOptions[sectionIndex].options[optionIndex].value;
		const foundIndex = selected.indexOf(selectedValue);
		if (allowMultiple) {
			const newSelection =
				foundIndex === -1
					? [selectedValue, ...selected]
					: [...selected.slice(0, foundIndex), ...selected.slice(foundIndex + 1, selected.length)];
			onChange(newSelection);
			return;
		}
		onChange([selectedValue]);
	};

	const handlePointerEnter = (sectionIndex: number, optionIndex: number) => {
		if (!onPointerEnterOption) return;

		const selectedValue = normalizedOptions[sectionIndex].options[optionIndex].value;

		onPointerEnterOption(selectedValue);
	};

	const handleFocus = (sectionIndex: number, optionIndex: number) => {
		if (!onFocusOption) return;

		const selectedValue = normalizedOptions[sectionIndex].options[optionIndex].value;

		onFocusOption(selectedValue);
	};

	const optionsExist = $derived(normalizedOptions.length > 0);
</script>

{#snippet optionsMarkup()}
	{#if optionsExist}
		{#each normalizedOptions as { title, options }, sectionIndex}
			{@const isFirstOption = sectionIndex === 0}
			{@const titleLevel = isFirstOption ? 'h2' : 'h3'}

			{#snippet titleMarkup()}
				{#if title}
					<Box
						paddingBlockStart={isFirstOption ? '050' : '300'}
						paddingInlineStart="150"
						paddingBlockEnd="100"
						paddingInlineEnd="150"
						borderColor="border-secondary"
					>
						<Text as={titleLevel} variant="headingSm">
							{title}
						</Text>
					</Box>
				{/if}
			{/snippet}

			{#snippet optionMarkup()}
				{#each options as option, optionIndex}
					{@const isSelected = selected.includes(option.value)}
					{@const optionId = option.id || `${idProp}-${sectionIndex}-${optionIndex}`}

					<Option
						{...option}
						id={optionId}
						section={sectionIndex}
						index={optionIndex}
						onClick={handleClick}
						select={isSelected}
						{allowMultiple}
						{verticalAlign}
						onPointerEnter={handlePointerEnter}
						onFocus={handleFocus}
					/>
				{/each}
			{/snippet}

			{#snippet option()}
				<Box as="ul" id={`${idProp}-${sectionIndex}`} role={role as BoxProps['role']}>
					{@render optionMarkup()}
				</Box>
			{/snippet}

			{@const blockStartPadding = isFirstOption ? (title ? '100' : '0') : title ? '050' : '0'}

			<Box as="li" paddingBlockStart={blockStartPadding}>
				<BlockStack gap={isFirstOption && sections ? undefined : '0'}>
					{@render titleMarkup()}
					{@render option()}
				</BlockStack>
			</Box>
		{/each}
	{/if}
{/snippet}

<Box as="ul" role={role as BoxProps['role']} padding="150">
	{@render optionsMarkup()}
</Box>

```

# components/option-list/types.ts

```ts
import type { OptionDescriptor, SectionDescriptor } from "$utilities/types.js";

type Alignment = 'top' | 'center' | 'bottom';

export interface OptionListProps {
  /** A unique identifier for the option list */
  id?: string;
  /** List title */
  title?: string;
  /** Collection of options to be listed */
  options?: OptionDescriptor[];
  /** Defines a specific role attribute for the list itself */
  role?: 'listbox' | 'combobox' | string;
  /** Sections containing a header and related options */
  sections?: SectionDescriptor[];
  /** The selected options */
  selected: string[];
  /** Allow more than one option to be selected */
  allowMultiple?: boolean;
  /** Vertically align child content to the center, top, or bottom.  */
  verticalAlign?: Alignment;
  /** Callback when selection is changed */
  onChange(selected: string[]): void;
  /** Callback when pointer enters an option */
  onPointerEnterOption?(selected: string): void;
  /** Callback when focusing an option */
  onFocusOption?(selected: string): void;
}

```

# components/page-actions/page-actions.module.css

```css
.PageActions {
    margin: 0 auto;

    border-top: 0;
    padding: var(--p-space-400);

    @media (--p-breakpoints-sm-up) {
        padding: var(--p-space-400) 0;
    }
}
```

# components/page-actions/page-actions.svelte

```svelte
<script lang='ts'>
	import ButtonFrom from '../button/button-from.svelte';
	import InlineStack from '../inline-stack/inline-stack.svelte';
    import styles from './page-actions.module.css';
    import type { PageActionsProps } from './types.js';
    let { primaryAction, secondaryActions }: PageActionsProps = $props();
</script>

<div class={styles.PageActions}>
    <InlineStack gap="200" align="end">
        {#if primaryAction}
            {#if typeof primaryAction === 'function'}
                {@render primaryAction?.()}
            {:else}
                <ButtonFrom action={primaryAction} overrides={{ variant: 'primary' }} />
            {/if}
        {/if}
        {#if secondaryActions}
            {#if typeof secondaryActions === 'function'}
                {@render secondaryActions?.()}
            {:else}
                {#each secondaryActions as action}
                    <ButtonFrom action={action} overrides={{ variant: 'secondary' }} />
                {/each}
            {/if}
        {/if}
    </InlineStack>
</div>
```

# components/page-actions/types.ts

```ts
import type { ComplexAction, DisableableAction, LoadableAction } from "$utilities/types.js";
import type { Snippet } from "svelte";

export interface PageActionsProps {
    /** The primary action for the page */
    primaryAction?: (DisableableAction & LoadableAction) | Snippet;
    /** The secondary actions for the page */
    secondaryActions?: ComplexAction[] | Snippet;
}
```

# components/page/components/page-header/components/page-title/page-title.module.css

```css
.Title {
    &.TitleWithSubtitle {
        margin-top: 0;
    }
}

.TitleWrapper {
    display: flex;
    flex-wrap: wrap;
    align-items: center;
    row-gap: var(--p-space-200);
    padding-block: var(--p-space-050);

    .Title {
        display: inline;
        margin-right: var(--p-space-200);

        /* stylelint-disable-next-line selector-max-combinators -- generated by polaris-migrator DO NOT COPY */
        >* {
            display: inline;
        }
    }
}

.SubTitle {
    margin-top: var(--p-space-050);

    &.SubtitleCompact {
        margin-top: var(--p-space-050);
    }

    &.SubtitleMaxWidth {
        max-width: 45ch;
    }
}
```

# components/page/components/page-header/components/page-title/page-title.svelte

```svelte
<script lang="ts">
	import { classNames } from '$utilities/css.js';
	import type { TitleProps } from './types.js';
	import styles from './page-title.module.css';
	import Text from '$lib/components/text/text.svelte';
	import Bleed from '$lib/components/bleed/bleed.svelte';

	let { title, subtitle, titleMetadata, compactTitle, hasSubtitleMaxWidth }: TitleProps = $props();
	const className = $derived(() => classNames(styles.Title, subtitle && styles.TitleWithSubtitle));
</script>

{#snippet titleMarkup()}
	{#if title}
		<h1 class={className}>
			<Text as="span" variant="headingLg" fontWeight="bold">
				{title}
			</Text>
		</h1>
	{/if}
{/snippet}

{#snippet titleMetadataMarkup()}
	{#if titleMetadata}
		{#if typeof titleMetadata === 'string'}
			<Bleed marginBlock="100">{titleMetadata}</Bleed>
		{:else}
			<Bleed marginBlock="100">
				{@render titleMetadata()}
			</Bleed>
		{/if}
	{/if}
{/snippet}

{#snippet wrappedTitleMarkup()}
	<div class={styles.TitleWrapper}>
		{@render titleMarkup()}
		{@render titleMetadataMarkup()}
	</div>
{/snippet}

{#snippet subtitleMarkup()}
	{#if subtitle}
		<div
			class={classNames(
				styles.SubTitle,
				compactTitle && styles.SubtitleCompact,
				hasSubtitleMaxWidth && styles.SubtitleMaxWidth
			)}
		>
			<Text as="p" variant="bodySm" tone="subdued">
				{subtitle}
			</Text>
		</div>
	{/if}
{/snippet}

{@render wrappedTitleMarkup()}
{@render subtitleMarkup()}

```

# components/page/components/page-header/components/page-title/types.ts

```ts
import type { Snippet } from "svelte";

export interface TitleProps {
    /**
     * @deprecated Page title, in large type
     * Use `breadcrumbs` prop instead as documented [here](https://shopify.dev/docs/api/app-bridge/previous-versions/actions/titlebar#using-titlebar-with-polaris)
     */
    title?: string;
    /** Page subtitle, in regular type */
    subtitle?: string;
    /** Important status information shown immediately after the title. */
    titleMetadata?: Snippet;
    /** Removes spacing between title and subtitle */
    compactTitle?: boolean;
    /** Whether or not to add a max-width to the subtitle. Gets calculated by
     * the presence of either the secondaryActions or actionGroups props on the
     * Header that consumes this component */
    hasSubtitleMaxWidth?: boolean;
}
```

# components/page/components/page-header/page-header.module.css

```css
.TitleWrapper {
    grid-area: title;
    margin-top: var(--p-space-100);
    align-self: center;

    @media (--p-breakpoints-sm-up) {
        margin-top: 0;
    }

    &.TitleWrapperExpand {
        flex: 1 1 auto;
    }
}

.BreadcrumbWrapper {
    grid-area: breadcrumbs;

    a,
    button {
        background: transparent;
        border-radius: var(--p-border-radius-200);
        box-shadow: none;

        &:is(:hover, :focus, :focus-visible) {
            /* stylelint-disable-next-line declaration-no-important -- match button group */
            box-shadow: none !important;
        }

        &:is(:hover, :focus-visible) {
            background: var(--p-color-bg-fill-tertiary-hover);
        }

        &:focus {
            background: var(--p-color-bg-fill-tertiary-active);
            /* stylelint-disable-next-line declaration-no-important -- override box shadow */
            box-shadow: var(--p-shadow-inset-200) !important;
        }
    }
}

.PaginationWrapper {
    margin-left: var(--p-space-200);
    line-height: 1;
}

.PrimaryActionWrapper {
    margin-top: 0;
    margin-left: var(--p-space-100);

    @media (--p-breakpoints-md-up) {
        margin-left: var(--p-space-200);
    }
}

.Row {
    display: flex;
    justify-content: space-between;
    line-height: normal;

    &:first-child {
        min-height: 28px;
    }

    +.Row {
        margin-top: var(--p-space-050);

        /* stylelint-disable-next-line selector-max-combinators, selector-max-class -- generated by polaris-migrator DO NOT COPY */
        .mobileView & {
            margin-top: var(--p-space-100);
        }

        /* stylelint-disable-next-line selector-max-combinators, selector-max-class -- generated by polaris-migrator DO NOT COPY */
        .RightAlign {
            margin-left: 0;
        }
    }
}

.RightAlign {
    grid-area: actions;
    display: flex;
    align-content: flex-end;
    flex: 1 1 auto;
    align-items: center;
    align-self: flex-start;
    justify-content: flex-end;
    margin-left: var(--p-space-400);

    /* Necessary for flex to realize this container doesn't want to wrap */
    white-space: nowrap;

    .noBreadcrumbs & {
        @media (--p-breakpoints-sm-down) {
            margin-left: 0;
        }
    }
}

.AdditionalMetaData {
    @media (--p-breakpoints-sm-up) {
        margin-left: calc(var(--p-space-500) + var(--p-space-200) + var(--p-space-100));
    }

    .noBreadcrumbs & {
        margin-left: 0;
    }
}

.Actions {
    width: 100%;
    display: flex;
    align-items: center;
    justify-content: flex-end;
    text-align: right;
}

/* stylelint-disable-next-line scss/at-rule-no-unknown -- Can't easily dedupe this one */
@define-mixin condensed-layout {
    .AdditionalMetaData {
        margin-left: 0;
    }

    .Row {
        display: grid;
        gap: var(--p-space-200) var(--p-space-400);
        grid-template-columns: auto 1fr;
        grid-template-areas: 'breadcrumbs actions' 'title title';

        +.Row {
            gap: 0;
        }
    }
}

.longTitle {
    @media (--p-breakpoints-lg-down) {
        @mixin condensed-layout;
    }
}

.mediumTitle:not(.noBreadcrumbs) {
    @media (--p-breakpoints-md-down) {
        @mixin condensed-layout;
    }
}

.mediumTitle.noBreadcrumbs {

    /* stylelint-disable-next-line selector-max-class -- generated by polaris-migrator DO NOT COPY */
    .TitleWrapper {
        margin-top: 0;
    }

    /* stylelint-disable-next-line selector-max-class -- generated by polaris-migrator DO NOT COPY */
    .RightAlign {
        margin-bottom: var(--p-space-100);

        @media (--p-breakpoints-md-up) {
            margin-bottom: 0;
        }
    }

    /* stylelint-disable-next-line selector-max-class -- generated by polaris-migrator DO NOT COPY */
    .Row {
        flex-wrap: wrap-reverse;

        @media (--p-breakpoints-md-up) {
            flex-wrap: nowrap;
        }
    }
}

.isSingleRow .Row {
    gap: 0;
}
```

# components/page/components/page-header/page-header.svelte

```svelte
<script lang="ts">
	import type { Component, Snippet } from 'svelte';
	import styles from './page-header.module.css';
	import {
		isSvelteConstruct,
		LONG_TITLE,
		REALLY_SHORT_TITLE,
		SHORT_TITLE,
		type HeaderProps,
		type PrimaryAction
	} from './types.js';
	import Box from '$lib/components/box/box.svelte';
	import Breadcrumbs from '$lib/components/breadcrumbs/breadcrumbs.svelte';
	import Pagination from '$lib/components/pagination/pagination.svelte';
	import { classNames } from '$utilities/css.js';
	import PageTitle from './components/page-title/page-title.svelte';
	import Text from '$lib/components/text/text.svelte';
	import { isInterface } from '$utilities/is-interface.js';
	import ButtonFrom from '$lib/components/button/button-from.svelte';
	import Tooltip from '$lib/components/tooltip/tooltip.svelte';
	import { hasGroupsWithActions } from '$lib/components/action-menu/types.js';
	import ActionMenu from '$lib/components/action-menu/action-menu.svelte';
	import InlineStack from '$lib/components/inline-stack/inline-stack.svelte';
	import FilterActionsProvider from '$lib/components/app-provider/filteraction-provider.svelte';
	import ConditionalRender from '$lib/components/conditional-render/conditional-render.svelte';
	import { useContext } from '$utilities/contexts.js';
	import { MEDIA_QUERY_CONTEXT_KEY, type MediaQueryState } from '$lib/components/app-provider/types.js';

	let {
		title,
		subtitle,
		pageReadyAccessibilityLabel,
		titleMetadata,
		additionalMetadata,
		titleHidden = false,
		primaryAction,
		pagination,
		filterActions,
		backAction,
		secondaryActions = [],
		actionGroups = [],
		compactTitle = false,
		onActionRollup
	}: HeaderProps = $props();

	function isActionsArray(value: unknown): value is Record<string, any>[] {
		return Array.isArray(value);
	}

	const isSingleRow = $derived.by(() => {
		const noPrimaryAction = !primaryAction;
		const noPagination = !pagination;
		const minimalSecondaryActions =
			(isActionsArray(secondaryActions) && secondaryActions.length === 0) ||
			isSvelteConstruct(secondaryActions);
		const noActionGroups = !actionGroups || actionGroups.length === 0;

		return noPrimaryAction && noPagination && minimalSecondaryActions && noActionGroups;
	});

	const hasActionGroupsOrSecondaryActions = $derived.by(() => {
		const hasActionGroups = actionGroups && actionGroups.length > 0;
		const hasArrayOfSecondaryActions =
			isActionsArray(secondaryActions) && secondaryActions.length > 0;
		const hasConstructForSecondaryActions = isSvelteConstruct(secondaryActions);

		return hasActionGroups || hasArrayOfSecondaryActions || hasConstructForSecondaryActions;
	});

	const mediaQueryStateContext = useContext<MediaQueryState>(MEDIA_QUERY_CONTEXT_KEY);
	const labelForPageReadyAccessibilityLabel = $derived(pageReadyAccessibilityLabel || title);

	function shouldShowIconOnly(isMobile: boolean, action: PrimaryAction): PrimaryAction {
		let { content, accessibilityLabel } = action;
		const { icon } = action;
		if (icon == null) return { ...action, icon: undefined };

		if (isMobile) {
			accessibilityLabel = accessibilityLabel || content;
			content = undefined;
		}

		return {
			...action,
			content,
			accessibilityLabel,
			icon
		};
	}

	function notNull(value: any) {
		return value != null;
	}

	const headerClassNames = $derived(
		classNames(
			isSingleRow && styles.isSingleRow,
			(backAction || (pagination && !mediaQueryStateContext()?.isNavigationCollapsed)) && styles.hasNavigation,
			secondaryActions && styles.hasActionMenu,
			mediaQueryStateContext()?.isNavigationCollapsed && styles.mobileView,
			!backAction && styles.noBreadcrumbs,
			title && title.length < LONG_TITLE && styles.mediumTitle,
			title && title.length > LONG_TITLE && styles.longTitle
		)
	);

	function determineLayout({
		actionMenuMarkup,
		additionalMetadataMarkup,
		breadcrumbMarkup,
		isNavigationCollapsed,
		pageTitleMarkup,
		paginationMarkup,
		primaryActionMarkup,
		title
	}: {
		actionMenuMarkup: Snippet;
		additionalMetadataMarkup: Snippet;
		breadcrumbMarkup: Snippet;
		isNavigationCollapsed: boolean;
		pageTitleMarkup: Snippet;
		paginationMarkup: Snippet;
		primaryActionMarkup: Snippet;
		title?: string;
	}) {
		//    Header Layout
		// |----------------------------------------------------|
		// | slot1 | slot2 |                    | slot3 | slot4 |
		// |----------------------------------------------------|
		// | slot5 |                                            |
		// |----------------------------------------------------|
		//
		const layouts = {
			mobileCompact: {
				slots: {
					slot1: null,
					slot2: pageTitleMarkup,
					slot3: actionMenuMarkup,
					slot4: primaryActionMarkup,
					slot5: additionalMetadataMarkup
				},
				condition:
					isNavigationCollapsed &&
					breadcrumbMarkup == null &&
					title != null &&
					title.length <= REALLY_SHORT_TITLE
			},
			mobileDefault: {
				slots: {
					slot1: breadcrumbMarkup,
					slot2: pageTitleMarkup,
					slot3: actionMenuMarkup,
					slot4: primaryActionMarkup,
					slot5: additionalMetadataMarkup
				},
				condition: isNavigationCollapsed
			},
			desktopCompact: {
				slots: {
					slot1: breadcrumbMarkup,
					slot2: pageTitleMarkup,
					slot3: actionMenuMarkup,
					slot4: primaryActionMarkup,
					slot5: additionalMetadataMarkup
				},
				condition:
					!isNavigationCollapsed &&
					paginationMarkup == null &&
					actionMenuMarkup == null &&
					title != null &&
					title.length <= SHORT_TITLE
			},
			desktopDefault: {
				slots: {
					slot1: breadcrumbMarkup,
					slot2: pageTitleMarkup,
					slot3: { actionMenuMarkup, primaryActionMarkup },
					slot4: paginationMarkup,
					slot5: additionalMetadataMarkup
				},
				condition: !isNavigationCollapsed
			}
		};

		const layout =
			Object.values(layouts).find((layout) => layout.condition) || layouts.desktopDefault;

		return layout.slots;
	}

	const { slot1, slot2, slot3, slot4, slot5 } = determineLayout({
		actionMenuMarkup,
		additionalMetadataMarkup,
		breadcrumbMarkup,
		isNavigationCollapsed: mediaQueryStateContext()?.isNavigationCollapsed,
		pageTitleMarkup,
		paginationMarkup,
		primaryActionMarkup,
		title
	});
</script>
{@render slot5?.()}
{#snippet breadcrumbMarkup()}
	{#if backAction}
		<div class={styles.BreadcrumbWrapper}>
			<Box maxWidth="100%" paddingInlineEnd="100" printHidden>
				<Breadcrumbs {backAction} />
			</Box>
		</div>
	{/if}
{/snippet}

{#snippet paginationMarkup()}
	{#if pagination && !mediaQueryStateContext()?.isNavigationCollapsed}
		<div class={styles.PaginationWrapper}>
			<Box printHidden>
				<Pagination
					{...pagination}
					hasPrevious={pagination.hasPrevious}
					hasNext={pagination.hasNext}
				/>
			</Box>
		</div>
	{/if}
{/snippet}

{#snippet pageTitleMarkup()}
	<div
		class={classNames(
			styles.TitleWrapper,
			!hasActionGroupsOrSecondaryActions && styles.TitleWrapperExpand
		)}
	>
		<PageTitle
			{title}
			{subtitle}
			{titleMetadata}
			{compactTitle}
			hasSubtitleMaxWidth={hasActionGroupsOrSecondaryActions}
		/>
	</div>
{/snippet}

{#snippet pageReadyAccessibilityLabelMarkup()}
	{#if labelForPageReadyAccessibilityLabel}
		<div role="status">
			<Text visuallyHidden as="p">
				{labelForPageReadyAccessibilityLabel}
			</Text>
		</div>
	{/if}
{/snippet}

{#snippet primaryActionMarkup()}
	{#if primaryAction}
		{#if isInterface(primaryAction)}
			{@const { primary: isPrimary, helpText } = primaryAction}
			{@const primary = isPrimary === undefined ? true : isPrimary}

			{#snippet content()}
				{@const { content, accessibilityLabel, icon } = shouldShowIconOnly(
					mediaQueryStateContext()?.isNavigationCollapsed,
					primaryAction
				)}
				<ButtonFrom
					action={primaryAction}
					overrides={{
						variant: primary ? 'primary' : undefined,
						accessibilityLabel,
						icon
					}}
				/>
			{/snippet}

			{#snippet actionMarkup()}
				{#if helpText}
					{#if typeof helpText === 'string'}
						<Tooltip preferredPosition="below" content={helpText} />
					{/if}
				{:else}
					{@render content()}
				{/if}
			{/snippet}

			<div class={styles.PrimaryActionWrapper}>
				<Box printHidden>{@render actionMarkup()}</Box>
			</div>
		{:else}
			<div class={styles.PrimaryActionWrapper}>
				<Box printHidden>{@render primaryAction()}</Box>
			</div>
		{/if}
	{/if}
{/snippet}

{#snippet actionMenuMarkup()}
	{#if isInterface(secondaryActions) && (secondaryActions.length > 0 || hasGroupsWithActions(actionGroups))}
		<ActionMenu
			actions={secondaryActions}
			groups={actionGroups}
			rollup={mediaQueryStateContext()?.isNavigationCollapsed}
			rollupActionsLabel={title ? `View actions for ${title}` : undefined}
			{onActionRollup}
		/>
	{:else if isSvelteConstruct(secondaryActions)}
		{@render secondaryActions()}
	{/if}
{/snippet}

{#snippet navigationMarkup()}
	<Box
		printHidden
		paddingBlockEnd="100"
		paddingInlineEnd={secondaryActions && mediaQueryStateContext()?.isNavigationCollapsed ? '1000' : undefined}
	>
		<InlineStack gap="400" align="space-between" blockAlign="center">
			{@render breadcrumbMarkup()}
			{@render paginationMarkup()}
		</InlineStack>
	</Box>
{/snippet}

{#snippet additionalMetadataMarkup()}
	{#if additionalMetadata}
		<div class={styles.AdditionalMetaData}>
			<Text tone="subdued" as="span" variant="bodySm">
				{additionalMetadata}
			</Text>
		</div>
	{/if}
{/snippet}

<Box
	position="relative"
	paddingBlockStart={{ xs: '400', md: '600' }}
	paddingBlockEnd={{ xs: '400', md: '600' }}
	paddingInlineStart={{ xs: '400', sm: '0' }}
	paddingInlineEnd={{ xs: '400', sm: '0' }}
	visuallyHidden={titleHidden}
>
	{@render pageReadyAccessibilityLabelMarkup()}
	<div class={headerClassNames}>
		<FilterActionsProvider filterActions={Boolean(filterActions)}>
			<ConditionalRender condition={[slot1, slot2, slot3, slot4].some(notNull)}>
				<div class={styles.Row}>
					{@render slot1?.()}
					{@render slot2?.()}
					<ConditionalRender condition={[slot3, slot4].some(notNull)}>
						<div class={styles.RightAlign}>
							<div class={styles.Actions}>
								{#if typeof slot3 === 'function'}
									{@render slot3()}
								{:else if typeof slot3 === "object"}
									{@render slot3.actionMenuMarkup()}
									{@render slot3.primaryActionMarkup()}
								{/if}
								{@render slot4?.()}
							</div>
						</div>
					</ConditionalRender>
				</div>
			</ConditionalRender>
			<ConditionalRender condition={[slot5].some(notNull)}>
				<div class={styles.Row}>
					<InlineStack gap="400">{@render slot5?.()}</InlineStack>
				</div>
			</ConditionalRender>
		</FilterActionsProvider>
	</div>
</Box>

```

# components/page/components/page-header/types.ts

```ts
import type { DestructableAction, DisableableAction, LoadableAction, IconableAction, TooltipAction, MenuActionDescriptor, MenuGroupDescriptor } from "$utilities/types.js";
import type { Component, Snippet } from "svelte";
import type { TitleProps } from "./components/page-title/types.js";
import type { PaginationProps } from "$lib/components/pagination/types.js";
import type { BreadcrumbsProps } from "$lib/components/breadcrumbs/types.js";

export interface PrimaryAction
    extends DestructableAction,
    DisableableAction,
    LoadableAction,
    IconableAction,
    TooltipAction {
    /** Provides extra visual weight and identifies the primary action in a set of buttons */
    primary?: boolean;
}

export interface HeaderProps extends TitleProps {
    /** Visually hide the title */
    titleHidden?: boolean;
    /** A label to use for the page when the page is ready, used by screen readers. Will override the title prop if present */
    pageReadyAccessibilityLabel?: string;
    /** Enables filtering action list items */
    filterActions?: boolean;
    /** Primary page-level action */
    primaryAction?: PrimaryAction | Snippet;
    /** Page-level pagination */
    pagination?: PaginationProps;
    /**
     * @deprecated A back action link
     * Use `breadcrumbs` prop instead as documented [here](https://shopify.dev/docs/api/app-bridge/previous-versions/actions/titlebar#using-titlebar-with-polaris)
     */
    backAction?: BreadcrumbsProps['backAction'];
    /** Collection of secondary page-level actions */
    secondaryActions?: MenuActionDescriptor[] | Snippet;
    /** Collection of page-level groups of secondary actions */
    actionGroups?: MenuGroupDescriptor[];
    // Additional meta data
    additionalMetadata?: Snippet | string;
    /** Callback that returns true when secondary actions are rolled up into action groups, and false when not */
    onActionRollup?(hasRolledUp: boolean): void;
}

export const SHORT_TITLE = 20;
export const REALLY_SHORT_TITLE = 8;
export const LONG_TITLE = 34;

export function isSvelteConstruct(value: unknown): value is Snippet<any> {
    // Svelte Components and Snippets are functions when passed as props
    return typeof value === 'function';
}
```

# components/page/page.module.css

```css
html,
body {
    min-height: 100%;
    height: 100%;
}

.Page {
    /* stylelint-disable-next-line -- generated by polaris-migrator DO NOT COPY */
    @mixin page-layout;

    /* Ensure bottom margins of any children are contained */
    &::after {
        content: '';
        /* stylelint-disable-next-line declaration-property-value-disallowed-list -- generated by polaris-migrator DO NOT COPY */
        display: table;
    }
}

.fullWidth {
    max-width: none;
}

.narrowWidth {
    /* stylelint-disable-next-line -- polaris custom global property */
    max-width: var(--pg-layout-width-primary-max);
}

.Content {
    padding: var(--p-space-200) 0;

    @media (--p-breakpoints-md-up) {
        padding-top: var(--p-space-500);
    }
}
```

# components/page/page.svelte

```svelte
<script lang="ts">
	import { classNames } from '$utilities/css.js';
	import { isInterface } from '$utilities/is-interface.js';
	import PageHeader from './components/page-header/page-header.svelte';
	import { isSvelteConstruct } from './components/page-header/types.js';
	import styles from './page.module.css';
	import type { PageProps } from './types.js';
	let { children, fullWidth, narrowWidth, ...rest }: PageProps = $props();
	const pageClassName = $derived(
		classNames(styles.Page, fullWidth && styles.fullWidth, narrowWidth && styles.narrowWidth)
	);
	const hasHeaderContent = $derived(
		(rest.title != null && rest.title !== '') ||
			(rest.subtitle != null && rest.subtitle !== '') ||
			rest.primaryAction != null ||
			(rest.secondaryActions != null &&
				((isInterface(rest.secondaryActions) && rest.secondaryActions.length > 0) ||
					isSvelteConstruct(rest.secondaryActions))) ||
			(rest.actionGroups != null && rest.actionGroups.length > 0) ||
			rest.backAction != null
	);
	const contentClassName = $derived(classNames(!hasHeaderContent && styles.Content));
</script>

<div class={pageClassName}>
	{#if hasHeaderContent}
		<PageHeader filterActions {...rest} />
	{/if}
	<div class={contentClassName}>
		{@render children?.()}
	</div>
</div>

```

# components/page/types.ts

```ts
import type { Snippet } from "svelte";
import type { HeaderProps } from "./components/page-header/types.js";

// Type definitions for page
export interface PageProps extends HeaderProps {
    /** The contents of the page */
    children?: Snippet;
    /** Remove the normal max-width on the page */
    fullWidth?: boolean;
    /** Decreases the maximum layout width. Intended for single-column layouts */
    narrowWidth?: boolean;
}
```

# components/pagination/pagination.module.css

```css
.Pagination {
    button {
        /* stylelint-disable-next-line declaration-no-important -- override border */
        border: none !important;
        /* stylelint-disable-next-line declaration-no-important -- override box-shadow */
        box-shadow: none !important;
        background-color: var(--p-color-bg-fill-tertiary);

        &:hover {
            background-color: var(--p-color-bg-fill-tertiary-hover);
        }

        &:active {
            /* stylelint-disable-next-line declaration-no-important -- override box shadow */
            box-shadow: var(--p-shadow-inset-200) !important;
        }

        &:active,
        &:focus {
            background-color: var(--p-color-bg-fill-tertiary-active);
        }
    }

    &.table {
        border-top: 1px solid var(--p-color-border);

        button {
            --button-min-height: var(--p-height-700);
            background-color: var(--p-color-bg-surface-secondary-selected);
            min-height: var(--button-min-height);
            min-width: var(--button-min-height);
            height: var(--button-min-height);
            width: var(--button-min-height);
            display: flex;
            padding: unset;

            /* stylelint-disable -- override pagination buttons in tables  */
            &:hover {
                background-color: var(--p-color-bg-fill-tertiary-hover);

                svg {
                    fill: var(--p-color-icon-hover);
                }
            }

            &:active,
            &:focus {
                background-color: var(--p-color-bg-fill-tertiary-active);

                svg {
                    fill: var(--p-color-icon-active);
                }
            }

            &:disabled {
                svg {
                    fill: var(--p-color-icon-disabled);
                }
            }

            /* stylelint-enable */
        }
    }
}

.TablePaginationActions {
    display: flex;
    gap: var(--p-space-025);
    align-items: center;
    justify-content: center;
}
```

# components/pagination/pagination.svelte

```svelte
<script lang="ts">
	import { isInputFocused } from '$utilities/is-input-focused.js';
	import ChevronLeftIcon from '@shopify/polaris-icons/dist/svg/ChevronLeftIcon.svg?component';
	import Button from '../button/button.svelte';
	import styles from './pagination.module.css';
	import type { PaginationProps } from './types.js';
	import Tooltip from '../tooltip/tooltip.svelte';
	import ChevronRightIcon from '@shopify/polaris-icons/dist/svg/ChevronRightIcon.svg?component';
	import { noop } from '$utilities/noop.js';
	import KeypressListener from '../keypress-listener/keypress-listener.svelte';
	import Box from '../box/box.svelte';
	import Text from '../text/text.svelte';
	import { classNames } from '$utilities/css.js';
	import InlineStack from '../inline-stack/inline-stack.svelte';
	import ButtonGroup from '../button-group/index.js';
	let {
		hasNext,
		hasPrevious,
		nextURL,
		previousURL,
		onNext,
		onPrevious,
		nextTooltip,
		previousTooltip,
		nextKeys,
		previousKeys,
		accessibilityLabel,
		accessibilityLabels,
		label,
		type = 'page'
	}: PaginationProps = $props();

	let node: HTMLElement | undefined = $state();
	const navLabel = accessibilityLabel || 'Pagination';
	const previousLabel = accessibilityLabels?.previous || 'Previous';
	const nextLabel = accessibilityLabels?.next || 'Next';

	function clickPaginationLink(id: string, node: HTMLElement) {
		return () => {
			if (node == null) {
				return;
			}

			const link: HTMLAnchorElement | null = node.querySelector(`#${id}`);
			if (link) {
				link.click();
			}
		};
	}

	function handleCallback(fn: () => void) {
		return () => {
			if (isInputFocused()) {
				return;
			}

			fn();
		};
	}

	const previousHandler = $derived(onPrevious || noop);
	const nextHandler = $derived(onNext || noop);
</script>

{#snippet prev()}
	<Button
		icon={ChevronLeftIcon}
		accessibilityLabel={previousLabel}
		url={previousURL}
		onClick={() => console.log('Previous')}
		disabled={!hasPrevious}
		id="previousURL"
	/>
{/snippet}
{#snippet constructedPrevious()}
	{#if previousTooltip && hasPrevious}
		<Tooltip content={previousTooltip}>
			{@render prev()}
		</Tooltip>
	{:else}
		{@render prev()}
	{/if}
{/snippet}

{#snippet next()}
	<Button
		icon={ChevronRightIcon}
		accessibilityLabel={nextLabel}
		url={nextURL}
		onClick={onNext}
		disabled={!hasNext}
		id="nextURL"
	/>
{/snippet}

{#snippet constructedNext()}
	{#if nextTooltip && hasNext}
		<Tooltip content={nextTooltip}>
			{@render next()}
		</Tooltip>
	{:else}
		{@render next()}
	{/if}
{/snippet}

{#snippet previousButtonEvents()}
	{#if previousKeys && (previousURL || onPrevious) && hasPrevious && node}
		{#each previousKeys as key}
			<KeypressListener
				handler={previousURL
					? handleCallback(clickPaginationLink('previousURL', node))
					: handleCallback(previousHandler)}
				keyCode={key}
				useCapture
			/>
		{/each}
	{/if}
{/snippet}

{#snippet nextButtonEvents()}
	{#if nextKeys && (nextURL || onNext) && hasNext && node}
		{#each nextKeys as key}
			<KeypressListener
				handler={nextURL
					? handleCallback(clickPaginationLink('nextURL', node))
					: handleCallback(nextHandler)}
				keyCode={key}
				useCapture
			/>
		{/each}
	{/if}
{/snippet}

{#snippet labelMarkup()}
	{#if label}
		<Box padding="300" paddingBlockStart="0" paddingBlockEnd="0">
			<Text as="span" variant="bodySm" fontWeight="medium">
				{#if typeof label === 'string'}
					{label}
				{:else}
					{@render label?.()}
				{/if}
			</Text>
		</Box>
	{/if}
{/snippet}

{#snippet labelTextMarkup()}
	{#if hasNext && hasPrevious}
		{#if typeof label === 'string'}
			<span>{label}</span>
		{:else}
			{@render label?.()}
		{/if}
	{:else}
		<Text tone="subdued" as="span">
			{#if typeof label === 'string'}
				{label}
			{:else}
				{@render label?.()}
			{/if}
		</Text>
	{/if}
{/snippet}

{#snippet labelMarkup1()}
	{#if label}
		<Box padding="300" paddingBlockStart="0" paddingBlockEnd="0">
			<div aria-live="polite">{@render labelTextMarkup()}</div>
		</Box>
	{/if}
{/snippet}

{#if type == 'table'}
	<nav aria-label={navLabel} bind:this={node} class={classNames(styles.Pagination, styles.table)}>
		{@render previousButtonEvents()}
		{@render nextButtonEvents()}

		<Box
			background="bg-surface-secondary"
			paddingBlockStart="150"
			paddingBlockEnd="150"
			paddingInlineStart="300"
			paddingInlineEnd="200"
		>
			<InlineStack align="center" blockAlign="center">
				<div class={styles.TablePaginationActions} data-buttongroup-variant="segmented">
					<div>{@render constructedPrevious()}</div>
					{@render labelMarkup()}
					<div>{@render constructedNext()}</div>
				</div>
			</InlineStack>
		</Box>
	</nav>
{:else}
	<nav aria-label={navLabel} bind:this={node} class={styles.Pagination}>
		{@render previousButtonEvents()}
		{@render nextButtonEvents()}
		<ButtonGroup variant="segmented">
			<ButtonGroup.Item>
				{@render constructedPrevious()}
			</ButtonGroup.Item>
			<ButtonGroup.Item>
				{@render labelMarkup1()}
			</ButtonGroup.Item>
			<ButtonGroup.Item>
				{@render constructedNext()}
			</ButtonGroup.Item>
		</ButtonGroup>
	</nav>
{/if}

```

# components/pagination/types.ts

```ts
import type { Key } from "$utilities/types.js";
import type { Snippet } from "svelte";

// Type definitions for pagination
export interface AccessibilityLabels {
    previous: string;
    next: string;
}

export interface PaginationProps {
    /** Keyboard shortcuts for the next button */
    nextKeys?: Key[];
    /** Keyboard shortcuts for the previous button */
    previousKeys?: Key[];
    /** Tooltip for the next button */
    nextTooltip?: string;
    /** Tooltip for the previous button */
    previousTooltip?: string;
    /** The URL of the next page */
    nextURL?: string;
    /** The URL of the previous page */
    previousURL?: string;
    /** Whether there is a next page to show */
    hasNext?: boolean;
    /** Whether there is a previous page to show */
    hasPrevious?: boolean;
    /** Accessible label for the pagination */
    accessibilityLabel?: string;
    /** Accessible labels for the buttons and UnstyledLinks */
    accessibilityLabels?: AccessibilityLabels;
    /** Callback when next button is clicked */
    onNext?(): void;
    /** Callback when previous button is clicked */
    onPrevious?(): void;
    /** Text to provide more context in between the arrow buttons */
    label?: Snippet|string;
    /** Layout structure of the component */
    type?: 'page' | 'table';
}
```

# components/placeholder/placeholder.svelte

```svelte
<script lang="ts">
	import { applyStyles } from '$utilities/css.js';

	let { height = 'auto', width = 'auto', showBorder = false } = $props();
</script>

<div
	style={applyStyles({
		background: 'var(--p-color-text-info)',
		height: height,
		width: width,
		borderInlineStart: showBorder ? '1px dashed var(--p-color-bg-surface-success)' : 'none'
	})}
></div>

```

# components/polaris-app-provider.svelte

```svelte
<script lang='ts'>
    import MediaQueryProvider from '$lib/components/app-provider/app-provider.svelte';
	import EphemeralPresenceManager from '$lib/components/app-provider/ephemeral-presence-manager.svelte';
	import StickymanagerProvider from '$lib/components/app-provider/stickymanager-provider.svelte';
    import { StickyManager } from '$utilities/sticky-manager/sticky-manager.js';
	import PortalsManager from '$lib/components/portals-manager/portals-manager.svelte';
    import PolarisStyles from '$lib/components/polaris-styles.svelte';
	import { onMount } from 'svelte';

    let { children } = $props();
    const stickyManager = new StickyManager();

    onMount(() => {
		stickyManager?.setContainer(document);
	});
</script>

<PolarisStyles />

<StickymanagerProvider value={stickyManager}>
	<MediaQueryProvider>
		<PortalsManager>
			<EphemeralPresenceManager>
				{@render children()}
			</EphemeralPresenceManager>
		</PortalsManager>
	</MediaQueryProvider>
</StickymanagerProvider>
```

# components/polaris-styles.svelte

```svelte
<script lang="ts">
	import '$lib/styles/polaris.css';
</script>

<svelte:head>
	<link rel="preconnect" href="https://cdn.shopify.com/" />
	<link rel="stylesheet" href="https://cdn.shopify.com/static/fonts/inter/v4/styles.css" />
</svelte:head>
```

# components/popover/components/pane/pane.svelte

```svelte
<script lang="ts">
	import Scrollable from '$lib/components/scrollable/scrollable.svelte';
	import { applyStyles, classNames } from '$utilities/css.js';
	import styles from '../../popover.module.css';
	import Section from '../section/section.svelte';
	import type { PaneProps } from './types.js';

	let {
		captureOverscroll = false,
		fixed,
		sectioned,
		children,
		height,
		maxHeight,
		minHeight,
		subdued,
		onScrolledToBottom
	}: PaneProps = $props();

	const className = $derived(
		classNames(
			styles.Pane,
			fixed && styles['Pane-fixed'],
			subdued && styles['Pane-subdued'],
			captureOverscroll && styles['Pane-captureOverscroll']
		)
	);

	const style = $derived({ height, maxHeight, minHeight });
</script>

{#snippet content()}
	{#if sectioned}
		<Section>
			{@render children?.()}
		</Section>
	{:else}
		{@render children?.()}
	{/if}
{/snippet}

{#if fixed}
	<div style={applyStyles(style)} class={className}>
		{@render content()}
	</div>
{:else}
	<Scrollable shadow class={className} {style} {onScrolledToBottom} scrollbarWidth="thin">
		{@render content()}
	</Scrollable>
{/if}

```

# components/popover/components/pane/types.ts

```ts
import type { Snippet } from "svelte";

export interface PaneProps {
    /** Fix the pane to the top of the popover */
    fixed?: boolean;
    /** Automatically wrap children in padded sections */
    sectioned?: boolean;
    /** The pane content */
    children?: Snippet;
    /** Sets a fixed height on the Scrollable */
    height?: string;
    /** Sets maxHeight on the Scrollable */
    maxHeight?: string;
    /** Sets minHeight on the Scrollable */
    minHeight?: string;
    /** Callback when the bottom of the popover is reached by mouse or keyboard  */
    onScrolledToBottom?(): void;
    /**
     * Prevents page scrolling when the end of the scrollable Popover content is reached
     * @default false
     */
    captureOverscroll?: boolean;
    /**
     * Sets a subdued background to the pane
     * @default false
     */
    subdued?: boolean;
}
```

# components/popover/components/popover-overlay/popover-overlay.svelte

```svelte
<script lang="ts">
	import { onDestroy, onMount, type Component } from 'svelte';
	import {
		nodeContainsDescendant,
		PopoverCloseSource,
		TransitionStatus,
		type PopoverOverlayProps,
		type PortalsContainerElement,
		type State
	} from './types.js';
	import { findFirstKeyboardFocusableNode } from '$utilities/focus.js';
	import { themeDefault } from '@shopify/polaris-tokens';
	import { applyStyles, classNames, variationName } from '$utilities/css.js';
	import styles from '../../popover.module.css';
	import PositionedOverlay from '$lib/components/positioned-overlay/positioned-overlay.svelte';
	import type { OverlayDetails } from '$lib/components/positioned-overlay/types.js';
	import { Rect } from '$utilities/geometry.js';
	import EventListener from '$lib/components/event-listener/event-listener.svelte';
	import KeypressListener from '$lib/components/keypress-listener/keypress-listener.svelte';
	import { Key } from '$utilities/types.js';
	import { overlay } from '$utilities/shared.js';
	import Pane from '../pane/pane.svelte';
	import { useContext, type PortalsManager } from '$utilities/contexts.js';
	import { PORTALS_MANAGER_CONTEXT_KEY } from '$utilities/portals/types.js';

	let {
		active,
		activator,
		fullWidth,
		preferredPosition = 'below',
		preferredAlignment = 'center',
		preferInputActivator = true,
		fixed,
		zIndexOverride,
		overlayRef = $bindable(),
		forceUpdatePosition = $bindable(),
		autofocusTarget = 'none',
		...rest
	}: PopoverOverlayProps = $props();

	let states: State = $state({
		transitionStatus: active ? TransitionStatus.Entered : TransitionStatus.Exited
	});

	let overlayDetails = $state<OverlayDetails>({
		activatorRect: new Rect({}),
		left: undefined,
		right: undefined,
		desiredHeight: 0,
		positioning: 'below',
		measuring: false,
		chevronOffset: 0
	});

	let contentNode = $state<HTMLDivElement>();
	let enteringTimer = $state<number>();
	let observer: ResizeObserver;
	let context = $derived(useContext<{container: PortalsContainerElement}>(PORTALS_MANAGER_CONTEXT_KEY)?.());

	function changeTransitionStatus(transitionStatus: TransitionStatus, cb?: () => void) {
		states = { transitionStatus };
		cb?.();
		// Forcing a reflow to enable the animation
		contentNode && contentNode.getBoundingClientRect();
	}

	function focusContent() {
		if (autofocusTarget === 'none' || contentNode == null) {
			return;
		}

		requestAnimationFrame(() => {
			if (contentNode == null) {
				return;
			}

			const focusableChild = findFirstKeyboardFocusableNode(contentNode);

			if (focusableChild && autofocusTarget === 'first-node') {
				focusableChild.focus({
					preventScroll: process.env.NODE_ENV === 'development'
				});
			} else {
				contentNode.focus({
					preventScroll: process.env.NODE_ENV === 'development'
				});
			}
		});
	}

	function clearTransitionTimeout() {
		if (enteringTimer) {
			window?.clearTimeout(enteringTimer);
		}
	}

	onMount(() => {
		if (active) {
			focusContent();
			changeTransitionStatus(TransitionStatus.Entered);
		}

		observer = new ResizeObserver(() => {
			states = {
				/**
				 * This is a workaround to enable event listeners to be
				 * re-attached when moving from one document to another
				 * when using a React portal across iframes.
				 * Using a resize observer works because when the clientWidth
				 * will go from 0 to the real width after the activator
				 * gets rendered in its new place.
				 */
				window: activator.ownerDocument.defaultView,
				transitionStatus: states.transitionStatus
			};
		});

		observer.observe(activator);
	});

	onDestroy(() => {
		clearTransitionTimeout();
		observer?.disconnect();
	});

	$effect(() => {
		if (active) {
			focusContent();
			changeTransitionStatus(TransitionStatus.Entered, () => {
				clearTransitionTimeout();
				enteringTimer = window?.setTimeout(
					() => {
						states = { transitionStatus: TransitionStatus.Entered };
						// Important: This will not update when the active theme changes.
						// Update this to `useTheme` once converted to a function component.
					},
					parseInt(themeDefault.motion['motion-duration-100'], 10)
				);
			});
		}

		if (!active) {
			clearTransitionTimeout();
			states = { transitionStatus: TransitionStatus.Exited };
		}

		if (activator) {
			observer?.unobserve(activator);
			observer?.observe(activator);
		}
	});

	const className = $derived(
		classNames(
			styles.PopoverOverlay,
			states.transitionStatus === TransitionStatus.Entering && styles['PopoverOverlay-entering'],
			states.transitionStatus === TransitionStatus.Entered && styles['PopoverOverlay-open'],
			states.transitionStatus === TransitionStatus.Exiting && styles['PopoverOverlay-exiting'],
			preferredPosition === 'cover' && styles['PopoverOverlay-noAnimation']
		)
	);

	function wasContentNodeDescendant(
		composedPath: readonly EventTarget[],
		contentNode?: HTMLDivElement
	) {
		return contentNode != null && composedPath.includes(contentNode);
	}

	function wasPolarisPortalDescendant(
		composedPath: readonly EventTarget[],
		portalsContainerElement?: PortalsContainerElement
	): boolean {
		return composedPath.some(
			(eventTarget) => eventTarget instanceof Node && portalsContainerElement?.contains(eventTarget)
		);
	}

	function handleScrollOut() {
		rest.onClose(PopoverCloseSource.ScrollOut);
	}

	function handleClick(event: Event) {
		const target = event.target as HTMLElement;
		const composedPath = event.composedPath();
		const wasDescendant = rest.preventCloseOnChildOverlayClick
			? wasPolarisPortalDescendant(composedPath, context?.container)
			: wasContentNodeDescendant(composedPath, contentNode);
		const isActivatorDescendant = nodeContainsDescendant(activator, target);
		if (
			wasDescendant ||
			isActivatorDescendant ||
			states.transitionStatus !== TransitionStatus.Entered
		) {
			return;
		}

		rest.onClose(PopoverCloseSource.Click);
	}

	function handleEscape(event: Event) {
		const target = event.target as HTMLElement;
		const composedPath = event.composedPath();
		const wasDescendant = wasContentNodeDescendant(composedPath, contentNode);
		const isActivatorDescendant = nodeContainsDescendant(activator, target);

		if (wasDescendant || isActivatorDescendant) {
			rest.onClose(PopoverCloseSource.EscapeKeypress);
		}
	}

	const handleFocusFirstItem = (): void => {
		rest.onClose(PopoverCloseSource.FocusOut);
	};

	const handleFocusLastItem = (): void => {
		rest.onClose(PopoverCloseSource.FocusOut);
	};

	const isCovering = $derived(overlayDetails.positioning === 'cover');
	const contentStyles = $derived(
		overlayDetails.measuring ? undefined : { height: overlayDetails.desiredHeight }
	);

	const contentClassNames = $derived(
		classNames(
			styles.Content,
			rest.fullHeight && styles['Content-fullHeight'],
			rest.fluidContent && styles['Content-fluidContent']
		)
	);

	const { window } = $derived(states);

	const popoverClassName = $derived(
		classNames(
			styles.Popover,
			overlayDetails.measuring && styles.measuring,
			(fullWidth || isCovering) && styles.fullWidth,
			rest.hideOnPrint && styles['PopoverOverlay-hideOnPrint'],
			overlayDetails.positioning && styles[variationName('positioned', overlayDetails.positioning)]
		)
	);
</script>

{#snippet renderPopoverContent()}
	<Pane>
		{@render rest.children?.()}
	</Pane>
{/snippet}

{#snippet renderPopover()}
	<div class={popoverClassName} {...overlay.props}>
		<EventListener event="click" handler={handleClick} {window} />
		<EventListener event="touchstart" handler={handleClick} {window} />
		<KeypressListener keyCode={Key.Escape} handler={handleEscape} document={window?.document} />
		<div class={styles.FocusTracker} tabIndex={0} onfocus={handleFocusFirstItem}></div>
		<div class={styles.ContentContainer}>
			<div
				tabIndex={autofocusTarget === 'none' ? undefined : -1}
				class={contentClassNames}
				style={contentStyles ? applyStyles(contentStyles) : undefined}
				bind:this={contentNode}
			>
				{@render renderPopoverContent()}
			</div>
		</div>
		<!-- <div class={styles.FocusTracker} tabIndex={0} onfocus={handleFocusLastItem}></div> -->
	</div>
{/snippet}

<PositionedOverlay
	bind:overlayRef
	bind:overlayDetails
	bind:forceUpdatePosition
	{fullWidth}
	{active}
	{activator}
	{preferInputActivator}
	{preferredPosition}
	{preferredAlignment}
	{fixed}
	onScrollOut={handleScrollOut}
	classNames={className}
	{zIndexOverride}
>
	{@render renderPopover()}
</PositionedOverlay>

```

# components/popover/components/popover-overlay/types.ts

```ts
import type { PositionedOverlayProps } from "$lib/components/positioned-overlay/types.js";
import type { Snippet } from "svelte";

export enum PopoverCloseSource {
    Click,
    EscapeKeypress,
    FocusOut,
    ScrollOut,
}

export type PopoverAutofocusTarget = 'none' | 'first-node' | 'container';

export enum TransitionStatus {
    Entering = 'entering',
    Entered = 'entered',
    Exiting = 'exiting',
    Exited = 'exited',
}

export interface PopoverOverlayProps {
    children?: Snippet;
    fullWidth?: boolean;
    fullHeight?: boolean;
    fluidContent?: boolean;
    preferredPosition?: PositionedOverlayProps['preferredPosition'];
    preferredAlignment?: PositionedOverlayProps['preferredAlignment'];
    active: boolean;
    id: string;
    zIndexOverride?: number;
    activator: HTMLElement;
    preferInputActivator?: PositionedOverlayProps['preferInputActivator'];
    sectioned?: boolean;
    fixed?: boolean;
    hideOnPrint?: boolean;
    onClose(source: PopoverCloseSource): void;
    autofocusTarget?: PopoverAutofocusTarget;
    preventCloseOnChildOverlayClick?: boolean;
    captureOverscroll?: boolean;
    forceUpdatePosition?: () => void;
    overlayRef?: HTMLDivElement;
}

export interface State {
    transitionStatus: TransitionStatus;
    window?: Window | null;
}

export function nodeContainsDescendant(
    rootNode: HTMLElement,
    descendant: HTMLElement,
): boolean {
    if (rootNode === descendant) {
        return true;
    }

    let parent = descendant.parentNode;

    while (parent != null) {
        if (parent === rootNode) {
            return true;
        }
        parent = parent.parentNode;
    }

    return false;
}

export type PortalsContainerElement = HTMLDivElement | null;
```

# components/popover/components/section/section.svelte

```svelte
<script lang="ts">
	import type { Snippet } from 'svelte';
	import styles from '../../popover.module.css';
	import Box from '$lib/components/box/box.svelte';

	export interface SectionProps {
		children?: Snippet;
	}

	let { children }: SectionProps = $props();
</script>

<div class={styles.Section}>
	<Box
		paddingInlineStart="300"
		paddingInlineEnd="300"
		paddingBlockStart="200"
		paddingBlockEnd="150"
	>
		{@render children?.()}
	</Box>
</div>

```

# components/popover/index.ts

```ts
import PaneComponent from "./components/pane/pane.svelte";
import PopoverPolarisComponent from "./popover.svelte";
import SectionComponent from "./components/section/section.svelte";

type PopoverCompoundType = typeof PopoverPolarisComponent & {
    Pane: typeof PaneComponent;
    Section: typeof SectionComponent;
};


const Popover = PopoverPolarisComponent as PopoverCompoundType;
Popover.Pane = PaneComponent;
Popover.Section = SectionComponent;

export default Popover;

```

# components/popover/popover.module.css

```css
.Popover {
    /* stylelint-disable-next-line -- Polaris component custom properties */
    --pc-popover-visible-portion-of-arrow: 5px;
    /* stylelint-disable-next-line -- Polaris component custom properties */
    --pc-popover-vertical-motion-offset: -5px;
    max-width: calc(100vw - var(--p-space-800));
    /* stylelint-disable-next-line -- Polaris component custom properties */
    margin: var(--pc-popover-visible-portion-of-arrow) var(--p-space-200) var(--p-space-400);
    will-change: left, top;
    @mixin shadow-bevel var(--p-shadow-300), var(--p-border-radius-300), null, '',
    2;
}

.PopoverOverlay {
    opacity: 0;
    transition: opacity var(--p-motion-duration-100) var(--p-motion-ease),
        transform var(--p-motion-duration-100) var(--p-motion-ease);
    /* stylelint-disable-next-line -- Polaris component custom properties */
    transform: translateY(var(--pc-popover-vertical-motion-offset));
}

.PopoverOverlay-noAnimation {
    transition: opacity var(--p-motion-duration-100) var(--p-motion-ease);
}

.PopoverOverlay-entering {
    opacity: 1;
    transform: translateY(0);
}

.PopoverOverlay-open {
    opacity: 1;
    transform: none;
}

.measuring:not(.PopoverOverlay-exiting) {
    opacity: 0;
    /* stylelint-disable-next-line -- Polaris component custom properties */
    transform: translateY(var(--pc-popover-vertical-motion-offset));
}

.fullWidth {
    /* stylelint-disable-next-line -- Polaris component custom properties */
    margin: var(--pc-popover-visible-portion-of-arrow) auto 0 auto;

    .Content {
        max-width: none;
    }
}

.positionedAbove {
    /* stylelint-disable-next-line -- Polaris component custom properties */
    margin: var(--p-space-400) var(--p-space-200) var(--pc-popover-visible-portion-of-arrow);

    &.fullWidth {
        /* stylelint-disable-next-line -- Polaris component custom properties */
        margin: 0 auto var(--pc-popover-visible-portion-of-arrow) auto;
    }
}

.positionedCover {
    margin: 0;

    &::before {
        border-radius: var(--p-border-radius-200);
    }

    .ContentContainer {
        border-radius: var(--p-border-radius-200);
    }
}

.ContentContainer {
    position: relative;
    overflow: hidden;
    background: var(--p-color-bg-surface);
    border-radius: var(--p-space-300);

    /* Prevent Scrollable's box shadows overflowing the rounded corners of this
     * element on Safari prior to tech preview version 156.
     * See: https://bugs.webkit.org/show_bug.cgi?id=68196 */
    isolation: isolate;
}

.Content {
    position: relative;
    display: flex;
    flex-direction: column;
    border-radius: var(--p-border-radius-100);
    max-width: 400px;
    max-height: 500px;

    &:focus {
        outline: none;
    }
}

.Content-fullHeight {
    max-height: 100vh;
}

.Content-fluidContent {
    max-height: none;
    max-width: none;
}

.Pane {
    flex: 1 1 auto;
    max-width: 100%;

    &:focus {
        outline: none;
    }
}

.Pane-fixed {
    overflow: visible;
    flex: 0 0 auto;
}

.Pane-subdued {
    background-color: var(--p-color-bg-surface-secondary);
}

.Pane-captureOverscroll {
    overscroll-behavior: contain;
}

.Section {
    +.Section {
        border-top: var(--p-border-width-025) solid var(--p-color-border-secondary);
    }
}

.FocusTracker {
    /* stylelint-disable-next-line -- generated by polaris-migrator DO NOT COPY */
    @mixin visually-hidden;
}

.PopoverOverlay-hideOnPrint {
    @media print {
        /* stylelint-disable-next-line declaration-no-important -- Enforce print styles */
        display: none !important;
    }
}
```

# components/popover/popover.svelte

```svelte
<script lang="ts">
	import {
		findFirstFocusableNodeIncludingDisabled,
		focusNextFocusableNode
	} from '$utilities/focus.js';
	import { portal } from '$utilities/shared.js';
	import type { AriaAttributes } from 'svelte/elements';
	import { setActivatorAttributes, type PopoverProps } from './types.js';
	import PopoverOverlay from './components/popover-overlay/popover-overlay.svelte';
	import Portal from '../portal/portal.svelte';
	import { onMount, tick } from 'svelte';

	let {
		activatorWrapper = 'div',
		children,
		onClose,
		activator,
		preventFocusOnClose,
		active,
		fixed,
		ariaHaspopup,
		preferInputActivator = true,
		zIndexOverride,
		forceUpdatePosition,
		trigger,
		...rest
	}: PopoverProps = $props();

	let isDisplayed = $state(false);
	let activatorNode = $derived(activator);
	let overlayRef = $state<HTMLDivElement>();
	let activatorContainer = $state<HTMLElement>();
	const id = $props.id();

	enum PopoverCloseSource {
		Click,
		EscapeKeypress,
		FocusOut,
		ScrollOut
	}

	function isInPortal(element: Element) {
		let parentElement = element.parentElement;

		while (parentElement) {
			if (parentElement.matches(portal.selector)) return false;
			parentElement = parentElement.parentElement;
		}

		return true;
	}

	const handleClose = (source: PopoverCloseSource) => {
		onClose(source);

		if (activatorContainer == null || preventFocusOnClose) {
			return;
		}

		activatorNode?.setAttribute('data-state', active === true ? 'open' : 'close');

		if (source === PopoverCloseSource.FocusOut && activatorNode) {
			const focusableActivator =
				findFirstFocusableNodeIncludingDisabled(activatorNode) ||
				findFirstFocusableNodeIncludingDisabled(activatorContainer) ||
				activatorContainer;
			if (!focusNextFocusableNode(focusableActivator, isInPortal)) {
				focusableActivator.focus();
			}
		} else if (source === PopoverCloseSource.EscapeKeypress && activatorNode) {
			const focusableActivator =
				findFirstFocusableNodeIncludingDisabled(activatorNode) ||
				findFirstFocusableNodeIncludingDisabled(activatorContainer) ||
				activatorContainer;

			if (focusableActivator) {
				focusableActivator.focus();
			} else {
				focusNextFocusableNode(focusableActivator, isInPortal);
			}
		}
	};

	const setAccessibilityAttributes = () => {
		if (activatorContainer == null) {
			return;
		}

		const firstFocusable = findFirstFocusableNodeIncludingDisabled(activatorContainer);
		const focusableActivator: HTMLElement & {
			disabled?: boolean;
		} = firstFocusable || activatorContainer;

		const activatorDisabled =
			'disabled' in focusableActivator && Boolean(focusableActivator.disabled);

		setActivatorAttributes(focusableActivator, {
			id,
			active,
			ariaHaspopup: ariaHaspopup as AriaAttributes['aria-haspopup'],
			activatorDisabled
		});
	};

	function setDisplayState() {
		/**
		 * This is a workaround to prevent rendering the Popover when the content is moved into
		 * a React portal that hasn't been rendered. We don't want to render the Popover in this
		 * case because the auto-focus logic will break. We wait until the activatorContainer is
		 * displayed, which is when it has an offsetParent, or if the activatorContainer is the
		 * body, if it has a clientWidth bigger than 0.
		 * See: https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/offsetParent
		 */

		isDisplayed = Boolean(
			activatorContainer &&
				(activatorContainer.offsetParent !== null ||
					(activatorContainer === activatorContainer.ownerDocument.body &&
						activatorContainer.clientWidth > 0))
		);
	}

	$effect(() => {
		if (!activatorContainer) {
			return;
		}

		const observer = new ResizeObserver(setDisplayState);
		observer.observe(activatorContainer);

		setDisplayState();

		return () => {
			observer.disconnect();
		};
	});

	/* $effect(() => {
		if (!activatorNode && activatorContainer) {
			activatorNode = activatorContainer.firstElementChild as HTMLElement;
		} else if (activatorNode && activatorContainer && !activatorContainer.contains(activatorNode)) {
			//TODO:
			activatorNode = activatorContainer.firstElementChild as HTMLElement;
		}

		if (activatorNode && activatorContainer) {
			//TODO:
			activatorNode = activatorContainer.firstElementChild as HTMLElement;
		}

		setAccessibilityAttributes();
	}); */

	onMount(async () => {
		await tick();
		if (!activatorNode && activatorContainer) {
			activatorNode = activatorContainer.firstElementChild as HTMLElement;
		} else if (activatorNode && activatorContainer && !activatorContainer.contains(activatorNode)) {
			//TODO:
			activatorNode = activatorContainer.firstElementChild as HTMLElement;
		}

		if (activatorNode && activatorContainer) {
			//TODO:
			activatorNode = activatorContainer.firstElementChild as HTMLElement;
		}

		setAccessibilityAttributes();
	});

	// DONOT REMOVE THIS, HANDLES POSITIONING OF OVERLAY
	/* const renderActivator = (node: Node) => {
		forceUpdatePosition?.();
	}; */
</script>

{#snippet portalMarkup()}
	{#if activatorNode && isDisplayed && active}
		<Portal idPrefix="popover">
			<PopoverOverlay
				bind:overlayRef
				bind:forceUpdatePosition
				{id}
				activator={activatorNode}
				{preferInputActivator}
				onClose={handleClose}
				{active}
				{fixed}
				{zIndexOverride}
				{...rest}
			>
				{@render children?.()}
			</PopoverOverlay>
		</Portal>
	{/if}
{/snippet}

<svelte:element this={activatorWrapper}>
	<div bind:this={activatorContainer}>
		{@render trigger?.()}
	</div>

	{@render portalMarkup()}
</svelte:element>

```

# components/popover/types.ts

```ts
import type { Snippet } from "svelte";
import type { PopoverCloseSource } from "./components/popover-overlay/types.js";
import type { PopoverAutofocusTarget } from "./components/popover-overlay/types.js";
import type { PopoverOverlayProps } from "./components/popover-overlay/types.js";
import type { AriaAttributes } from "svelte/elements";

export type { PopoverCloseSource };
export type { PopoverAutofocusTarget };

export interface PopoverProps {
    /** The content to display inside the popover */
    children?: Snippet;
    /** The preferred direction to open the popover */
    preferredPosition?: PopoverOverlayProps['preferredPosition'];
    /** The preferred alignment of the popover relative to its activator */
    preferredAlignment?: PopoverOverlayProps['preferredAlignment'];
    /** Show or hide the Popover */
    active: boolean;
    /** The element to activate the Popover.
     * If using a button, use the default or tertiary variant
     * which will show an active state when popover is active
     */
    activator?: HTMLElement;
    /**
     * Use the activator's input element to calculate the Popover position
     * @default true
     */
    preferInputActivator?: PopoverOverlayProps['preferInputActivator'];
    /**
     * The element type to wrap the activator with
     * @default 'div'
     */
    activatorWrapper?: string;
    /** Override on the default z-index of 400 */
    zIndexOverride?: number;
    /** Prevents focusing the activator or the next focusable element when the popover is deactivated */
    preventFocusOnClose?: boolean;
    /** Automatically add wrap content in a section */
    sectioned?: boolean;
    /** Allow popover to stretch to the full width of its activator */
    fullWidth?: boolean;
    /** Allow popover to stretch to fit content vertically */
    fullHeight?: boolean;
    /** Allow popover content to determine the overlay width and height */
    fluidContent?: boolean;
    /** Remains in a fixed position */
    fixed?: boolean;
    /** Used to illustrate the type of popover element */
    ariaHaspopup?: string;
    /** Allow the popover overlay to be hidden when printing */
    hideOnPrint?: boolean;
    /** Callback when popover is closed */
    onClose(source: PopoverCloseSource): void;
    /**
     * The preferred auto focus target defaulting to the popover container
     * @default 'container'
     */
    autofocusTarget?: PopoverAutofocusTarget;
    /** Prevents closing the popover when other overlays are clicked */
    preventCloseOnChildOverlayClick?: boolean;
    /**
     * Prevents page scrolling when the end of the scrollable Popover overlay content is reached - applied to Pane subcomponent
     * @default false
     */
    captureOverscroll?: boolean;
    forceUpdatePosition?: () => void;
    trigger: Snippet;
}

export type CloseTarget = 'activator' | 'next-node';
export interface PopoverPublicAPI {
    forceUpdatePosition(): void;
    close(target?: CloseTarget): void;
}

export function setActivatorAttributes(
    activator: HTMLElement,
    {
        id,
        active = false,
        ariaHaspopup,
        activatorDisabled = false,
    }: {
        id: string;
        active: boolean;
        ariaHaspopup: AriaAttributes['aria-haspopup'];
        activatorDisabled: boolean;
    },
) {
    if (!activatorDisabled) {
        activator.tabIndex = activator.tabIndex || 0;
    }

    activator.setAttribute('aria-controls', id);
    activator.setAttribute('aria-owns', id);
    activator.setAttribute('aria-expanded', String(active));
    activator.setAttribute('data-state', active ? 'open' : 'closed');

    if (ariaHaspopup != null) {
        activator.setAttribute('aria-haspopup', String(ariaHaspopup));
    }
}
```

# components/portal/portal.svelte

```svelte
<script lang="ts">
	import { useContext, type PortalsManager } from '$utilities/contexts.js';
	import { noop } from '$utilities/noop.js';
	import { onMount } from 'svelte';
	import type { PortalProps } from './types.js';
	import ThemeProvider from '../theme-provider/theme-provider.svelte';
	import { isThemeNameLocal } from '../theme-provider/types.js';
	import { THEME_NAME_CONTEXT_KEY } from '$utilities/use-theme.js';
	import { themeNameDefault, type ThemeName } from '@shopify/polaris-tokens';
	import { browser } from '$app/environment';
	import { PORTALS_MANAGER_CONTEXT_KEY } from '$utilities/portals/types.js';

	let { children, idPrefix = '', onPortalCreated = noop }: PortalProps = $props();

	const themeNameContext = useContext<ThemeName>(THEME_NAME_CONTEXT_KEY);
	let context = useContext<PortalsManager | undefined>(PORTALS_MANAGER_CONTEXT_KEY);
	let container = $derived(context()?.container);
	const uniqueId = $props.id();
	const portalId = $derived(idPrefix !== '' ? `${idPrefix}-${uniqueId}` : uniqueId);
	const themeName = $derived(themeNameContext());

	onMount(() => {
		onPortalCreated();
	});

	function portal(node: HTMLElement, target = document.body) {
		let targetElement;

		function update(newTarget: string | HTMLElement) {
			if (typeof newTarget === 'string') {
				targetElement = document.querySelector(newTarget);
			} else {
				targetElement = newTarget;
			}

			if (targetElement && targetElement !== node.parentNode) {
				targetElement.appendChild(node);
			}
		}

		update(target);

		return {
			update,
			destroy() {
				if (node.parentNode) {
					node.parentNode.removeChild(node);
				}
			}
		};
	}
</script>

{#if browser}
	<div use:portal={container ?? undefined}>
		<ThemeProvider
			theme={themeName
				? isThemeNameLocal(themeName)
					? themeName
					: themeNameDefault
				: themeNameDefault}
			data-portal-id={portalId}
		>
			{@render children?.()}
		</ThemeProvider>,
	</div>
{/if}

```

# components/portal/types.ts

```ts
import type { Snippet } from "svelte";

export interface PortalProps {
    children?: Snippet;
    idPrefix?: string;
    onPortalCreated?(): void;
}
```

# components/portals-manager/components/portals-container/portals-container.svelte

```svelte
<script lang="ts">
	import type { PropsWithChildren } from '$utilities/props-with-children.js';
	import type { PolarisContainerProps } from './types.js';


	let { ref = $bindable(), ...rest }: PolarisContainerProps = $props();
</script>

<div id="PolarisPortalsContainer" {...rest} bind:this={ref}>
</div>


```

# components/portals-manager/components/portals-container/types.ts

```ts
import type { PortalsContainerElement } from "$utilities/contexts.js";

export interface PolarisContainerProps {
    ref?: PortalsContainerElement
}
```

# components/portals-manager/portals-manager.svelte

```svelte
<script lang="ts">
	import type { PortalsManagerProps } from './types.js';
	import PortalsContainer from './components/portals-container/portals-container.svelte';
	import PortalsContextProvider from '../app-provider/portals-context-provider.svelte';
	let { children, container }: PortalsManagerProps = $props();

	let contextContainer = $derived(container);
</script>

<PortalsContextProvider container={contextContainer}>
	{@render children?.()}
	{#if !container}
		<PortalsContainer bind:ref={contextContainer} />
	{/if}
</PortalsContextProvider>

```

# components/portals-manager/types.ts

```ts
import type { PortalsContainerElement } from "$utilities/contexts.js";
import type { Snippet } from "svelte";

export interface PortalsManagerProps {
    children: Snippet;
    container?: PortalsContainerElement;
}
```

# components/positioned-overlay/positioned-overlay.module.css

```css
.PositionedOverlay {
    position: absolute;
    z-index: var(--p-z-index-2);
}

.fixed {
    position: fixed;
}

.calculating {
    visibility: hidden;
}

.preventInteraction {
    pointer-events: none;
}
```

# components/positioned-overlay/positioned-overlay.svelte

```svelte
<script lang="ts">
	import { getRectForNode, Rect } from '$utilities/geometry.js';
	import { onDestroy, onMount, tick } from 'svelte';
	import styles from './positioned-overlay.module.css';
	import type { PositionedOverlayProps, Positioning, State } from './types.js';
	import { forNode } from '../scrollable/types.js';
	import { applyStyles, classNames } from '$utilities/css.js';
	import EventListener from '../event-listener/event-listener.svelte';
	import { dataPolarisTopBar, layer } from '$utilities/shared.js';
	import {
		calculateHorizontalPosition,
		calculateVerticalPosition,
		intersectionWithViewport,
		rectIsOutsideOfRect,
		windowRect
	} from '$utilities/math.js';
	let {
		activator,
		active,
		children,
		onScrollOut,
		preferInputActivator,
		preferredPosition,
		preferredAlignment,
		fullWidth,
		fixed,
		preventInteraction,
		classNames: suppliedClass,
		zIndexOverride,
		overlayRef = $bindable(),
		overlayDetails = $bindable(),
		forceUpdatePosition = $bindable()
	}: PositionedOverlayProps = $props();

	let states: State = $state({
		measuring: true,
		activatorRect: getRectForNode(activator),
		right: undefined,
		left: undefined,
		top: 0,
		height: 0,
		width: null,
		positioning: 'below',
		zIndex: null,
		outsideScrollableContainer: false,
		lockPosition: false,
		chevronOffset: 0
	});

	const setScrollableContainers = () => {
		const containers: (HTMLElement | Document)[] = [];
		let scrollableContainer = forNode(activator);

		if (scrollableContainer) {
			containers.push(scrollableContainer);

			while (scrollableContainer?.parentElement) {
				scrollableContainer = forNode(scrollableContainer.parentElement);

				containers.push(scrollableContainer);
			}
		}

		scrollableContainers = containers;
	};

	const registerScrollHandlers = () => {
		scrollableContainers.forEach((node) => {
			node.addEventListener('scroll', handleMeasurement);
		});
	};

	const unregisterScrollHandlers = () => {
		scrollableContainers.forEach((node) => {
			node.removeEventListener('scroll', handleMeasurement);
		});
	};

	onMount(async () => {
		setScrollableContainers();
		if (scrollableContainers.length && !fixed) {
			registerScrollHandlers();
		}

		await tick();
		handleMeasurement();
	});

	onDestroy(() => {
		observer?.disconnect();

		if (scrollableContainers.length && !fixed) {
			unregisterScrollHandlers();
		}
	});

	$effect(() => {
		const { outsideScrollableContainer, top } = states;

		if (active && onScrollOut != null && top !== 0 && outsideScrollableContainer) {
			onScrollOut();
		}

		overlayDetails = {
			activatorRect: states.activatorRect,
			left: states.left,
			right: states.right,
			desiredHeight: states.height,
			positioning: states.positioning,
			measuring: states.measuring,
			chevronOffset: states.chevronOffset
		};

		forceUpdatePosition = () => requestAnimationFrame(handleMeasurement);
	});

	function firstScrollableContainer(): HTMLElement | Document | null {
		return scrollableContainers[0] ?? null;
	}

	function isDocument(node: HTMLElement | Document | null): node is Document {
		return node?.ownerDocument === null;
	}

	function getMarginsForNode(node: HTMLElement) {
		// Accounts for when the node is moved between documents
		const window = node?.ownerDocument.defaultView || globalThis.window;
		const nodeStyles = window.getComputedStyle(node);
		return {
			activator: parseFloat(nodeStyles.marginTop || '0'),
			container: parseFloat(nodeStyles.marginBottom || '0'),
			horizontal: parseFloat(nodeStyles.marginLeft || '0')
		};
	}

	function getZIndexForLayerFromNode(node: HTMLElement) {
		const layerNode = node.closest(layer.selector) || node?.ownerDocument?.body;
		const zIndex =
			layerNode === node?.ownerDocument?.body
				? 'auto'
				: parseInt(window.getComputedStyle(layerNode).zIndex || '0', 10);
		return zIndex === 'auto' || isNaN(zIndex) ? null : zIndex;
	}

	const handleMeasurement = () => {
		const { lockPosition, top } = states;

		observer?.disconnect();
		if (overlayRef == null || firstScrollableContainer() == null) {
			return;
		}
		const document = activator?.ownerDocument;
		const preferredActivator = preferInputActivator
			? activator.querySelector('input') || activator
			: activator;
		const activatorRect = getRectForNode(preferredActivator);
		const currentOverlayRect = getRectForNode(overlayRef);
		const scrollableElement = isDocument(firstScrollableContainer())
			? document?.body
			: firstScrollableContainer();
		const scrollableContainerRect = scrollableElement ? getRectForNode(scrollableElement) : null;

		if (!scrollableContainerRect) {
			//throw new Error('Scrollable container rect is null, cannot calculate position');
			return;
		}

		const overlayRect =
			fullWidth || preferredPosition === 'cover'
				? new Rect({ ...currentOverlayRect, width: activatorRect.width })
				: currentOverlayRect;

		// If `body` is 100% height, it still acts as though it were not constrained to that size. This adjusts for that.
		if (scrollableElement === document.body && scrollableContainerRect) {
			scrollableContainerRect.height = document.body.scrollHeight;
		}

		let topBarOffset = 0;

		const topBarElement = scrollableElement?.querySelector(`${dataPolarisTopBar.selector}`);

		if (topBarElement) {
			topBarOffset = topBarElement.clientHeight;
		}

		let overlayMargins = { activator: 0, container: 0, horizontal: 0 };

		if (overlayRef.firstElementChild) {
			const nodeMargins = getMarginsForNode(overlayRef.firstElementChild as HTMLElement);
			overlayMargins = nodeMargins;
		}

		const containerRect = windowRect(activator);
		const zIndexForLayer = getZIndexForLayerFromNode(activator);
		const zIndex = zIndexForLayer == null ? zIndexForLayer : zIndexForLayer + 1;

		if (!preferredPosition) {
			throw new Error('preferredPosition is not provided');
		}

		if (!preferredAlignment) {
			throw new Error('preferredAlignment is not provided');
		}

		const verticalPosition = calculateVerticalPosition(
			activatorRect,
			overlayRect,
			overlayMargins,
			scrollableContainerRect,
			containerRect,
			preferredPosition,
			fixed,
			topBarOffset
		);

		const horizontalPosition = calculateHorizontalPosition(
			activatorRect,
			overlayRect,
			containerRect,
			overlayMargins,
			preferredAlignment
		);

		const chevronOffset =
			activatorRect.center.x - horizontalPosition + overlayMargins.horizontal * 2;

		states = {
			measuring: false,
			activatorRect: getRectForNode(activator),
			left: preferredAlignment !== 'right' ? horizontalPosition : undefined,
			right: preferredAlignment === 'right' ? horizontalPosition : undefined,
			top: lockPosition ? top : verticalPosition.top,
			lockPosition: Boolean(fixed),
			height: verticalPosition.height || 0,
			width: fullWidth || preferredPosition === 'cover' ? overlayRect.width : null,
			positioning: verticalPosition.positioning as Positioning,
			outsideScrollableContainer:
				onScrollOut != null &&
				rectIsOutsideOfRect(
					activatorRect,
					intersectionWithViewport(scrollableContainerRect, containerRect)
				),
			zIndex,
			chevronOffset
		};
	};

	let scrollableContainers: (HTMLElement | Document)[] = $state([]);
	let observer: MutationObserver | null = new MutationObserver(handleMeasurement);

	let positionedOverlayStyles = $derived({
		top: states.top == null || isNaN(states.top) ? undefined : states.top,
		left: states.left == null || isNaN(states.left) ? undefined : states.left,
		right: states.right == null || isNaN(states.right) ? undefined : states.right,
		width: states.width == null || isNaN(states.width) ? undefined : states.width,
		zIndex: zIndexOverride || states.zIndex || undefined
	});

	const className = $derived(
		classNames(
			styles.PositionedOverlay,
			fixed && styles.fixed,
			preventInteraction && styles.preventInteraction,
			suppliedClass
		)
	);
	
</script>

<div class={className} style="top: {positionedOverlayStyles.top}px; left: {positionedOverlayStyles.left}px; right: {positionedOverlayStyles.right}px; width: {positionedOverlayStyles.width}px; z-index: {positionedOverlayStyles.zIndex};" bind:this={overlayRef}>
	<EventListener
		event="resize"
		handler={handleMeasurement}
		window={overlayRef?.ownerDocument.defaultView}
	/>
	{@render children?.()}
</div>

```

# components/positioned-overlay/types.ts

```ts
import type { Rect } from "$utilities/geometry.js";
import type { PreferredAlignment, PreferredPosition } from "$utilities/math.js";
import type { Snippet } from "svelte";

export type Positioning = 'above' | 'below' | 'cover';

export interface OverlayDetails {
    left?: number;
    right?: number;
    desiredHeight: number;
    positioning: Positioning;
    measuring: boolean;
    activatorRect: Rect;
    chevronOffset: number;
}

export interface PositionedOverlayProps {
    active: boolean;
    activator: HTMLElement;
    preferInputActivator?: boolean;
    preferredPosition?: PreferredPosition;
    preferredAlignment?: PreferredAlignment;
    fullWidth?: boolean;
    fixed?: boolean;
    preventInteraction?: boolean;
    classNames?: string;
    zIndexOverride?: number;
    children?: Snippet;
    onScrollOut?(): void;
    overlayRef?: HTMLDivElement,
    overlayDetails: OverlayDetails,
    forceUpdatePosition?: () => void
}

export interface State {
    measuring: boolean;
    activatorRect: Rect;
    left?: number;
    right?: number;
    top: number;
    height: number;
    width: number | null;
    positioning: Positioning;
    zIndex: number | null;
    outsideScrollableContainer: boolean;
    lockPosition: boolean;
    chevronOffset: number;
}

export const OBSERVER_CONFIG = {
    childList: true,
    subtree: true,
    characterData: true,
    attributeFilter: ['style'],
};
```

# components/radio-button/radio-button.module.css

```css
.RadioButton {
    position: relative;
    margin: var(--p-space-025);
}

/* stylelint-disable selector-max-specificity, selector-max-class, selector-max-combinators -- code is much more readable this way */
.Input {
    /* stylelint-disable-next-line -- generated by polaris-migrator DO NOT COPY */
    @mixin visually-hidden;

    &:focus-visible+.Backdrop {
        outline: var(--p-border-width-050) solid var(--p-color-border-focus);
        outline-offset: var(--p-space-025);

        &::after {
            border-radius: var(--p-border-radius-full);
        }
    }

    &:checked+.Backdrop {

        &,
        /* Ideally we'd use a single `:where(.ChoiceLabel:hover) &` after all these*/
        /* selectors to set the hover styles, but because of browser support, we*/
        /* have to ensure the specificity of these rules are maintained when hovered*/
        /* and not hovered.*/
        .ChoiceLabel:hover & {
            border-color: var(--p-color-border-emphasis);

            &::before {
                background-color: var(--p-color-text-brand-on-bg-fill);
                transition: opacity var(--p-motion-duration-150) var(--p-motion-ease-out),
                    transform var(--p-motion-duration-150) var(--p-motion-ease-out);
                opacity: 1;
                transform: translate(-50%, -50%) scale(1);
            }
        }
    }

    &:checked:not([disabled])+.Backdrop {

        &,
        .ChoiceLabel:hover & {
            background-color: var(--p-color-bg-fill-brand-selected);
            border-color: var(--p-color-bg-fill-brand-selected);
        }
    }

    &.toneMagic:checked:not([disabled])+.Backdrop {

        &,
        .ChoiceLabel:hover & {
            background-color: var(--p-color-bg-fill-magic);
            border-color: var(--p-color-bg-fill-magic);
        }

        &::before {

            &,
            .ChoiceLabel:hover & {
                background-color: var(--p-color-text-magic-on-bg-fill);
            }
        }
    }

    +.Backdrop {
        .ChoiceLabel:hover & {
            cursor: pointer;
            border-color: var(--p-color-input-border-hover);
            background: var(--p-color-input-bg-surface-hover);
        }

        .ChoiceLabel:active & {
            border-color: var(--p-color-bg-fill-brand);
            border-width: var(--p-border-width-050);
        }
    }

    &:disabled+.Backdrop {

        &,
        .ChoiceLabel:hover & {
            cursor: default;
            background-color: var(--p-color-radio-button-bg-surface-disabled);
            border: none;

            &::before {
                background-color: var(--p-color-border-disabled);
            }
        }
    }

    &:disabled:checked+.Backdrop::before {

        &,
        .ChoiceLabel:hover & {
            background-color: var(--p-color-radio-button-icon-disabled);
        }
    }
}

/* stylelint-enable selector-max-specificity, selector-max-class, selector-max-combinators */

.Backdrop {
    /* stylelint-disable-next-line -- Polaris component custom properties */
    --pc-icon-size-small: 8px;

    /* ::before is the selected dot, ::after the focus-ring */

    @media (--p-breakpoints-md-down) {
        /* stylelint-disable-next-line -- Polaris component custom properties */
        --pc-icon-size-small: 10px;
    }

    position: relative;
    top: 0;
    left: 0;
    display: block;
    width: 100%;
    height: 100%;
    border: var(--p-border-width-0165) solid var(--p-color-input-border);
    border-radius: var(--p-border-radius-full);
    background-color: var(--p-color-input-bg-surface);
    transition: border-color var(--p-motion-duration-100) var(--p-motion-ease-out);

    &::before {
        content: '';
        position: absolute;
        top: 50%;
        left: 50%;
        opacity: 0;
        transform: translate(-50%, -50%) scale(0.1);
        transform-origin: 50% 50%;
        /* stylelint-disable-next-line -- generated by polaris-migrator DO NOT COPY */
        height: var(--pc-icon-size-small);
        /* stylelint-disable-next-line -- generated by polaris-migrator DO NOT COPY */
        width: var(--pc-icon-size-small);
        background-color: var(--p-color-bg-fill-brand);
        border-radius: var(--p-border-radius-full);
        transition: opacity var(--p-motion-duration-100) var(--p-motion-ease-out),
            transform var(--p-motion-duration-100) var(--p-motion-ease-out);

        @media (forced-colors: active) {
            border: var(--p-border-width-100) solid transparent;
        }
    }

    /* stylelint-disable-next-line -- generated by polaris-migrator DO NOT COPY */
    @mixin focus-ring base, var(--p-border-width-050);

    &::after {
        border-radius: var(--p-border-radius-full);
    }
}
```

# components/radio-button/radio-button.svelte

```svelte
<script lang="ts">
	import { classNames, variationName } from '$utilities/css.js';
	import Choice from '../choice/choice.svelte';
	import { helpTextID } from '../choice/types.js';
	import styles from './radio-button.module.css';
	import type { RadioButtonProps } from './types.js';
	let {
		ariaDescribedBy: ariaDescribedByProp,
		label,
		labelHidden,
		helpText,
		checked,
		disabled,
		onChange,
		onFocus,
		onBlur,
		id: idProp,
		name: nameProp,
		value,
		fill,
		bleed,
		bleedBlockStart,
		bleedBlockEnd,
		bleedInlineStart,
		bleedInlineEnd,
		tone
	}: RadioButtonProps = $props();

	const uniqId = $props.id();
	const id = idProp ?? uniqId;
	const name = nameProp || id;
	let inputNode = $state<HTMLInputElement | undefined>(undefined);

	const handleBlur = () => {
		onBlur && onBlur();
	};

	function handleChange({ currentTarget }: Event) {
		onChange && onChange((currentTarget as HTMLInputElement)?.checked, id);
	}

	const describedBy: string[] = $derived.by(() => {
		const newDescribedBy: string[] = [];
		if (helpText) {
			newDescribedBy.push(helpTextID(id));
		}
		if (ariaDescribedByProp) {
			newDescribedBy.push(ariaDescribedByProp);
		}
		return newDescribedBy;
	});

	const ariaDescribedBy = $derived(describedBy.length ? describedBy.join(' ') : undefined);

	const inputClassName = $derived(
		classNames(styles.Input, tone && styles[variationName('tone', tone)])
	);

	const extraChoiceProps = $derived({
		helpText,
		bleed,
		bleedBlockStart,
		bleedBlockEnd,
		bleedInlineStart,
		bleedInlineEnd
	});
</script>

<Choice
	{label}
	{labelHidden}
	{disabled}
	{id}
	labelClassName={styles.ChoiceLabel}
	{fill}
	{...extraChoiceProps}
	{...checked ? { tone } : {}}
>
	<span class={styles.RadioButton}>
		<input
			{id}
			{name}
			{value}
			type="radio"
			{checked}
			{disabled}
			class={inputClassName}
			onchange={handleChange}
			onfocus={onFocus}
			onblur={handleBlur}
			aria-describedby={ariaDescribedBy}
			bind:this={inputNode}
		/>
		<span class={styles.Backdrop}></span>
	</span>
</Choice>

```

# components/radio-button/types.ts

```ts
import type { ResponsiveProp } from "$utilities/css.js";
import type { ChoiceBleedProps } from "../choice/types.js";

export interface RadioButtonProps extends ChoiceBleedProps{
    /** Indicates the ID of the element that describes the radio button */
    ariaDescribedBy?: string;
    /** Label for the radio button */
    label: string;
    /** Visually hide the label */
    labelHidden?: boolean;
    /** Radio button is selected */
    checked?: boolean;
    /** Disable input */
    disabled?: boolean;
    /** ID for form input */
    id?: string;
    /** Name for form input */
    name?: string;
    /** Value for form input */
    value?: string;
    /** Callback when the radio button is toggled */
    onChange?(newValue: boolean, id: string): void;
    /** Callback when radio button is focused */
    onFocus?(): void;
    /** Callback when focus is removed */
    onBlur?(): void;
    /** Grow to fill the space. Equivalent to width: 100%; height: 100% */
    fill?: ResponsiveProp<boolean>;
    /** Additional text to aide in use */
    helpText?: string;
    /** Indicates the tone of the text field */
    tone?: 'magic';
}
```

# components/resource-item/base-resource-item.svelte

```svelte
<script lang="ts">
	import { SELECT_ALL_ITEMS } from '$utilities/index-provider/types.js';
	import type { ResourceListSelectedItems, VueNode } from '$utilities/types.js';
	import type { Alignment, CombinedProps, State } from './types.js';
	import Checkbox from '../checkbox/checkbox.svelte';
	import styles from './resource-item.module.css';
	import InlineStack from '../inline-stack/inline-stack.svelte';
	import { classNames } from '$utilities/css.js';
	import UnstyledLink from '../unstyled-link/unstyled-link.svelte';
	import Box from '../box/box.svelte';
	import InlineGrid from '../inline-grid/inline-grid.svelte';
	import type { InlineStackProps } from '../inline-stack/types.js';
	import ButtonGroup from '../button-group/button-group.svelte';
	import ButtonFrom from '../button/button-from.svelte';
	import Popover from '../popover/popover.svelte';
	import ActionList from '../action-list/action-list.svelte';
	import Button from '../button/button.svelte';
	import MenuHorizontalIcon from '@shopify/polaris-icons/dist/svg/MenuHorizontalIcon.svg?component';
	import { isSvelteConstruct } from '../page/components/page-header/types.js';

	let {
		id,
		children,
		url,
		external,
		media,
		shortcutActions,
		ariaControls,
		ariaExpanded,
		persistActions = false,
		accessibilityLabel,
		name,
		context,
		verticalAlignment,
		dataHref,
		breakpoints,
		onMouseOver,
		disabled,
		sortOrder,
		onClick,
		onMouseOut
	}: CombinedProps = $props();

	const {
		selectable,
		selectMode,
		hasBulkActions,
		loading,
		resourceName,
		onSelectionChange,
		selectedItems
	} = $derived(context);

	function isSelected(id: string, selectedItems?: ResourceListSelectedItems) {
		return Boolean(
			selectedItems &&
				((Array.isArray(selectedItems) && selectedItems.includes(id)) ||
					selectedItems === SELECT_ALL_ITEMS)
		);
	}

	let states: State = $derived({
		actionsMenuVisible: false,
		focused: false,
		focusedInner: false,
		selected: isSelected(id, selectedItems)
	});

	let node: HTMLDivElement | null = null;
	let overlayRef = $state<HTMLAnchorElement>();
	let buttonOverlay = $state<HTMLButtonElement>();
	const { actionsMenuVisible, focused, focusedInner, selected } = $derived(states);
	const checkboxAccessibilityLabel = name || accessibilityLabel || 'checkbox';

	$effect(() => {
		const newSelected = isSelected(id, selectedItems);
		if (states.selected !== newSelected) {
			states.selected = newSelected;
		}
	});

	function stopPropagation(event: Event) {
		event.stopPropagation();
	}

	function handleLargerSelectionArea(event: Event) {
		event.stopPropagation();
		handleSelection(states.selected, (event as MouseEvent).shiftKey);
	}

	const className = $derived(
		classNames(
			styles.ResourceItem,
			focused && styles.focused,
			selectable && styles.selectable,
			selected && styles.selected,
			selectMode && styles.selectMode,
			persistActions && styles.persistActions,
			focusedInner && styles.focusedInner,
			disabled && styles.disabled
		)
	);

	const listItemClassName = $derived(
		classNames(
			styles.ListItem,
			focused && !focusedInner && styles.focused,
			hasBulkActions && styles.hasBulkActions,
			selected && styles.selected,
			selectable && styles.selectable
		)
	);

	const tabIndex = $derived(loading ? -1 : 0);
	const ariaLabel = $derived(
		accessibilityLabel ||
			`View details for ${name || (resourceName && resourceName.singular) || ''}`
	);

	function getAlignment(alignment?: Alignment): InlineStackProps['blockAlign'] {
		switch (alignment) {
			case 'leading':
				return 'start';
			case 'trailing':
				return 'end';
			case 'center':
				return 'center';
			case 'fill':
				return 'stretch';
			case 'baseline':
				return 'baseline';
			default:
				return 'start';
		}
	}

	const handleFocus = (event: FocusEvent) => {
		if (event.target === buttonOverlay || (node && event.target === overlayRef)) {
			states.focused = true;
			states.focusedInner = false;
		} else if (node && node.contains(event.target as Node)) {
			states.focused = true;
			states.focusedInner = true;
		}
	};

	const handleBlur = ({ relatedTarget }: FocusEvent) => {
		if (node && relatedTarget instanceof Node && node.contains(relatedTarget)) {
			return;
		}

		states.focused = false;
		states.focusedInner = false;
	};

	const handleMouseOut = () => {
		states.focused && (states.focused = false);
		states.focusedInner && (states.focusedInner = false);
		if (onMouseOut) {
			onMouseOut();
		}
	};

	const handleSelection = (value: boolean, shiftKey: boolean) => {
		if (id == null || onSelectionChange == null) {
			return;
		}

		states.focused = value;
		states.focusedInner = value;
		onSelectionChange?.(value, id, sortOrder, shiftKey);
	};

	const handleClick = (event: MouseEvent) => {
		stopPropagation(event);
		const { ctrlKey, metaKey } = event;
		const anchor = node && node.querySelector('a');

		if (selectMode) {
			handleLargerSelectionArea(event);
			return;
		}

		if (anchor === event.target) {
			return;
		}

		if (onClick) {
			onClick(id);
		}

		if (url && (ctrlKey || metaKey)) {
			window.open(url, '_blank');
			return;
		}

		if (url && anchor) {
			anchor.click();
		}
	};

	// This fires onClick when there is a URL on the item
	const handleKeyUp = (event: KeyboardEvent) => {
		const { key } = event;

		if (key === 'Enter' && url && !selectMode && !disabled) {
			onClick?.();
		}
	};

	const handleActionsClick = () => {
		states.actionsMenuVisible = !states.actionsMenuVisible;
	};

	const handleCloseRequest = () => {
		states.actionsMenuVisible = false;
	};
</script>

{#snippet handleMarkup()}
	{#if selectable}
		<!-- svelte-ignore a11y_click_events_have_key_events -->
		<!-- svelte-ignore a11y_no_static_element_interactions -->
		<div class="CheckboxWrapper" onclick={stopPropagation} onchange={handleLargerSelectionArea}>
			<Checkbox
				{id}
				label={checkboxAccessibilityLabel}
				labelHidden
				checked={selected}
				disabled={loading || disabled}
				bleedInlineStart="300"
				bleedInlineEnd="300"
				bleedBlockStart="300"
				bleedBlockEnd="300"
				fill
				labelClassName={styles.CheckboxLabel}
			/>
		</div>
	{/if}
{/snippet}

{#snippet renderVueNode(vueNode: VueNode)}
	{#if isSvelteConstruct(vueNode)}
		{@render vueNode()}
	{:else}
		{vueNode}
	{/if}
{/snippet}

{#snippet ownedMarkup()}
	{#if media || selectable}
		<InlineStack
			gap="300"
			blockAlign={media && selectable ? 'center' : getAlignment(verticalAlignment)}
		>
			{@render handleMarkup()}
			{#if media}
				{@render renderVueNode(media)}
			{/if}
		</InlineStack>
	{/if}
{/snippet}

{#snippet actionsMarkup()}
	{#if shortcutActions && !loading}
		{#if persistActions}{/if}
	{/if}
{/snippet}

{#snippet accessibleMarkup()}
	{#if url}
		<UnstyledLink
			aria-describedby={id}
			aria-label={ariaLabel}
			className={styles.Link}
			{url}
			{external}
			{tabIndex}
			{id}
			ref={overlayRef}
		/>
	{:else}
		<button
			class={styles.Button}
			aria-label={ariaLabel}
			aria-controls={ariaControls}
			aria-expanded={ariaExpanded}
			onclick={handleClick}
			tabindex={tabIndex}
			bind:this={buttonOverlay}
		></button>
	{/if}
{/snippet}

{#snippet containerMarkup()}
	<Box
		{id}
		position="relative"
		paddingInlineStart="300"
		paddingInlineEnd="300"
		paddingBlockStart="300"
		paddingBlockEnd="300"
		zIndex="var(--pc-resource-item-content-stacking-order)"
	>
		<InlineGrid columns={{ xs: '1fr auto' }}>
			<InlineGrid columns={{ xs: media || selectable ? 'auto 1fr' : '1fr' }} gap="300">
				{@render ownedMarkup()}
				<InlineStack blockAlign={getAlignment(verticalAlignment)}>
					<Box width="100%" padding="0">
						{@render children?.()}
					</Box>
				</InlineStack>
			</InlineGrid>

			<!-- {@render actionsMarkup()}
			{@render disclosureMarkup()} -->
			{#if shortcutActions && !loading}
				{#if persistActions}
					{#if breakpoints?.lgUp}
						<!-- svelte-ignore a11y_click_events_have_key_events -->
						<!-- svelte-ignore a11y_no_static_element_interactions -->
						<div class={styles.Actions} onclick={stopPropagation}>
							<ButtonGroup>
								<ButtonFrom action={shortcutActions[1]} overrides={{ variant: 'tertiary' }} />
							</ButtonGroup>
						</div>
					{/if}

					{#if !selectMode && breakpoints?.lgDown}
						{@const disclosureAccessibilityLabel = name
							? `Actions for ${accessibilityLabel}`
							: `Actions dropdown`}
						<!-- svelte-ignore a11y_click_events_have_key_events -->
						<!-- svelte-ignore a11y_no_static_element_interactions -->
						<div onclick={stopPropagation}>
							<Popover onClose={handleCloseRequest} active={actionsMenuVisible}>
								{#snippet trigger()}
									<Button
										accessibilityLabel={disclosureAccessibilityLabel}
										onClick={handleActionsClick}
										variant="tertiary"
										icon={MenuHorizontalIcon}
									/>
								{/snippet}
								<ActionList items={shortcutActions} />
							</Popover>
						</div>
					{/if}
				{:else}
					<!-- svelte-ignore a11y_click_events_have_key_events -->
					<!-- svelte-ignore a11y_no_static_element_interactions -->
					<div class={styles.Actions} onclick={stopPropagation}>
						<Box position="absolute" insetBlockStart="400" insetInlineEnd="500">
							<ButtonGroup variant="segmented">
								<ButtonFrom action={shortcutActions[1]} overrides={{ variant: 'tertiary' }} />
							</ButtonGroup>
						</Box>
					</div>
				{/if}
			{/if}
		</InlineGrid>
	</Box>
{/snippet}

<li class={listItemClassName} data-href={dataHref}>
	<div class={styles.ItemWrapper}>
		<!-- svelte-ignore a11y_no_static_element_interactions -->
		<div
			bind:this={node}
			class={className}
			onclick={disabled ? () => {} : handleClick}
			onfocus={handleFocus}
			onblur={handleBlur}
			onkeyup={handleKeyUp}
			onmouseover={onMouseOver}
			onmouseout={handleMouseOut}
			data-href={url}
		>
			{#if !disabled}
				{@render accessibleMarkup()}
			{/if}
			{@render containerMarkup()}
		</div>
	</div>
</li>

```

# components/resource-item/resource-item.module.css

```css
.ResourceItem {
  /* stylelint-disable -- Polaris component custom properties */
  --pc-resource-item-min-height: 44px;
  --pc-resource-item-disclosure-width: 48px;
  --pc-resource-item-offset: 38px;
  --pc-resource-item-clickable-stacking-order: 1;
  --pc-resource-item-content-stacking-order: 2;
  --pc-resource-item-action-unhide-clip: auto;
  --pc-resource-item-action-hide-clip: rect(0, 0, 0, 0);
  --pc-resource-item-action-unhide-overflow: visible;
  --pc-resource-item-action-hide-overflow: hidden;
  /* stylelint-enable */
  outline: none;
  cursor: pointer;

  &:hover {
    background-color: var(--p-color-bg-surface-secondary-hover);

    .Actions {

      /* stylelint-disable-next-line selector-max-combinators -- show actions on hover */
      >* {
        /* stylelint-disable-next-line -- Polaris component custom properties */
        clip: var(--pc-resource-item-action-unhide-clip);
        /* stylelint-disable-next-line -- Polaris component custom properties */
        overflow: var(--pc-resource-item-action-unhide-overflow);
      }
    }
  }

  &:active {
    background-color: var(--p-color-bg-surface-active);
  }
}

.ItemWrapper {
  overflow: hidden;
  max-width: 100%;
}

.CheckboxWrapper {
  /* stylelint-disable -- Polaris component custom properties */
  z-index: var(--pc-resource-item-content-stacking-order);
  /* stylelint-enable -- Polaris component custom properties */

  /* Pass-through the item alignment to the underlaying .CheckboxLabel */
  display: flex;
  align-items: inherit;

  /* Fill the entire space so the nested <Checkbox fill> can use it all for its
     hit target. */
  height: 100%;
}

/* stylelint-disable-next-line selector-max-class -- generated by polaris-migrator DO NOT COPY */
.focusedInner,
.focusedInner.focused,
.focusedInner.focused.selected {
  box-shadow: none;
}

.Link,
.Button {
  position: absolute;
  /* stylelint-disable-next-line -- generated by polaris-migrator DO NOT COPY */
  z-index: var(--pc-resource-item-clickable-stacking-order);
  top: 0;
  left: 0;
  height: 100%;
  width: 100%;
  opacity: 0;
}

.Button {
  padding: 0;
  border: none;
}

.selectable {
  width: 100%;
  margin-right: 0;
}

.disabled {
  cursor: default;
  color: var(--p-color-text-secondary);

  &:hover {
    background-color: transparent;
  }
}

/* Item actions */
.Actions {
  >* {
    /* stylelint-disable-next-line -- Polaris component custom properties */
    clip: var(--pc-resource-item-action-hide-clip);
    /* stylelint-disable-next-line -- Polaris component custom properties */
    overflow: var(--pc-resource-item-action-hide-overflow);
  }

  .focused & {

    /* stylelint-disable-next-line selector-max-combinators  -- show actions on focus */
    >* {
      /* stylelint-disable-next-line -- Polaris component custom properties */
      clip: var(--pc-resource-item-action-unhide-clip);
      /* stylelint-disable-next-line -- Polaris component custom properties */
      overflow: var(--pc-resource-item-action-unhide-overflow);
    }
  }
}

.selected {
  background-color: var(--p-color-bg-surface-brand-selected);

  &:hover {
    background-color: var(--p-color-bg-surface-brand-hover);
  }

  &:active {
    background-color: var(--p-color-bg-surface-brand-active);
  }
}

.ListItem {
  /* stylelint-disable-next-line -- include focus-ring mixin to prevent jump in content for first focused element */
  @mixin focus-ring base, -1px;

  .ListItem+& {
    /* stylelint-disable-next-line -- Polaris component custom properties */
    border-top: var(--pc-resource-list-separator-border);
  }

  &.focused {
    /* stylelint-disable-next-line -- remove focus-ring mixin to use outline styles */
    @mixin no-focus-ring;
    outline: var(--p-border-width-050) solid var(--p-color-border-focus);
    outline-offset: calc(-1 * var(--p-space-050));
    /* stylelint-disable-next-line -- custom property */
    z-index: var(--pc-resource-item-clickable-stacking-order);
    border-radius: var(--p-border-radius-0);

    @media (--p-breakpoints-sm-up) {
      border-radius: var(--p-border-radius-300);

      &:first-of-type {
        border-bottom-left-radius: var(--p-border-radius-0);
        border-bottom-right-radius: var(--p-border-radius-0);
      }

      &:last-of-type {
        border-top-left-radius: var(--p-border-radius-0);
        border-top-right-radius: var(--p-border-radius-0);
      }
    }

    &:only-child {
      border-radius: var(--p-border-radius-0);

      @media (--p-breakpoints-sm-up) {
        border-radius: var(--p-border-radius-300);
      }
    }

    /* stylelint-disable-next-line selector-max-class -- set border radius for selectable items */
    &.selectable {
      border-radius: var(--p-border-radius-0);

      @media (--p-breakpoints-sm-up) {

        /* stylelint-disable-next-line -- set border radius for last selectable item to match ResourceList border radius */
        &:last-child {
          border-bottom-left-radius: var(--p-border-radius-300);
          border-bottom-right-radius: var(--p-border-radius-300);
        }

        /* stylelint-disable-next-line -- set border radius for last selectable item to match BulkActions border radius */
        &.hasBulkActions {

          /* stylelint-disable-next-line -- set border radius for last selectable item to match BulkActions border radius */
          &:last-child {

            /* stylelint-disable-next-line -- set border radius for last selectable item to match BulkActions border radius */
            &.selected {
              border-bottom-left-radius: var(--p-border-radius-0);
              border-bottom-right-radius: var(--p-border-radius-0);
            }
          }
        }
      }
    }
  }
}
```

# components/resource-item/resource-item.svelte

```svelte
<script lang="ts">
	import { UseBreakpoints } from '$lib/use/use-breakpoints.svelte.js';
	import { useContext } from '$utilities/contexts.js';
	import type { ResourceListContextType } from '$utilities/types.js';
	import { RESOURCE_LIST_CONTEXT_KEY } from '../app-provider/types.js';
	import BaseResourceItem from './base-resource-item.svelte';
	import type { ResourceItemProps } from './types.js';
	const bp = $derived(new UseBreakpoints());
	let props: ResourceItemProps = $props();

	const context = $derived(useContext<ResourceListContextType>(RESOURCE_LIST_CONTEXT_KEY)?.() ?? {});
</script>

<BaseResourceItem
	{...props}
	breakpoints={bp.breakpoints}
	context={context}
/>

```

# components/resource-item/types.ts

```ts
import type { Component, Snippet } from "svelte";
import type { AvatarProps } from "../avatar/types.js";
import type { ThumbnailProps } from "../thumbnail/types.js";
import type { DisableableAction, ResourceListContextType } from "$utilities/types.js";
import type { BreakpointsDirectionAlias } from "$lib/use/use-breakpoints.svelte.js";

export type Alignment = 'leading' | 'trailing' | 'center' | 'fill' | 'baseline';

export interface BaseProps {
    /** Whether or not interaction is disabled */
    disabled?: boolean;
    /** Visually hidden text for screen readers used for item link */
    accessibilityLabel?: string;
    /** Individual item name used by various text labels */
    name?: string;
    /** Id of the element the item onClick controls */
    ariaControls?: string;
    /** Tells screen reader the controlled element is expanded */
    ariaExpanded?: boolean;
    /** Unique identifier for the item */
    id: string;
    /** Content for the media area at the left of the item, usually an Avatar or Thumbnail */
    media?: Component<AvatarProps | ThumbnailProps>;
    /** Makes the shortcut actions always visible */
    persistActions?: boolean;
    /** 1 or 2 shortcut actions; must be available on the page linked to by url */
    shortcutActions?: DisableableAction[];
    /** The order the item is rendered */
    sortOrder?: number;
    /** URL for the resourceâ€™s details page (required unless onClick is provided) */
    url?: string;
    /** Allows url to open in a new tab */
    external?: boolean;
    /** Callback when clicked (required if url is omitted) */
    onClick?(id?: string): void;
    /** Content for the details area */
    children?: Snippet;
    /** Adjust vertical alignment of elements */
    verticalAlignment?: Alignment;
    /** Prefetched url attribute to bind to the main element being returned */
    dataHref?: string;
    /** Callback when mouse cursor is on item */
    onMouseOver?: () => void;
    /** Callback when mouse cursor leaves item */
    onMouseOut?: () => void;
}

export interface PropsWithUrl extends BaseProps {
    url: string;
    onClick?(id?: string): void;
}

export interface PropsWithClick extends BaseProps {
    url?: string;
    onClick(id?: string): void;
}

export type ResourceItemProps = PropsWithUrl | PropsWithClick;

export type BreakpointsMatches = {
    [DirectionAlias in BreakpointsDirectionAlias]: boolean;
};

export interface PropsFromWrapper {
    breakpoints?: BreakpointsMatches;
    context: ResourceListContextType;
}

export interface State {
    actionsMenuVisible: boolean;
    focused: boolean;
    focusedInner: boolean;
    selected: boolean;
}

export type CombinedProps = PropsFromWrapper & (PropsWithUrl | PropsWithClick);
```

# components/resource-list/index.ts

```ts
import ResourceItem from '../resource-item/resource-item.svelte';
import ResourceListComponent from './resource-list.svelte';

type CompoundResourceListType = typeof ResourceListComponent & {
    Item : typeof ResourceItem
}

const ResourceList = ResourceListComponent as CompoundResourceListType;
ResourceList.Item = ResourceItem;

export default ResourceList;
```

# components/resource-list/resource-list.module.css

```css
.FiltersWrapper {
  padding: var(--p-space-300);

  /* stylelint-disable-next-line selector-max-combinators, selector-max-specificity -- needed to add the dividing line only when the first child is the list */
  +.ResourceListWrapper> :first-child:is(.ResourceList) {
    /* stylelint-disable-next-line -- polaris component custom properties */
    border-top: var(--pc-resource-list-separator-border);
  }
}

.HeaderOuterWrapper {
  position: relative;
  background-color: var(--p-color-bg-surface);
  /* stylelint-disable-next-line -- generated by polaris-migrator DO NOT COPY */
  z-index: var(--pc-resource-list-header-outer-wrapper-stacking-order);
  border-top-left-radius: var(--p-border-radius-200);
  border-top-right-radius: var(--p-border-radius-200);

  /* stylelint-disable-next-line selector-max-class, selector-max-combinators -- Ssshhhhh */
  +.ResourceList,
  /* Bulk actions get injected into the DOM between the wrapper and resource*/
  /* list dynamically when an item is checked, so we have to handle that case*/
  /* here.*/
  +.BulkActionsWrapper+.ResourceList {
    /* stylelint-disable-next-line -- polaris component custom properties */
    border-top: var(--pc-resource-list-separator-border);
  }
}

.HeaderWrapper-disabled {
  pointer-events: none;
}

.HeaderWrapper-overlay {
  position: absolute;
  top: 0;
  right: 0;
  bottom: 0;
  left: 0;
  /* stylelint-disable-next-line -- generated by polaris-migrator DO NOT COPY */
  z-index: var(--pc-resource-list-header-overlay-stacking-order);
  /* stylelint-disable-next-line -- generated by polaris-migrator DO NOT COPY */
  background-color: rgba(255, 255, 255, 0.5);
}

/* stylelint-disable-next-line selector-max-class, selector-max-combinators -- Needed to correctly position the header */
.FiltersWrapper+.ResourceListWrapper>.HeaderOuterWrapper {
  margin-top: calc(-1 * var(--p-space-400));
}

.HeaderWrapper {
  position: relative;
  display: flex;
  width: 100%;
  background-color: var(--p-color-bg-surface);
  border-radius: var(--p-border-radius-200);

  /* This container conditionally includes a Select component for sorting
     It's 32px above md-up and 36px below
     This hardcoded min-height is to ensure the Select has uniform padding when it's 36px high */
  min-height: 52px;
  align-items: center;
  padding: var(--p-space-200) var(--p-space-300);

  /* We reduce the min-height here to account for the Select shrinking to 32px at this breakpoint. */
  @media (--p-breakpoints-md-up) {
    min-height: 48px;
  }
}

.HeaderWrapper-isSticky {
  box-shadow: var(--p-shadow-100);
  border-radius: 0;
}

.HeaderContentWrapper {
  position: absolute;
  /* stylelint-disable-next-line -- generated by polaris-migrator DO NOT COPY */
  z-index: var(--pc-resource-list-content-wrapper-stacking-order);
  right: var(--p-space-300);
  left: var(--p-space-300);

  /* Regardless of the variable height of the content
     we just want it to be center aligned. */
  top: 0;
  bottom: 0;
  display: flex;
  /* stylelint-disable-next-line -- polaris custom global property */
  min-height: var(--pg-control-height);
  opacity: 1;
  transition: opacity var(--p-motion-ease) var(--p-motion-duration-200);
  align-items: center;

  .HeaderWrapper-inSelectMode & {
    opacity: 0;
  }
}

.SortWrapper,
.AlternateToolWrapper {
  position: relative;
  display: flex;
  flex: 1;
  align-items: center;

  .HeaderWrapper-hasSelect & {
    padding-right: var(--p-space-200);
  }

  @media (--p-breakpoints-sm-up) {
    position: relative;
    left: auto;
    flex: 0 1 auto;
    margin-left: var(--p-space-400);

    /* stylelint-disable-next-line selector-max-class -- generated by polaris-migrator DO NOT COPY */
    .HeaderWrapper-hasAlternateTool.HeaderWrapper-hasSelect &,
    .HeaderWrapper-hasSort.HeaderWrapper-hasSelect & {
      padding-right: 0;
    }
  }
}

.SortWrapper {
  min-width: 0;
  max-width: 100%;

  >* {
    max-width: 100%;
  }
}

.HeaderTitleWrapper {
  white-space: nowrap;
  text-overflow: ellipsis;
  flex: 1;
  align-self: center;

  .HeaderWrapper-hasAlternateTool &,
  .HeaderWrapper-hasSort & {
    display: none;
  }

  @media (--p-breakpoints-sm-up) {

    /* stylelint-disable-next-line selector-max-class -- generated by polaris-migrator DO NOT COPY */
    .HeaderWrapper-hasSelect &,
    .HeaderWrapper-hasAlternateTool.HeaderWrapper-hasSelect &,
    .HeaderWrapper-hasSort.HeaderWrapper-hasSelect & {
      display: none;
    }

    .HeaderWrapper-hasAlternateTool &,
    .HeaderWrapper-hasSort & {
      display: block;
    }
  }
}

.SelectAllActionsWrapper {
  /* stylelint-disable-next-line -- generated by polaris-migrator DO NOT COPY */
  z-index: var(--pc-resource-list-bulk-actions-wrapper-stacking-order);
  position: absolute;
  left: 0;
  width: 100%;
  display: flex;
  align-items: center;

  @media (--p-breakpoints-sm-up) {
    flex: 0 1 auto;
    align-self: flex-start;
  }
}

.SelectAllActionsWrapperSticky {
  position: fixed;
  top: auto;
  bottom: 0;
}

.SelectAllActionsWrapperAtEnd {
  opacity: 0;
  transition: opacity var(--p-motion-duration-100) var(--p-motion-ease);
}

.SelectAllActionsWrapperAtEndAppear {
  opacity: 1;
}

.BulkActionsWrapper {
  position: relative;
  /* stylelint-disable-next-line -- generated by polaris-migrator DO NOT COPY */
  z-index: var(--pc-resource-list-bulk-actions-wrapper-stacking-order);
  width: 100%;

  visibility: hidden;
  opacity: 0;
  transition: opacity var(--p-motion-duration-100) var(--p-motion-ease),
    visibility var(--p-motion-duration-100) var(--p-motion-ease);

  &.BulkActionsWrapperVisible {
    visibility: visible;
    opacity: 1;
  }
}

.PaginationWrapper {
  /* stylelint-disable-next-line -- sets the z-index created above */
  z-index: var(--pc-pagination-index);

  @media (--p-breakpoints-md-up) {
    position: sticky;
    bottom: 0;
  }
}

.CheckableButtonWrapper {
  display: none;

  /* Checkable button has no opinion on its height, so we just fill the
     container */
  height: 100%;

  @media (--p-breakpoints-sm-up) {
    flex: 1;
    display: block;
  }
}

.SelectButtonWrapper {
  position: relative;
  flex: none;

  @media (--p-breakpoints-sm-up) {
    display: none;
  }
}

.EmptySearchResultWrapper {
  padding-top: var(--p-space-800);
  padding-bottom: var(--p-space-800);

  /* stylelint-disable-next-line -- generated by polaris-migrator DO NOT COPY */
  @media (min-height: 37.5em) {
    padding-top: var(--p-space-1600);
    padding-bottom: var(--p-space-1600);
  }
}

.ResourceListWrapper {
  /* stylelint-disable -- Polaris component custom properties */
  --pc-resource-list-stacking-order: 1;
  --pc-resource-list-content-wrapper-stacking-order: 1;
  --pc-resource-list-overlay-stacking-order: 3;
  --pc-resource-list-header-overlay-stacking-order: 4;
  --pc-resource-list-spinner-stacking-order: 4;
  --pc-pagination-index: 30;
  --pc-resource-list-bulk-actions-wrapper-stacking-order: 31;
  --pc-resource-list-header-outer-wrapper-stacking-order: 31;
  --pc-resource-list-separator-border: var(--p-border-width-025) solid var(--p-color-border);
  /* stylelint-enable */
  position: relative;
}

.ResourceList {
  position: relative;
  /* stylelint-disable-next-line -- generated by polaris-migrator DO NOT COPY */
  z-index: var(--pc-resource-list-stacking-order);
  margin: 0;
  padding: 0;
  list-style: none;
}

.ItemWrapper {
  position: relative;
  /* stylelint-disable-next-line -- generated by polaris-migrator DO NOT COPY */
  z-index: var(--pc-resource-list-stacking-order);
  overflow: hidden;
  max-width: 100%;

  +.ItemWrapper {
    /* stylelint-disable-next-line -- polaris component custom properties */
    border-top: var(--pc-resource-list-separator-border);
  }
}

.ItemWrapper-isLoading {
  min-height: 64px;
}

.SpinnerContainer {
  position: absolute;
  top: 0;
  right: 0;
  bottom: 0;
  left: 0;
  /* stylelint-disable-next-line -- generated by polaris-migrator DO NOT COPY */
  z-index: var(--pc-resource-list-spinner-stacking-order);
  display: flex;
  justify-content: center;
}

.LoadingOverlay {
  position: absolute;
  top: 0;
  right: 0;
  bottom: 0;
  left: 0;
  /* stylelint-disable-next-line -- generated by polaris-migrator DO NOT COPY */
  z-index: var(--pc-resource-list-overlay-stacking-order);
  display: flex;
  justify-content: center;
  /* stylelint-disable-next-line -- generated by polaris-migrator DO NOT COPY */
  background-color: rgba(255, 255, 255, 0.5);
}

.DisabledPointerEvents {
  pointer-events: none;
}

.disableTextSelection {
  user-select: none;
}
```

# components/resource-list/resource-list.svelte

```svelte
<script lang="ts">
	import { themeDefault, toPx } from '@shopify/polaris-tokens';
	import styles from './resource-list.module.css';
	import {
		LARGE_SPINNER_HEIGHT,
		SMALL_SPINNER_HEIGHT,
		type ResourceListItemData,
		type ResourceListProps
	} from './types.js';
	import { debounce } from '$utilities/debounce.js';
	import { SELECT_ALL_ITEMS } from '$utilities/index-provider/types.js';
	import { applyStyles, classNames } from '$utilities/css.js';
	import BulkActions from '../bulk-actions/bulk-actions.svelte';
	import Select from '../select/select.svelte';
	import type { VueNode } from '$utilities/types.js';
	import { onMount, type Component } from 'svelte';
	import { isSvelteConstruct } from '../page/components/page-header/types.js';
	import Text from '../text/text.svelte';
	import Button from '../button/button.svelte';
	import CheckboxIcon from '@shopify/polaris-icons/dist/svg/CheckboxIcon.svg?component';
	import CheckableButton from '../checkable-button/checkable-button.svelte';
	import Sticky from '../sticky/sticky.svelte';
	import EmptySearchResult from '../empty-search-result/empty-search-result.svelte';
	import Spinner from '../spinner/spinner.svelte';
	import Pagination from '../pagination/pagination.svelte';
	import ResourcelistContextProvider from '../app-provider/resourcelist-context-provider.svelte';

	let {
		items,
		filterControl,
		flushFilters,
		emptyState,
		emptySearchState,
		resourceName: resourceNameProp,
		promotedBulkActions,
		bulkActions,
		selectedItems = [],
		isFiltered,
		selectable,
		hasMoreItems,
		loading,
		headerContent,
		showHeader,
		totalItemsCount,
		sortValue,
		sortOptions,
		alternateTool,
		onSortChange,
		onSelectionChange,
		renderItem,
		idForItem = defaultIdForItem,
		resolveItemId,
		pagination
	}: ResourceListProps = $props();

	function getAllItemsOnPage<TItemType extends ResourceListItemData>(
		items: TItemType[],
		idForItem: (item: TItemType, index: number) => string
	) {
		return items.map((item: TItemType, index: number) => {
			return idForItem(item, index);
		});
	}

	const isBreakpointsXS = () => {
		return typeof window === 'undefined'
			? false
			: window.innerWidth < parseFloat(toPx(themeDefault.breakpoints['breakpoints-sm']) ?? '');
	};

	function defaultIdForItem<TItemType extends ResourceListItemData>(
		item: TItemType,
		index: number
	): string {
		return Object.prototype.hasOwnProperty.call(item, 'id') ? item.id : index.toString();
	}

	let x = $state<number>(0);
	const forceUpdate: (x?: number) => void = () => {
		x++;
	};

	let selectMode = $state(Boolean(selectedItems && selectedItems.length > 0));
	let loadingPosition = $state(0);
	let lastSelected = $state<number>(0);
	let smallScreen = $derived(isBreakpointsXS());
	let checkableButtonRef = $state<HTMLInputElement | null>(null);
	let defaultResourceName = $state({ singular: 'item', plural: 'items' });
	let listRef = $state<HTMLUListElement | null>(null);
	let isSticky = $state(false);

	const handleSelectMode = (selectMode: boolean) => {
		selectMode = selectMode;
		if (!selectMode && onSelectionChange) {
			onSelectionChange([]);
		}
	};

	const handleResize = debounce(
		() => {
			const newSmallScreen = isBreakpointsXS();
			if (selectedItems && selectedItems.length === 0 && selectMode && !newSmallScreen) {
				handleSelectMode(false);
			}

			if (smallScreen !== newSmallScreen) {
				smallScreen = newSmallScreen;
			}
		},
		50,
		{ leading: true, trailing: true, maxWait: 50 }
	);

	$effect(() => {
		if (listRef) {
			handleResize();
			window.addEventListener('resize', handleResize);
		}
		return () => {
			window.removeEventListener('resize', handleResize);
		};
	});

	const isSelectable = $derived(
		Boolean(
			(promotedBulkActions && promotedBulkActions.length > 0) ||
				(bulkActions && bulkActions.length > 0) ||
				selectable
		) && !smallScreen
	);

	let selectAllSelectState = $derived.by((): boolean => {
		let selectState: boolean = false;
		if (!selectedItems || (Array.isArray(selectedItems) && selectedItems.length === 0)) {
			selectState = false;
		} else if (
			selectedItems === SELECT_ALL_ITEMS ||
			(Array.isArray(selectedItems) && selectedItems.length === items.length)
		) {
			selectState = true;
		}
		return selectState;
	});

	const resourceName = $derived(resourceNameProp ? resourceNameProp : defaultResourceName);

	const headerTitle = $derived.by(() => {
		const itemsCount = items.length;
		const resource =
			!loading && ((!totalItemsCount && itemsCount === 1) || totalItemsCount === 1)
				? resourceName.singular
				: resourceName.plural;

		if (loading) {
			return `Loading ${resource}`;
		} else if (totalItemsCount) {
			return `Showing ${itemsCount} of ${totalItemsCount} ${resource}`;
		} else if (headerContent) {
			return headerContent;
		} else {
			return `Showing ${itemsCount} ${resource}`;
		}
	});

	let selectedItemsCount = $derived(
		selectedItems === SELECT_ALL_ITEMS ? `${items.length}+` : selectedItems.length
	);

	$effect(() => {
		if (selectedItems === SELECT_ALL_ITEMS || selectedItems.length > 0) {
			selectedItemsCount =
				selectedItems === SELECT_ALL_ITEMS ? `${items.length}+` : selectedItems.length;
		}
	});

	const selectAllActionsLabel = $derived(`${selectedItemsCount} selected`);

	const bulkActionsAccessibilityLabel = $derived.by(() => {
		const selectedItemsCount = selectedItems.length;
		const totalItemsCount = items.length;
		const allSelected = selectedItemsCount === totalItemsCount;

		if (totalItemsCount === 1 && allSelected) {
			return `Deselect ${resourceName.singular}`;
		} else if (totalItemsCount === 1) {
			return `Select ${resourceName.singular}`;
		} else if (allSelected) {
			return `Deselect all ${items.length} ${resourceName.plural}`;
		} else {
			return `Select all ${items.length} ${resourceName.plural}`;
		}
	});

	const paginatedSelectAllText = $derived.by(() => {
		if (!isSelectable || !hasMoreItems) {
			return '';
		}

		if (selectedItems === SELECT_ALL_ITEMS) {
			return isFiltered
				? `All ${items.length}+ ${resourceName.plural} in this filter are selected`
				: `All ${items.length}+ ${resourceName.plural} in your store are selected`;
		}
	});

	const handleSelectAllItemsInStore = () => {
		const newlySelectedItems =
			selectedItems === SELECT_ALL_ITEMS ? getAllItemsOnPage(items, idForItem) : SELECT_ALL_ITEMS;

		if (onSelectionChange) {
			onSelectionChange(newlySelectedItems);
		}
	};

	const paginatedSelectAllAction = $derived.by(() => {
		if (!isSelectable || !hasMoreItems) {
			return;
		}

		const actionText =
			selectedItems === SELECT_ALL_ITEMS
				? 'Undo'
				: isFiltered
					? `Select all ${items.length}+ ${resourceName.plural} in this filter`
					: `Select all ${items.length}+ ${resourceName.plural} in your store`;

		return {
			content: actionText,
			onAction: handleSelectAllItemsInStore
		};
	});

	const emptySearchResultText = $derived({
		title: `No ${resourceName.plural} found`,
		description: 'Try changing the filters or search term'
	});

	const setLoadingPosition = () => {
		if (listRef != null) {
			if (typeof window === 'undefined') {
				return;
			}

			const overlay = listRef.getBoundingClientRect();
			const viewportHeight = Math.max(
				document.documentElement ? document.documentElement.clientHeight : 0,
				window.innerHeight || 0
			);

			const overflow = viewportHeight - overlay.height;

			const spinnerHeight = items.length === 1 ? SMALL_SPINNER_HEIGHT : LARGE_SPINNER_HEIGHT;

			const spinnerPosition =
				overflow > 0
					? (overlay.height - spinnerHeight) / 2
					: (viewportHeight - overlay.top - spinnerHeight) / 2;

			loadingPosition = spinnerPosition;
		}
	};

	const itemsExist = items.length > 0;

	$effect(() => {
		if (loading) {
			setLoadingPosition();
		}
	});

	$effect(() => {
		if (selectedItems && selectedItems.length > 0 && !selectMode) {
			selectMode = true;
		}
		if ((!selectedItems || selectedItems.length === 0) && !isBreakpointsXS()) {
			selectMode = false;
		}
	});

	onMount(() => {
		forceUpdate();
	});

	/* ;

	$effect(() => {
		forceUpdate();
	}); */

	type TItemType = ResourceListItemData;

	const renderItemWithId = (item: TItemType, index: number) => {
		const id = idForItem(item, index);
		const itemContent = renderItem(item);
		return itemContent;
	};

	const handleMultiSelectionChange = (
		lastSelected: number,
		currentSelected: number,
		resolveItemId: (item: TItemType) => string
	) => {
		const min = Math.min(lastSelected, currentSelected);
		const max = Math.max(lastSelected, currentSelected);
		//@ts-ignore
		return items.slice(min, max + 1).map(resolveItemId);
	};

	const handleSelectionChange = (
		selected: boolean,
		id: string,
		sortOrder: number | undefined,
		shiftKey: boolean
	) => {
		if (selectedItems == null || onSelectionChange == null) {
			return;
		}

		let newlySelectedItems =
			selectedItems === SELECT_ALL_ITEMS ? getAllItemsOnPage(items, idForItem) : [...selectedItems];

		if (sortOrder !== undefined) {
			lastSelected = sortOrder;
		}

		const lastSelectedFromState = lastSelected;

		let selectedIds: string[] = [id];

		if (shiftKey && lastSelectedFromState != null && sortOrder !== undefined && resolveItemId) {
			selectedIds = handleMultiSelectionChange(lastSelectedFromState, sortOrder, resolveItemId);
		}
		newlySelectedItems = [...new Set([...newlySelectedItems, ...selectedIds])];

		if (!selected) {
			for (const selectedId of selectedIds) {
				newlySelectedItems.splice(newlySelectedItems.indexOf(selectedId), 1);
			}
		}

		if (newlySelectedItems.length === 0 && !isBreakpointsXS()) {
			handleSelectMode(false);
		} else if (newlySelectedItems.length > 0) {
			handleSelectMode(true);
		}

		if (onSelectionChange) {
			onSelectionChange(newlySelectedItems);
		}
	};

	const handleToggleAll = () => {
		let newlySelectedItems: string[];

		if (
			(Array.isArray(selectedItems) && selectedItems.length === items.length) ||
			selectedItems === SELECT_ALL_ITEMS
		) {
			newlySelectedItems = [];
		} else {
			newlySelectedItems = items.map((item, index) => {
				return idForItem(item, index);
			});
		}

		if (newlySelectedItems.length === 0 && !isBreakpointsXS()) {
			handleSelectMode(false);
		} else if (newlySelectedItems.length > 0) {
			handleSelectMode(true);
		}

		if (onSelectionChange) {
			onSelectionChange(newlySelectedItems);
		}

		// setTimeout ensures execution after the Transition on BulkActions
		setTimeout(() => {
			checkableButtonRef?.focus();
		}, 0);
	};

	const bulkActionClassNames = $derived(
		classNames(styles.BulkActionsWrapper, selectMode && styles.BulkActionsWrapperVisible)
	);

	const needsHeader = $derived(
		isSelectable || (sortOptions && sortOptions.length > 0) || alternateTool
	);

	const showEmptyState = $derived(emptyState && !itemsExist && !loading);

	const showEmptySearchState = $derived(
		!showEmptyState && filterControl && !itemsExist && !loading
	);

	const headerClassName = $derived(
		classNames(
			styles.HeaderWrapper,
			sortOptions && sortOptions.length > 0 && !alternateTool && styles['HeaderWrapper-hasSort'],
			alternateTool && styles['HeaderWrapper-hasAlternateTool'],
			isSelectable && styles['HeaderWrapper-hasSelect'],
			loading && styles['HeaderWrapper-disabled'],
			isSelectable && selectMode && styles['HeaderWrapper-inSelectMode'],
			isSticky && styles['HeaderWrapper-isSticky']
		)
	);

	const defaultTopPadding = 8;
	const topPadding = $derived(loadingPosition > 0 ? loadingPosition : defaultTopPadding);
	const spinnerStyle = $derived({ paddingTop: `${topPadding}px` });
	const spinnerSize = $derived(items.length < 2 ? 'small' : 'large');

	const className = $derived(
		classNames(styles.ItemWrapper, loading && styles['ItemWrapper-isLoading'])
	);

	const resourceListClassName = $derived(
		classNames(
			styles.ResourceList,
			loading && styles.disabledPointerEvents,
			selectMode && styles.disableTextSelection
		)
	);

	const context = $derived({
		selectable: isSelectable,
		selectedItems,
		selectMode,
		hasBulkActions: Boolean(bulkActions),
		resourceName,
		loading,
		onSelectionChange: handleSelectionChange
	});
</script>

{#snippet bulkActionsMarkup()}
	{#if isSelectable}
		<div class={bulkActionClassNames}>
			<BulkActions
				{selectMode}
				onSelectModeToggle={handleSelectMode}
				label={selectAllActionsLabel}
				{paginatedSelectAllAction}
				{paginatedSelectAllText}
				promotedActions={promotedBulkActions}
				actions={bulkActions}
				disabled={loading}
				accessibilityLabel={bulkActionsAccessibilityLabel}
				selected={selectAllSelectState}
				onToggleAll={handleToggleAll}
				bind:ref={checkableButtonRef}
				buttonSize="medium"
			/>
		</div>
	{/if}
{/snippet}

{#snippet filterControlMarkup()}
	<div class={classNames(!flushFilters && styles.FiltersWrapper)}>
		{@render filterControl?.()}
	</div>
{/snippet}

{#snippet renderVueNode(vueNode: VueNode)}
	{#if isSvelteConstruct(vueNode)}
		{@render vueNode()}
	{:else}
		{vueNode}
	{/if}
{/snippet}

{#snippet sortingSelectMarkup()}
	{#if sortOptions && sortOptions.length > 0 && !alternateTool}
		<div class={styles.SortWrapper}>
			<Select
				label="Sort by"
				labelInline={!smallScreen}
				labelHidden={smallScreen}
				options={sortOptions}
				onChange={onSortChange}
				value={sortValue}
				disabled={selectMode}
			/>
		</div>
	{/if}
{/snippet}

{#snippet alternateToolMarkup()}
	{#if alternateTool && !sortOptions}
		<div class={styles.AlternateToolWrapper}>
			{@render renderVueNode(alternateTool)}
		</div>
	{/if}
{/snippet}

{#snippet headerTitleMarkup()}
	<div class={styles.HeaderTitleWrapper}>
		<Text as="span" variant="bodyMd">
			{headerTitle}
		</Text>
	</div>
{/snippet}

{#snippet selectButtonMarkup()}
	{#if isSelectable}
		<div class={styles.SelectButtonWrapper}>
			<Button disabled={selectMode} icon={CheckboxIcon} onClick={() => handleSelectMode(true)}>
				Select
			</Button>
		</div>
	{/if}
{/snippet}

{#snippet checkableButtonMarkup()}
	{#if isSelectable}
		<div class={styles.CheckableButtonWrapper}>
			<CheckableButton
				accessibilityLabel={bulkActionsAccessibilityLabel}
				label={headerTitle}
				onToggleAll={handleToggleAll}
				disabled={loading}
				ref={checkableButtonRef}
				selected={selectAllSelectState}
			/>
		</div>
	{/if}
{/snippet}

{#snippet headerWrapperOverlay()}
	{#if loading}
		<div class={styles['HeaderWrapper-overlay']}></div>
	{/if}
{/snippet}

{#snippet headerMarkup()}
	{#if !showEmptyState && showHeader !== false && !showEmptySearchState && (showHeader || needsHeader) && listRef}
		<div class={styles.HeaderOuterWrapper}>
			<Sticky bind:isSticky boundingElement={listRef}>
				<div class={headerClassName}>
					{@render headerWrapperOverlay()}
					<div class={styles.HeaderContentWrapper}>
						{@render headerTitleMarkup()}
						{@render checkableButtonMarkup()}
						{@render alternateToolMarkup()}
						{@render sortingSelectMarkup()}
						{@render selectButtonMarkup()}
					</div>
					{@render bulkActionsMarkup()}
				</div>
			</Sticky>
		</div>
	{/if}
{/snippet}

{#snippet emptySearchStateMarkup()}
	{#if showEmptySearchState}
		{#if emptySearchState}
			{@render emptySearchState()}
		{:else}
			<div class={styles.EmptySearchResultWrapper}>
				<EmptySearchResult {...emptySearchResultText} withIllustration />
			</div>
		{/if}
	{/if}
{/snippet}

{#snippet emptyStateMarkup()}
	{#if showEmptyState}
		{@render emptyState?.()}
	{/if}
{/snippet}

{#snippet loadingOverlay()}
	{#if loading}
		<li class={styles.SpinnerContainer} style={applyStyles(spinnerStyle)}>
			<Spinner size={spinnerSize} accessibilityLabel="Items are loading" />
		</li>
		<li class={styles.LoadingOverlay}></li>
	{/if}
{/snippet}

{#snippet loadingWithoutItemsMarkup()}
	{#if loading && !itemsExist}
		<div class={className} tabIndex={-1}>
			{@render loadingOverlay()}
		</div>
	{/if}
{/snippet}

{#snippet listMarkup()}
	{#if itemsExist}
		<ul class={resourceListClassName} bind:this={listRef} aria-live="polite" aria-busy={loading}>
			{@render loadingOverlay()}
			<!-- {items.map(renderItemWithId)} -->
			{#each items as item}
				{@render renderItem(item)}
			{/each}
		</ul>
	{/if}
{/snippet}

{#snippet paginationMarkup()}
	{#if pagination}
		<div class={styles.PaginationWrapper}>
			<Pagination type="table" {...pagination} />
		</div>
	{/if}
{/snippet}

<ResourcelistContextProvider value={context}>
	{@render filterControlMarkup()}
	<div class={styles.ResourceListWrapper}>
		{@render headerMarkup()}
		{@render listMarkup()}
		{@render emptySearchStateMarkup()}
		{@render emptyStateMarkup()}
		{@render loadingWithoutItemsMarkup()}
		{@render paginationMarkup()}
	</div>
</ResourcelistContextProvider>

```

# components/resource-list/types.ts

```ts
import type { Snippet } from "svelte";
import type { PaginationProps } from "../pagination/types.js";
import type { BulkActionsProps } from "../bulk-actions/types.js";
import type { ResourceListSelectedItems, VueNode } from "$utilities/types.js";
import type { SelectOption } from "../select/types.js";

export const SMALL_SPINNER_HEIGHT = 28;
export const LARGE_SPINNER_HEIGHT = 45;

export interface ResourceListItemData {
    [data: string]: any;
}

export type ResourceListPaginationProps = Omit<PaginationProps, 'type'>;

export interface ResourceListProps<
    TItemType extends ResourceListItemData = ResourceListItemData,
> {
    /** Item data; each item is passed to renderItem */
    items: TItemType[];
    filterControl?: Snippet;
    /** Whether to remove all padding around the filter controls. Should be true if using Filters, and false if using LegacyFilters.  */
    flushFilters?: boolean;
    /** The markup to display when no resources exist yet. Renders when set and items is empty. */
    emptyState?: Snippet;
    /** The markup to display when no results are returned on search or filter of the list. Renders when `filterControl` is set, items are empty, and `emptyState` is not set.
     * @default EmptySearchResult
     */
    emptySearchState?: Snippet;
    /** Name of the resource, such as customers or products */
    resourceName?: {
        singular: string;
        plural: string;
    };
    /** Up to 2 bulk actions that will be given more prominence */
    promotedBulkActions?: BulkActionsProps['promotedActions'];
    /** Actions available on the currently selected items */
    bulkActions?: BulkActionsProps['actions'];
    /** Collection of IDs for the currently selected items */
    selectedItems?: ResourceListSelectedItems;
    /** Whether or not the list has filter(s) applied */
    isFiltered?: boolean;
    /** Renders a Select All button at the top of the list and checkboxes in front of each list item. For use when bulkActions aren't provided. **/
    selectable?: boolean;
    /** Whether or not there are more items than currently set on the items prop. Determines whether or not to set the paginatedSelectAllAction and paginatedSelectAllText props on the BulkActions component. */
    hasMoreItems?: boolean;
    /** Overlays item list with a spinner while a background action is being performed */
    loading?: boolean;
    /** Boolean to show or hide the header */
    showHeader?: boolean;
    /** Total number of resources */
    totalItemsCount?: number;
    /** Current value of the sort control */
    sortValue?: string;
    /** Collection of sort options to choose from */
    sortOptions?: SelectOption[];
    /** ReactNode to display instead of the sort control */
    alternateTool?: VueNode;
    /** Custom header text displayed above the list instead of the resource count. */
    headerContent?: string;
    /** Callback when sort option is changed */
    onSortChange?(selected: string, id: string): void;
    /** Callback when selection is changed */
    onSelectionChange?(selectedItems: ResourceListSelectedItems): void;
    /** Function to render each list item, must return a ResourceItem component */
    renderItem: Snippet<[ResourceListItemData]>;
    /** Function to customize the unique ID for each item */
    idForItem?(item: TItemType, index: number): string;
    /** Function to resolve the ids of items */
    resolveItemId?(item: TItemType): string;
    /** Properties to enable pagination at the bottom of the list. */
    pagination?: ResourceListPaginationProps;
}
```

# components/scrollable/components/scroll-to/scroll-to.svelte

```svelte
<script lang='ts'>
	import { SCROLLABLE_CONTEXT_KEY, useContext, type ScrollToPositionFn } from "$utilities/contexts.js";

    let anchorNode = $state<HTMLAnchorElement|undefined>()
    const id = $props.id();
    const scrollToPosition = useContext<ScrollToPositionFn>(SCROLLABLE_CONTEXT_KEY);
    let scrollToPositionFn = $derived(scrollToPosition())

    $effect(() => {
        if (!scrollToPositionFn || !anchorNode) {
            return;
        }
        
        scrollToPositionFn?.(anchorNode.offsetTop);
    })
</script>

<!-- svelte-ignore a11y_consider_explicit_label -->
<!-- svelte-ignore a11y_missing_attribute -->
<a id={id} bind:this={anchorNode}></a>
```

# components/scrollable/index.ts

```ts
import ScrollToComponent from "./components/scroll-to/scroll-to.svelte";
import ScrollableComponent from "./scrollable.svelte";

type ScrollableCompoundType = typeof ScrollableComponent & {
	ScrollTo: typeof ScrollToComponent;
};

const Scrollable = ScrollableComponent as ScrollableCompoundType;
Scrollable.ScrollTo = ScrollToComponent;

export default Scrollable;
```

# components/scrollable/scrollable.module.css

```css
.Scrollable {
    /* stylelint-disable -- Polaris component custom properties */
    --pc-scrollable-shadow-size: var(--p-space-500);
    --pc-scrollable-shadow-color: rgba(0, 0, 0, 0.15);
    --pc-scrollable-shadow-bottom: 0 var(--pc-scrollable-shadow-size) var(--pc-scrollable-shadow-size) var(--pc-scrollable-shadow-size) var(--pc-scrollable-shadow-color);
    --pc-scrollable-shadow-top: 0 calc(-1 * var(--pc-scrollable-shadow-size)) var(--pc-scrollable-shadow-size) var(--pc-scrollable-shadow-size) var(--pc-scrollable-shadow-color);
    --pc-scrollable-max-height: none;
    /* stylelint-enable */
    -webkit-overflow-scrolling: touch;
    position: relative;
    /* stylelint-disable-next-line -- generated by polaris-migrator DO NOT COPY */
    max-height: var(--pc-scrollable-max-height);
    overflow-x: hidden;
    overflow-y: hidden;

    /* Prevent Scrollable's box shadows overflowing the rounded corners of this
     * element on Safari prior to tech preview version 156.
     * See: https://bugs.webkit.org/show_bug.cgi?id=68196 */
    isolation: isolate;

    &:focus {
        outline: var(--p-border-width-050) solid var(--p-color-border-focus);
        outline-offset: var(--p-space-050);
    }

    &.hasTopShadow,
    &.hasBottomShadow {

        /* Why not combine the box shadows onto one element? Because then it would
       * need to be height: 100%, but that doesn't work when there's no explicit
       * height set on the parent element (eg; for the Modal component which uses
       * min-height: 80vh instead). */
        &::before,
        &::after {
            content: '';

            /* Using CSS sticky to position the pseudo elements relative to the scroll
         * container insead of relative to the contents */
            position: sticky;

            left: 0;

            /* Ensure we can give it an explicit height of 0 later */
            display: block;

            /* No one likes clicking on shadows! */
            pointer-events: none;

            /* height: 0 ensures it does not take up any static space, but still
         * abides by position: sticky rules (ie; sorta position: fixed, but
         * relative to the scroll container). */
            height: var(--p-space-0);

            /* Full width to cover the entire scrollable container */
            width: 100%;

            /* Arbitrarily picked this because it sorta sits above other elements most
        * of the time without obscuring modals that might be above, etc.
        * See https://github.com/Shopify/polaris/pull/9668/files#diff-b4fd34abf294f8d6bdcf784136be2ac82883085b8b0f91e450b2210eb6caaef9R70 */
            /* stylelint-disable-next-line -- See above */
            z-index: 32;
        }

        &::before {
            /* First element ticks to the top left */
            top: 0;
        }

        &::after {
            /* Last element sticks to the bottom left */
            bottom: 0;
        }
    }

    &.hasTopShadow::before {
        /* stylelint-disable-next-line -- generated by polaris-migrator DO NOT COPY */
        box-shadow: var(--pc-scrollable-shadow-top);
    }

    &.hasBottomShadow::after {
        /* stylelint-disable-next-line -- generated by polaris-migrator DO NOT COPY */
        box-shadow: var(--pc-scrollable-shadow-bottom);
    }
}

.horizontal {
    overflow-x: auto;
}

.vertical {
    overflow-y: auto;
}

.scrollbarWidthThin {
    scrollbar-width: thin;
}

.scrollbarWidthNone {
    scrollbar-width: none;
}

.scrollbarWidthAuto {
    scrollbar-width: auto;
}

.scrollbarGutterStable {
    scrollbar-gutter: stable;
}

.scrollbarGutterStableboth-edges {
    scrollbar-gutter: stable both-edges;
}
```

# components/scrollable/scrollable.svelte

```svelte
<script lang="ts">
	import { StickyManager } from '$utilities/sticky-manager/sticky-manager.js';
	import { onMount } from 'svelte';
	import styles from './scrollable.module.css';
	import {
		LOW_RES_BUFFER,
		performScrollHint,
		type ScrollableProps
	} from './types.js';
	import { debounce } from '$utilities/debounce.js';
	import { applyStyles, classNames, variationName } from '$utilities/css.js';
	import { scrollable } from '$utilities/shared.js';
	import ScrollableProvider from '../app-provider/scrollable-provider.svelte';
	import StickymanagerProvider from '../app-provider/stickymanager-provider.svelte';
	let {
		children,
		horizontal = true,
		vertical = true,
		class: className,
		shadow,
		hint,
		focusable,
		style,
		scrollbarWidth = 'thin',
		scrollbarGutter,
		onScrolledToBottom,
		...rest
	}: ScrollableProps & { class?: string, style?: Record<string, string | number | undefined> } = $props();

	let topShadow = $state(false);
	let bottomShadow = $state(false);
	const stickyManager = new StickyManager();
	let scrollArea: HTMLDivElement | undefined = $state();

	const handleScroll = () => {
		const currentScrollArea = scrollArea;
		if (!currentScrollArea) {
			return;
		}

		requestAnimationFrame(() => {
			const { scrollTop, clientHeight, scrollHeight } = currentScrollArea;
			const canScroll = Boolean(scrollHeight > clientHeight);
			const isBelowTopOfScroll = Boolean(scrollTop > 0);
			const isAtBottomOfScroll = Boolean(scrollTop + clientHeight >= scrollHeight - LOW_RES_BUFFER);

			topShadow = isBelowTopOfScroll;
			bottomShadow = !isAtBottomOfScroll;

			if (canScroll && isAtBottomOfScroll && onScrolledToBottom) {
				onScrolledToBottom();
			}
		});
	};

	onMount(() => {
		handleScroll();

		if (hint) {
			requestAnimationFrame(() => performScrollHint(scrollArea));
		}
	});

	$effect(() => {
		const currentScrollArea = scrollArea;

		if (!currentScrollArea) {
			return;
		}

		const handleResize = debounce(handleScroll, 50, { trailing: true });

		stickyManager.setContainer(currentScrollArea);
		currentScrollArea.addEventListener('scroll', handleScroll);
		globalThis.addEventListener('resize', handleResize);

		return () => {
			currentScrollArea.removeEventListener('scroll', handleScroll);
			globalThis.removeEventListener('resize', handleResize);
		};
	});

	const finalClassName = $derived(
		classNames(
			className,
			styles.Scrollable,
			vertical && styles.vertical,
			horizontal && styles.horizontal,
			shadow && topShadow && styles.hasTopShadow,
			shadow && bottomShadow && styles.hasBottomShadow,
			scrollbarWidth && styles[variationName('scrollbarWidth', scrollbarWidth)],
			scrollbarGutter && styles[variationName('scrollbarGutter', scrollbarGutter.replace(' ', ''))]
		)
	);
</script>

<ScrollableProvider>
	<StickymanagerProvider value={stickyManager}>
		<div
			class={finalClassName}
			{...scrollable.props}
			{...rest}
			style={style ? applyStyles(style) : undefined}
			bind:this={scrollArea}
			tabIndex={focusable ? 0 : undefined}
		>
			{@render children?.()}
		</div>
	</StickymanagerProvider>
</ScrollableProvider>

```

# components/scrollable/types.ts

```ts
import { scrollable } from "$utilities/shared.js";
import type { Snippet } from "svelte";

export const MAX_SCROLL_HINT_DISTANCE = 100;
export const LOW_RES_BUFFER = 2;

export interface ScrollableProps {
    /** Content to display in scrollable area */
    children?: Snippet;
    /** Scroll content vertically
     * @default true
     * */
    vertical?: boolean;
    /** Scroll content horizontally
     * @default true
     * */
    horizontal?: boolean;
    /** Add a shadow when content is scrollable */
    shadow?: boolean;
    /** Slightly hints content upon mounting when scrollable */
    hint?: boolean;
    /** Adds a tabIndex to scrollable when children are not focusable */
    focusable?: boolean;
    /** Browser determined scrollbar width
     * @default 'thin'
     */
    scrollbarWidth?: 'thin' | 'none' | 'auto';
    /** Adds space to one or both sides to prevent content shift when scrolling is necessary */
    scrollbarGutter?: 'stable' | 'stable both-edges';
    /** Called when scrolled to the bottom of the scroll area */
    onScrolledToBottom?(): void;
}

export interface ScrollToOptions {
    behavior?: 'instant' | 'smooth' | 'auto';
}

export interface ScrollableRef {
    scrollTo: (scrollY: number, options?: ScrollToOptions) => void;
}

export function prefersReducedMotion() {
    try {
        return window.matchMedia('(prefers-reduced-motion: reduce)').matches;
    } catch (err) {
        return false;
    }
}

export function performScrollHint(elem?: HTMLDivElement | null) {
    if (!elem || prefersReducedMotion()) {
        return;
    }

    const scrollableDistance = elem.scrollHeight - elem.clientHeight;
    const distanceToPeek =
        Math.min(MAX_SCROLL_HINT_DISTANCE, scrollableDistance) - LOW_RES_BUFFER;

    const goBackToTop = () => {
        requestAnimationFrame(() => {
            if (elem.scrollTop >= distanceToPeek) {
                elem.removeEventListener('scroll', goBackToTop);
                elem.scrollTo({ top: 0, behavior: 'smooth' });
            }
        });
    };

    elem.addEventListener('scroll', goBackToTop);
    elem.scrollTo({ top: MAX_SCROLL_HINT_DISTANCE, behavior: 'smooth' });
}

export const forNode = (node: HTMLElement): HTMLElement | Document => {
    const closestElement = node?.closest(scrollable.selector);
    return closestElement instanceof HTMLElement ? closestElement : document;
  };
  

```

# components/select/select.module.css

```css
.Select {
  /* stylelint-disable -- Polaris component custom properties */
  --pc-select-backdrop: 10;
  --pc-select-content: 20;
  --pc-select-input: 30;
  /* stylelint-enable */
  position: relative;

  /* IE 11 fix to remove default dropdown arrow */
  select::-ms-expand {
    display: none;
  }

  &:not(.disabled):not(.error) {

    /* stylelint-disable-next-line -- overrides */
    &:hover .Backdrop {
      border-color: var(--p-color-input-border-hover);
      background-color: var(--p-color-input-bg-surface-hover);
    }

    /* stylelint-disable-next-line -- overrides */
    .Input:active~.Backdrop {
      border: none;
      box-shadow: var(--p-shadow-inset-200);
      background-color: var(--p-color-input-bg-surface-active);
    }
  }
}

.disabled {
  .Content {
    color: var(--p-color-text-disabled);
  }

  .InlineLabel {
    color: inherit;
  }

  /* stylelint-disable-next-line -- generated by polaris-migrator DO NOT COPY */
  .Icon svg {
    fill: var(--p-color-icon-disabled);
  }

  .Backdrop {
    border-color: var(--p-color-border-disabled);
    background-color: var(--p-color-bg-surface-disabled);

    &::before {
      background-color: var(--p-color-input-bg-surface);
    }

    &:hover {
      cursor: default;
    }
  }
}

.Content {
  /* stylelint-disable-next-line -- generated by polaris-migrator DO NOT COPY */
  @mixin text-style-input;
  position: relative;
  /* stylelint-disable-next-line -- generated by polaris-migrator DO NOT COPY */
  z-index: var(--pc-select-content);
  display: flex;
  align-items: center;
  width: 100%;
  /* stylelint-disable-next-line -- polaris custom global property */
  min-height: var(--pg-control-height);
  padding: var(--p-space-150) var(--p-space-200) var(--p-space-150) var(--p-space-300);

  font-size: var(--p-font-size-400);
  line-height: var(--p-font-line-height-600);

  @media (--p-breakpoints-md-up) {
    line-height: var(--p-font-line-height-500);
    font-size: var(--p-font-size-325);
  }

  @media (--p-breakpoints-md-down) {

    /* stylelint-disable-next-line selector-max-combinators, selector-max-type -- generated by polaris-migrator DO NOT COPY */
    div>span {
      font-size: var(--p-font-size-400);
      line-height: var(--p-font-line-height-500);
    }
  }
}

.SelectedOption {
  flex: 1;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.Prefix {
  padding-right: var(--p-space-100);
}

.Icon svg {
  fill: var(--p-color-icon-secondary);
}

.Input {
  /* Even though the input is invisible, text styles apply to the options menu */
  font-size: var(--p-font-size-400);
  font-weight: var(--p-font-weight-regular);
  line-height: var(--p-font-line-height-600);

  /* Safari requires the font-family to be added to the <select> element */
  font-family: var(--p-font-family-sans);
  letter-spacing: initial;
  position: absolute;

  /* Required to solve a bug causing Safari 13 to crash https://bugs.webkit.org/show_bug.cgi?id=202055 */
  text-rendering: auto;
  top: 0;
  left: 0;
  /* stylelint-disable-next-line -- generated by polaris-migrator DO NOT COPY */
  z-index: var(--pc-select-input);
  width: 100%;
  height: 100%;
  margin: 0;
  opacity: 0;
  appearance: none;
  border: none;

  /* Google chrome on Windows requires padding to be added otherwise <option> has no space */
  padding: var(--p-space-150) var(--p-space-200) var(--p-space-150) var(--p-space-300);

  @media (--p-breakpoints-md-up) {
    font-size: var(--p-font-size-325);
    line-height: var(--p-font-line-height-500);
  }
}

.Backdrop {
  /* stylelint-disable-next-line -- generated by polaris-migrator DO NOT COPY */
  z-index: var(--pc-select-backdrop);
  top: 0;
  right: 0;
  bottom: 0;
  left: 0;
  border: var(--p-border-width-0165) solid var(--p-color-input-border);
  border-radius: var(--p-border-radius-200);
  background-color: var(--p-color-input-bg-surface);
  /* stylelint-disable-next-line order/properties-order -- 'position' needs to sit below focus-ring since it will be overwritten with relative when the focus ring style is 'base' */
  position: absolute;
}

.error {
  .Backdrop {
    border-color: var(--p-color-border-critical-secondary);
    background-color: var(--p-color-bg-surface-critical);

    /* stylelint-disable-next-line selector-max-class -- generated by polaris-migrator DO NOT COPY */
    &.hover,
    &:hover {
      border-color: var(--p-color-border-critical);
    }
  }

  /* Need to override the higher specificity of the sibling selector
     so that errors still have red borders. */
  /* stylelint-disable-next-line selector-max-combinators, selector-max-specificity, selector-max-class -- generated by polaris-migrator DO NOT COPY */
  .Input:focus-visible~.Backdrop {
    border-color: var(--p-color-border-critical-secondary);
    border-width: var(--p-border-width-025);
    background-color: var(--p-color-bg-surface-critical);
  }
}

.Input:focus-visible {
  ~.Backdrop {
    border-color: var(--p-color-input-border-active);
    border-width: var(--p-border-width-025);
    background-color: var(--p-color-input-bg-surface-active);
    outline: var(--p-border-width-050) solid var(--p-color-border-focus);
    outline-offset: var(--p-space-025);
  }
}

.toneMagic {
  .Content {
    color: var(--p-color-text-magic);
  }

  .InlineLabel {
    color: inherit;
  }

  .Backdrop {
    border-color: var(--p-color-border-magic-secondary);
    background-color: var(--p-color-bg-surface-magic);
  }

  /* stylelint-disable-next-line selector-max-combinators -- set Icon fill */
  .Icon svg {
    fill: var(--p-color-icon-magic);
  }

  /* stylelint-disable selector-max-specificity, selector-max-class, selector-max-combinators, selector-max-compound-selectors, max-nesting-depth -- apply hover and active styles */
  &:not(.disabled):not(.error) {
    &:not(:focus-within) {
      &:hover .Backdrop {
        border-color: var(--p-color-border-magic-secondary-hover);
        background-color: var(--p-color-bg-surface-magic-hover);
      }
    }

    .Input:focus-visible {
      ~.Content {
        color: var(--p-color-text);

        .Icon svg {
          fill: var(--p-color-icon-secondary);
        }
      }
    }
  }

  /* stylelint-enable selector-max-specificity, selector-max-class, selector-max-combinators */
}

@media (-ms-high-contrast: active) {
  .Content {
    color: windowText;
    -ms-high-contrast-adjust: none;
  }

  .InlineLabel {
    color: inherit;

    &::after {
      content: ':';
    }
  }

  .SelectedOption {
    color: inherit;
  }

  .Icon svg {
    fill: buttonText;
  }

  .Backdrop {
    &::after {
      /* Remove the dotted focus outline from the control-backdrop mixin. */
      display: none;
    }
  }

  .Input:focus {
    ~.Content {
      color: highlightText;
    }

    ~.Backdrop {
      /* Align with the native styling for this element, which differs from
         what the control-backdrop mixin provides. */
      background-color: highlight;
    }
  }

  .disabled {
    .Content {
      color: grayText;
    }

    .Icon {
      opacity: 1;

      /* stylelint-disable-next-line -- generated by polaris-migrator DO NOT COPY */
      svg {
        fill: grayText;
      }
    }
  }
}
```

# components/select/select.svelte

```svelte
<script lang="ts">
	import { UseToggle } from '$lib/use/use-toggle.svelte.js';
	import { classNames, variationName } from '$utilities/css.js';
	import Box from '../box/box.svelte';
	import { helpTextID } from '../choice/types.js';
	import styles from './select.module.css';
	import Text from '../text/text.svelte';
	import {
		PLACEHOLDER_VALUE,
		type HideableStrictOption,
		type SelectGroup,
		type SelectOption,
		type SelectProps,
		type StrictGroup,
		type StrictOption
	} from './types.js';
	import type { Snippet } from 'svelte';
	import Icon from '../icon/icon.svelte';
	import SelectIcon from '@shopify/polaris-icons/dist/svg/SelectIcon.svg?component';
	import Labelled from '../labelled/labelled.svelte';

	let {
		options: optionsProp,
		label,
		labelAction,
		labelHidden: labelHiddenProp,
		labelInline,
		disabled,
		helpText,
		placeholder,
		id: idProp,
		name,
		value = PLACEHOLDER_VALUE,
		error,
		onChange,
		onFocus,
		onBlur,
		requiredIndicator,
		tone
	}: SelectProps = $props();

	const focused = new UseToggle(false);
	const toggleFocused = focused.toggle;

	const uniqId = $props.id();
	const id = idProp ?? uniqId;
	const labelHidden = labelInline ? true : labelHiddenProp;

	const className = classNames(
		styles.Select,
		error && styles.error,
		tone && styles[variationName('tone', tone)],
		disabled && styles.disabled
	);

	const handleFocus = (event: FocusEvent) => {
		toggleFocused();
		onFocus?.(event);
	};

	const handleBlur = (event: FocusEvent) => {
		toggleFocused();
		onBlur?.(event);
	};

	const handleChange = onChange
		? (event: Event) => onChange((event.target as HTMLSelectElement).value, id)
		: undefined;

	const describedBy: string[] = $derived.by(() => {
		const newDescribedBy: string[] = [];
		if (helpText) {
			newDescribedBy.push(helpTextID(id));
		}
		if (focused.value) {
			newDescribedBy.push(`${id}Error`);
		}
		return newDescribedBy;
	});

	function isString(option: SelectOption | SelectGroup): option is string {
		return typeof option === 'string';
	}

	function isGroup(option: SelectOption | SelectGroup): option is SelectGroup {
		return typeof option === 'object' && 'options' in option && option.options != null;
	}

	function normalizeStringOption(option: string): StrictOption {
		return {
			label: option,
			value: option
		};
	}

	function normalizeOption(option: SelectOption | SelectGroup): HideableStrictOption | StrictGroup {
		if (isString(option)) {
			return normalizeStringOption(option);
		} else if (isGroup(option)) {
			const { title, options } = option;
			return {
				title,
				options: options.map((option) => {
					return isString(option) ? normalizeStringOption(option) : option;
				})
			};
		}

		return option;
	}

	const options = $derived(optionsProp || []);
	const normalizedOptions = $derived.by(() => {
		let newNormalizedOptions = options.map(normalizeOption);
		if (placeholder) {
			newNormalizedOptions = [
				{
					label: placeholder,
					value: PLACEHOLDER_VALUE,
					disabled: true
				},
				...newNormalizedOptions
			];
		}
		return newNormalizedOptions;
	});

	/**
	 * Gets the text to display in the UI, for the currently selected option
	 */
	function getSelectedOption(
		options: (HideableStrictOption | StrictGroup)[],
		value: string
	): HideableStrictOption {
		const flatOptions = flattenOptions(options);
		let selectedOption = flatOptions.find((option) => value === option.value);

		if (selectedOption === undefined) {
			// Get the first visible option (not the hidden placeholder)
			selectedOption = flatOptions.find((option) => !option.hidden);
		}

		return selectedOption || { value: '', label: '' };
	}

	/**
	 * Ungroups an options array
	 */
	function flattenOptions(options: (HideableStrictOption | StrictGroup)[]): HideableStrictOption[] {
		let flatOptions: HideableStrictOption[] = [];

		options.forEach((optionOrGroup) => {
			if (isGroup(optionOrGroup)) {
				flatOptions = flatOptions.concat(optionOrGroup.options);
			} else {
				flatOptions.push(optionOrGroup);
			}
		});

		return flatOptions;
	}

	const selectedOption = $derived(getSelectedOption(normalizedOptions, value));
</script>

{#snippet inlineLabelMarkup()}
	{#if labelInline}
		<Box paddingInlineEnd="100">
			<Text
				as="span"
				variant="bodyMd"
				tone={tone && tone === 'magic' && !focused ? 'magic-subdued' : 'subdued'}
				truncate
			>
				{#if typeof label === 'string'}
					{label}
				{/if}
			</Text>
		</Box>
	{/if}
{/snippet}

{#snippet prefixMarkup()}
	<div class={styles.Prefix}>
		{@render selectedOption.prefix?.()}
	</div>
{/snippet}

{#snippet contentMarkup()}
	<div class={styles.Content} aria-hidden={true} aria-disabled={disabled}>
		{@render inlineLabelMarkup()}
		{@render prefixMarkup()}
		<span class={styles.SelectedOption}>{selectedOption.label}</span>
		<span class={styles.Icon}>
			<Icon source={SelectIcon} />
		</span>
	</div>
{/snippet}

{#snippet renderSingleOption(option: HideableStrictOption)}
	{@const { value, label, prefix: _prefix, key, ...rest } = option}
	<option {value} {...rest}>
		{label}
	</option>
{/snippet}

{#snippet renderOption(optionOrGroup: HideableStrictOption | StrictGroup)}
	{#if isGroup(optionOrGroup)}
		{@const { title, options } = optionOrGroup}
		<optgroup label={title}>
			{#each options as option}
				{@render renderSingleOption(option)}
			{/each}
		</optgroup>
	{:else}
		{@render renderSingleOption(optionOrGroup)}
	{/if}
{/snippet}

{#snippet optionsMarkup()}
	{#each normalizedOptions as option}
		{@render renderOption(option)}
	{/each}
{/snippet}

<Labelled
	{id}
	{label}
	{error}
	action={labelAction}
	{labelHidden}
	{helpText}
	{requiredIndicator}
	{disabled}
>
	<div class={className}>
		<select
			{id}
			{name}
			{value}
			class={styles.Input}
			{disabled}
			onfocus={handleFocus}
			onblur={handleBlur}
			onchange={handleChange}
			aria-invalid={Boolean(error)}
			aria-describedby={describedBy.length ? describedBy.join(' ') : undefined}
			aria-required={requiredIndicator}
		>
			{@render optionsMarkup()}
		</select>
		{@render contentMarkup()}
		<div class={styles.Backdrop}></div>
	</div>
</Labelled>

```

# components/select/types.ts

```ts
import type { Snippet } from "svelte";
import type { LabelledProps } from "../labelled/types.js";
import type { Error } from "$utilities/types.js";

export interface StrictOption {
    /** Machine value of the option; this is the value passed to `onChange` */
    value: string;
    /** Human-readable text for the option */
    label: string;
    /** Option will be visible, but not selectable */
    disabled?: boolean;
    /** Element to display to the left of the option label. Does not show in the dropdown. */
    prefix?: Snippet;
    /** Unique key applied to the option element. Defaults to option value prop when undefined. */
    key?: string;
}

export interface HideableStrictOption extends StrictOption {
    hidden?: boolean;
}

export interface StrictGroup {
    /** Title for the group */
    title: string;
    /** List of options */
    options: StrictOption[];
}

export type SelectOption = string | StrictOption;

export interface SelectGroup {
    title: string;
    options: SelectOption[];
}

export interface SelectProps {
    /** List of options or option groups to choose from */
    options?: (SelectOption | SelectGroup)[];
    /** Label for the select */
    label: string;
    /** Adds an action to the label */
    labelAction?: LabelledProps['action'];
    /** Visually hide the label */
    labelHidden?: boolean;
    /** Show the label to the left of the value, inside the control */
    labelInline?: boolean;
    /** Disable input */
    disabled?: boolean;
    /** Additional text to aide in use */
    helpText?: Snippet;
    /** Example text to display as placeholder */
    placeholder?: string;
    /** ID for form input */
    id?: string;
    /** Name for form input */
    name?: string;
    /** Value for form input */
    value?: string;
    /** Display an error state */
    error?: Error | boolean;
    /** Callback when selection is changed */
    onChange?(selected: string, id: string): void;
    /** Callback when select is focused */
    onFocus?(event?: FocusEvent): void;
    /** Callback when focus is removed */
    onBlur?(event?: FocusEvent): void;
    /** Visual required indicator, add an asterisk to label */
    requiredIndicator?: boolean;
    /** Indicates the tone of the select */
    tone?: 'magic';
}

export const PLACEHOLDER_VALUE = '';
```

# components/setting-action/setting-action.module.css

```css
.SettingAction {
    display: flex;
    flex-wrap: wrap;
    align-items: center;
    margin-top: calc(-1 * var(--p-space-400));
    margin-left: calc(-1 * var(--p-space-400));
}

.Setting,
.Action {
    flex: 0 0 auto;
    margin-top: var(--p-space-400);
    margin-left: var(--p-space-400);
    max-width: calc(100% - var(--p-space-400));
    min-width: 0;
}

.Setting {
    flex: 1 0 350px;
}

.Action {
    @media (--p-breakpoints-md-up) {
        margin-top: var(--p-space-600);
    }
}
```

# components/setting-action/setting-action.svelte

```svelte
<script lang="ts">
	import styles from './setting-action.module.css';
	import type { SettingActionProps } from './types.js';

	let { action, children }: SettingActionProps = $props();
</script>

<div class={styles.SettingAction}>
	<div class={styles.Setting}>{@render children?.()}</div>
	<div class={styles.Action}>{@render action?.()}</div>
</div>

```

# components/setting-action/types.ts

```ts
import type { Snippet } from "svelte";

export interface SettingActionProps {
    action?: Snippet;
    children?: Snippet;
}
```

# components/shadow-bevel/shadow-bevel.module.css

```css
.ShadowBevel {
    overflow: clip;
    /* stylelint-disable-next-line -- Explicitly set `0` to create a local stacking context. While the initial `z-index: auto` has a stack level of `0` within the current stacking context, it does not create a new local stacking context. */
    z-index: 0;
  
    @mixin scope-custom-property shadow-bevel, z-index;
  
    @mixin responsive-props shadow-bevel, box-shadow, --pc-shadow-bevel-box-shadow;
    @mixin responsive-props shadow-bevel, border-radius,
      --pc-shadow-bevel-border-radius;
    @mixin responsive-props shadow-bevel, content, --pc-shadow-bevel-content;
  
    @mixin shadow-bevel var(--pc-shadow-bevel-box-shadow),
      var(--pc-shadow-bevel-border-radius), null, var(--pc-shadow-bevel-content),
      var(--pc-shadow-bevel-z-index);
  }
```

# components/shadow-bevel/shadow-bevel.svelte

```svelte
<script lang="ts">
	import type { BorderRadiusAliasOrScale, ShadowAliasOrScale } from '@shopify/polaris-tokens';
	import styles from './shadow-bevel.module.css';
	import type { ShadowBevelProps } from './types.js';
	import { applyStyles, classNames, createStyleString, getResponsiveValue, mapResponsiveProp, sanitizeCustomProperties } from '$utilities/css.js';

	let { as = 'div', bevel = true, borderRadius, boxShadow, children, zIndex = '0' }: ShadowBevelProps = $props();

    const className = $derived(
        classNames(
          styles.ShadowBevel,
        )
    );

    const style = $derived({
        '--pc-shadow-bevel-z-index': zIndex,
        ...getResponsiveValue(
          'shadow-bevel',
          'content',
          mapResponsiveProp(bevel, (bevel) => (bevel ? '""' : 'none')),
        ),
        ...getResponsiveValue(
          'shadow-bevel',
          'box-shadow',
          mapResponsiveProp(bevel, (bevel) =>
            bevel ? `var(--p-shadow-${boxShadow})` : 'none',
          ),
        ),
        ...getResponsiveValue(
          'shadow-bevel',
          'border-radius',
          mapResponsiveProp(bevel, (bevel) =>
            bevel
              ? `var(--p-border-radius-${borderRadius})`
              : 'var(--p-border-radius-0)',
          ),
        ),
    });
</script>

<svelte:element this={as} class={className} style={applyStyles(style)}>
    {@render children?.()}
</svelte:element>

```

# components/shadow-bevel/types.ts

```ts
import type { ResponsiveProp } from "$utilities/css.js";
import type { BorderRadiusAliasOrScale, ShadowAliasOrScale } from "@shopify/polaris-tokens";
import type { Snippet } from "svelte";

export interface ShadowBevelProps {
    as?: any;
    children?: Snippet;
    /** The box-shadow applied to the root element. */
    boxShadow: ShadowAliasOrScale;
    /** The border-radius applied to both the root and pseudo elements. */
    borderRadius: BorderRadiusAliasOrScale;
    /** The z-index applied to the pseudo element. */
    zIndex?: string;
    /**
     * Enable/disable the bevel effect.
     * Note: This also disables the border-radius and box-shadow.
     * @default true
     */
    bevel?: ResponsiveProp<boolean>;
  }
```

# components/shared.ts

```ts
export const scrollable = {
    props: { 'data-polaris-scrollable': true },
    selector: '[data-polaris-scrollable]',
};

export const overlay = {
    props: { 'data-polaris-overlay': true },
    selector: '[data-polaris-overlay]',
};

export const layer = {
    props: { 'data-polaris-layer': true },
    selector: '[data-polaris-layer]',
};

export const unstyled = {
    props: { 'data-polaris-unstyled': true },
    selector: '[data-polaris-unstyled]',
};

export const dataPolarisTopBar = {
    props: { 'data-polaris-top-bar': true },
    selector: '[data-polaris-top-bar]',
};

export const headerCell = {
    props: { 'data-polaris-header-cell': true },
    selector: '[data-polaris-header-cell]',
};

export const portal = {
    props: ['data-portal-id'],
    selector: '[data-portal-id]',
};

export const DATA_ATTRIBUTE = {
    overlay,
    layer,
};
```

# components/spinner/spinner.module.css

```css
.Spinner svg {
    animation: var(--p-motion-keyframes-spin) var(--p-motion-duration-500) linear infinite;
    fill: var(--p-color-bg-fill-brand);
}

.sizeSmall svg {
    height: 20px;
    width: 20px;
}

.sizeLarge svg {
    height: 44px;
    width: 44px;
}
```

# components/spinner/spinner.svelte

```svelte
<script lang="ts">
	import { classNames, variationName } from '$utilities/css.js';
	import Text from '../text/text.svelte';
	import styles from './spinner.module.css';
	import type { SpinnerProps } from './types.js';

	let { size = 'large', accessibilityLabel, hasFocusableParent }: SpinnerProps = $props();

	const className = $derived(
		classNames(styles.Spinner, size && styles[variationName('size', size)])
	);

    const spanAttributes = {
    ...(!hasFocusableParent && {role: 'status'}),
    'aria-label': accessibilityLabel,
  };
</script>

{#if size == 'large'}
    <span class={className}>
        <svg viewBox="0 0 44 44" xmlns="http://www.w3.org/2000/svg">
            <path
                d="M15.542 1.487A21.507 21.507 0 00.5 22c0 11.874 9.626 21.5 21.5 21.5 9.847 0 18.364-6.675 20.809-16.072a1.5 1.5 0 00-2.904-.756C37.803 34.755 30.473 40.5 22 40.5 11.783 40.5 3.5 32.217 3.5 22c0-8.137 5.3-15.247 12.942-17.65a1.5 1.5 0 10-.9-2.863z"
            />
        </svg>
    </span>
    <Text as="span" {...spanAttributes} visuallyHidden>{accessibilityLabel}</Text>
{:else}
    <span class={className}>
        <svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
            <path d="M7.229 1.173a9.25 9.25 0 1011.655 11.412 1.25 1.25 0 10-2.4-.698 6.75 6.75 0 11-8.506-8.329 1.25 1.25 0 10-.75-2.385z" />
        </svg>
    </span>
    <Text as="span" {...spanAttributes} visuallyHidden>{accessibilityLabel}</Text>
{/if}

```

# components/spinner/types.ts

```ts
type Size = 'small' | 'large';

export interface SpinnerProps {
    /**
     * Size of spinner
     * @default 'large'
     */
    size?: Size;
    /** Accessible label for the spinner */
    accessibilityLabel?: string;
    /** Allows the component to apply the correct accessibility roles based on focus */
    hasFocusableParent?: boolean;
  }
```

# components/sticky/sticky-inner.svelte

```svelte
<script lang="ts">
	import { onMount } from 'svelte';
	import type { CombinedProps, State } from './types.js';
	import { applyStyles } from '$utilities/css.js';
	import { getRectForNode } from '$utilities/geometry.js';

	let states: State = $state({
		isSticky: false,
		style: {}
	});

	let placeHolderNode: HTMLElement | null = $state(null);
	let stickyNode: HTMLElement | null = $state(null);
	let {
		offset = false,
		disableWhenStacked = false,
		stickyManager,
		children,
		onStickyChange,
		boundingElement,
		isSticky = $bindable()
	}: CombinedProps = $props();

	const handlePositioning = (stick: boolean, top = 0, left = 0, width = 0) => {
		isSticky = states.isSticky;

		if ((stick && !isSticky) || (!stick && isSticky)) {
			adjustPlaceHolderNode(stick);
			states.isSticky = !isSticky;

			if (onStickyChange) {
				onStickyChange(!isSticky);
			}

			if (boundingElement) {
				boundingElement.toggleAttribute('data-sticky-active');
			}
		}

		const style = stick
			? {
					position: 'fixed',
					top,
					left,
					width
				}
			: {};

		states.style = style;
	};

	const adjustPlaceHolderNode = (add: boolean) => {
		if (placeHolderNode && stickyNode) {
			placeHolderNode.style.paddingBottom = add ? `${getRectForNode(stickyNode).height}px` : '0px';
		}
	};

	onMount(() => {
		if (!stickyNode || !placeHolderNode) return;

		stickyManager().registerStickyItem({
			stickyNode,
			placeHolderNode,
			handlePositioning,
			offset,
			boundingElement,
			disableWhenStacked
		});

		return () => {
			if (!stickyNode) return;
			stickyManager().unregisterStickyItem(stickyNode);
		};
	});
</script>

<div>
	<div bind:this={placeHolderNode}></div>
	<div bind:this={stickyNode} style={applyStyles(states.style)}>
		{@render children?.()}
	</div>
</div>

```

# components/sticky/sticky.module.css

```css
.container {
  /* Add your styles for sticky here */
}
```

# components/sticky/sticky.svelte

```svelte
<script lang="ts">
	import { useContext } from '$utilities/contexts.js';
	import { STICKY_MANAGER_CONTEXT_KEY } from '$utilities/sticky-manager/context.js';
	import type { StickyManager } from '$utilities/sticky-manager/sticky-manager.js';
	import StickyInner from './sticky-inner.svelte';
	import type { StickyProps } from './types.js';
	//const stickyManager = useStickyManager();
	const stickyManagerContext = useContext<StickyManager>(STICKY_MANAGER_CONTEXT_KEY)
	let {isSticky = $bindable(), ...props}: StickyProps = $props();
</script>

<StickyInner {...props} stickyManager={stickyManagerContext} {isSticky} />
```

# components/sticky/types.ts

```ts
import type { useStickyManager } from "$utilities/sticky-manager/hooks.js";
import type { Snippet } from "svelte";

export interface State {
    isSticky: boolean;
    style: { [key: string]: string | number | undefined };
}

export type StickyProps = {
    /** Element outlining the fixed position boundaries */
    boundingElement?: HTMLElement | null;
    /** Offset vertical spacing from the top of the scrollable container */
    offset?: boolean;
    /** Should the element remain in a fixed position when the layout is stacked (smaller screens)  */
    disableWhenStacked?: boolean;
    /** Callback run when sticky header is added or removed  */
    onStickyChange?: (isSticky: boolean) => void;
    children: Snippet;
    isSticky?: boolean;
}

export type CombinedProps = StickyProps & {
    stickyManager: ReturnType<typeof useStickyManager>;
};
```

# components/tabs/components/create-view-model/create-view-model.module.css

```css
.container {
  /* Add your styles for create-view-model here */
}
```

# components/tabs/components/create-view-model/create-view-model.svelte

```svelte
<script lang="ts">
  import styles from './create-view-model.module.css';
</script>

<div class={styles.container}>
  </div>

```

# components/tabs/components/create-view-model/types.ts

```ts
// Type definitions for create-view-model component
```

# components/tabs/components/item/item.svelte

```svelte
<script lang="ts">
	import UnstyledLink from '$lib/components/button/unstyled-link.svelte';
	import { classNames } from '$utilities/css.js';
	import styles from '../../tabs.module.css';
	import type { ItemProps } from './types.js';

	let { id, focused, children, url, accessibilityLabel }: ItemProps = $props();
	let focusedNode = $state<HTMLButtonElement | null>(null);

	$effect(() => {
		if (focusedNode && focusedNode instanceof HTMLElement && focused) {
			requestAnimationFrame(() => {
				focusedNode?.focus();
			});
		}
	});

	const classname = $derived(classNames(styles.Item));

	const sharedProps = $derived({
		id,
		ref: focusedNode,
		onclick,
		class: classname,
		'aria-selected': false,
		'aria-label': accessibilityLabel
	});
</script>

<li>
	{#if url}
		<UnstyledLink {...sharedProps} {url}>
			{@render children?.()}
		</UnstyledLink>
	{:else}
		<button bind:this={focusedNode} type="button" {...sharedProps}>
			{@render children?.()}
		</button>
	{/if}
</li>

```

# components/tabs/components/item/types.ts

```ts
import type { Snippet } from "svelte";

export interface ItemProps {
    id: string;
    focused: boolean;
    children?: Snippet;
    url?: string;
    accessibilityLabel?: string;
    onClick?(): void;
}
```

# components/tabs/components/list/list.svelte

```svelte
<script lang="ts">
	import { noop } from '$utilities/noop.js';
	import styles from '../../tabs.module.css';
	import Item from '../item/item.svelte';
	import type { ListProps } from './types.js';

	let { focusIndex, disclosureTabs, onClick = noop, onKeyPress = noop }: ListProps = $props();

	function handleKeyDown(event: KeyboardEvent) {
		const { key } = event;

		if (key === 'ArrowLeft' || key === 'ArrowRight') {
			event.preventDefault();
			event.stopPropagation();
		}
	}
</script>

{#snippet tabsMarkup()}
	{#each disclosureTabs as { id, content, ...tabProps }, index}
		<Item
			{...tabProps}
			{id}
			focused={index === focusIndex}
			onClick={onClick.bind(null, id)}
		>
			{content}
		</Item>
	{/each}
{/snippet}

<!-- svelte-ignore a11y_no_noninteractive_element_interactions -->
<ul class={styles.List} onkeydown={handleKeyDown} onkeyup={onKeyPress}>
    {@render tabsMarkup()}
</ul>

```

# components/tabs/components/list/types.ts

```ts
import type { TabProps } from "../../types.js";

export interface ListProps {
    focusIndex: number;
    disclosureTabs: TabProps[];
    onClick?(id: string): void;
    onKeyPress?(event: KeyboardEvent): void;
}
```

# components/tabs/components/panel/panel.svelte

```svelte
<script lang="ts">
	import { classNames } from '$utilities/css.js';
	import styles from '../../tabs.module.css';
	import type { PanelProps } from './types.js';
	let { hidden, id, tabID, children }: PanelProps = $props();
	const className = classNames(styles.Panel, hidden && styles['Panel-hidden']);
</script>

<div class={className}></div>

<div class={className} {id} role="tabpanel" aria-labelledby={tabID} tabIndex={-1}>
	{@render children?.()}
</div>

```

# components/tabs/components/panel/types.ts

```ts
import type { Snippet } from "svelte";

export interface PanelProps {
    hidden?: boolean;
    id: string;
    tabID: string;
    children?: Snippet;
}
```

# components/tabs/components/tab-measurer/tab-measurer.svelte

```svelte
<script lang="ts">
	import { onMount } from 'svelte';
	import type { TabMeasurerProps } from './types.js';
	import { noop } from '$utilities/noop.js';
	import styles from '../../tabs.module.css';
	import { classNames } from '$utilities/css.js';
	import Tab from '../tab/tab.svelte';

	let {
		selected,
		tabs,
		activator,
		tabToFocus,
		siblingTabHasFocus,
		handleMeasurement: handleMeasurementProp
	}: TabMeasurerProps = $props();

	let containerNode = $state<HTMLDivElement | null>(null);
	let animationFrame = $state<number | null>(null);
	const classname = $derived(classNames(styles.Tabs, styles.TabsMeasurer));

	const handleMeasurement = () => {
		if (animationFrame) {
			cancelAnimationFrame(animationFrame);
		}

		animationFrame = requestAnimationFrame(() => {
			if (!containerNode) {
				return;
			}

			const containerWidth = containerNode.offsetWidth - 20 - 28;
			const hiddenTabNodes = containerNode.children;
			const hiddenTabNodesArray = Array.from(hiddenTabNodes);
			const hiddenTabWidths = hiddenTabNodesArray.map((node) => {
				const buttonWidth = Math.ceil(node.getBoundingClientRect().width);
				return buttonWidth + 4;
			});
			const disclosureWidth = hiddenTabWidths.pop() || 0;

			handleMeasurementProp({
				containerWidth,
				disclosureWidth,
				hiddenTabWidths
			});
		});
	};

	/* $effect(() => {
		handleMeasurement();
	}); */

	onMount(() => {
		handleMeasurement();
	});
</script>

{#snippet tabsMarkup()}
	{#each tabs as tab, index}
		<Tab
			measuring
			id={`${tab.id}Measurer`}
			{siblingTabHasFocus}
			focused={index === tabToFocus}
			selected={index === selected}
			url={tab.url}
			content={tab.content}
			onTogglePopover={noop}
			onToggleModal={noop}
		/>
	{/each}
{/snippet}

<div class={classname} bind:this={containerNode}>
	{@render tabsMarkup()}
	{@render activator()}
</div>

```

# components/tabs/components/tab-measurer/types.ts

```ts
import type { Snippet } from "svelte";
import type { TabMeasurements, TabProps } from "../../types.js";

export interface TabMeasurerProps {
    tabToFocus: number;
    siblingTabHasFocus: boolean;
    activator: Snippet;
    selected: number;
    tabs: Omit<TabProps, 'onToggleModal' | 'onTogglePopover'>[];
    handleMeasurement(measurements: TabMeasurements): void;
}
```

# components/tabs/components/tab/components/duplicate-modal/duplicate-modal.svelte

```svelte
<script lang="ts">
	import { focusFirstFocusableNode } from '$utilities/focus.js';
	import { MAX_VIEW_NAME_LENGTH, type DuplicateModalProps } from './types.js';

	let {
		open,
		isModalLoading,
		name,
		onClose,
		onClickPrimaryAction,
		onClickSecondaryAction,
		helpText,
		viewNames
	}: DuplicateModalProps = $props();

	let value = $state(name);
	let container = $state<HTMLDivElement | null>(null);

	const hasSameNameError = $derived(
		viewNames?.some((viewName) => viewName.trim().toLowerCase() === value.trim().toLowerCase())
	);

	const isPrimaryActionDisabled = $derived(
		isModalLoading || hasSameNameError || !value || value.length > MAX_VIEW_NAME_LENGTH
	);

	$effect(() => {
		if (!container) return;
		if (open) {
			focusFirstFocusableNode(container);
		}
	});

	$effect(() => {
		if (open) {
			value = name.slice(0, MAX_VIEW_NAME_LENGTH);
		}
	});

	const handleChange = (newValue: string) => {
		value = newValue;
	};

	async function handlePrimaryAction() {
		if (isPrimaryActionDisabled) {
			return;
		}
		await onClickPrimaryAction(value);
		value = '';
		onClose();
	}

	function handleSecondaryAction() {
		onClickSecondaryAction?.();
		value = name;
		onClose();
	}
</script>

```

# components/tabs/components/tab/components/duplicate-modal/types.ts

```ts
export interface DuplicateModalProps {
    open: boolean;
    isModalLoading?: boolean;
    name: string;
    helpText?: string;
    viewNames?: string[];
    onClose: () => void;
    onClickPrimaryAction: (value: string) => Promise<void>;
    onClickSecondaryAction?: () => void;
}

export const MAX_VIEW_NAME_LENGTH = 40;
```

# components/tabs/components/tab/components/rename-modal/types.ts

```ts

```

# components/tabs/components/tab/tab.svelte

```svelte
<script lang="ts">
	import type { TabAction, TabPropsWithAddedMethods } from '../../types.js';
	import { classNames } from '$utilities/css.js';
	import styles from '../../tabs.module.css';
	import { focusFirstFocusableNode, handleMouseUpByBlurring } from '$utilities/focus.js';
	import InfoIcon from '@shopify/polaris-icons/dist/svg/InfoIcon.svg?component';
	import DuplicateIcon from '@shopify/polaris-icons/dist/svg/DuplicateIcon.svg?component';
	import EditIcon from '@shopify/polaris-icons/dist/svg/EditIcon.svg?component';
	import LayoutColumns3Icon from '@shopify/polaris-icons/dist/svg/LayoutColumns3Icon.svg?component';
	import DeleteIcon from '@shopify/polaris-icons/dist/svg/DeleteIcon.svg?component';
	import Badge from '$lib/components/badge/badge.svelte';
	import Icon from '$lib/components/icon/icon.svelte';
	import ChevronDownIcon from '@shopify/polaris-icons/dist/svg/ChevronDownIcon.svg?component';
	import UnstyledButton from '$lib/components/button/unstyled-button.svelte';
	import UnstyledLink from '$lib/components/link/link.svelte';
	import InlineStack from '$lib/components/inline-stack/inline-stack.svelte';
	import Text from '$lib/components/text/text.svelte';

	let {
		content,
		accessibilityLabel,
		badge,
		id,
		panelID,
		url,
		onAction,
		actions,
		disabled,
		isModalLoading,
		icon,
		siblingTabHasFocus,
		measuring,
		focused,
		selected,
		onToggleModal,
		onTogglePopover,
		viewNames,
		tabIndexOverride,
		disclosureZIndexOverride,
		onFocus,
		ref: node = $bindable()
	}: TabPropsWithAddedMethods & { ref?: HTMLElement } = $props();

	let popoverActive = $state(false);
	let activeModalType = $state<TabAction | null>(null);
	let wasSelected = $state(selected);
	let panelFocused = $state(false);

	function focusPanelID(panelID: string) {
		const panel = document.getElementById(panelID);
		if (panel) {
			panel.focus({ preventScroll: true });
		}
	}

	$effect(() => {
		onTogglePopover(popoverActive);
	});

	$effect(() => {
		onToggleModal(Boolean(activeModalType));
	});

	$effect(() => {
		return () => {
			onToggleModal(false);
			onTogglePopover(false);
		};
	});

	$effect(() => {
		if (measuring) {
			return;
		}

		// Because of timing issues with the render, we may still have the old, in-disclosure version of the tab that has focus. Check for this as a second indicator of focus
		const itemHadFocus = focused || (document.activeElement && document.activeElement.id === id);

		// If we just check for selected, the panel for the active tab will be focused on page load, which we donâ€™t want
		if (itemHadFocus && selected && panelID != null && !panelFocused) {
			focusPanelID(panelID);
			panelFocused = true;
		}

		if (selected && !wasSelected && panelID != null) {
			focusPanelID(panelID);
		} else if (focused && node != null && activeModalType == null && !disabled) {
			focusFirstFocusableNode(node);
		}

		wasSelected = selected;
	});

	let tabIndex: 0 | -1 = $derived.by(() => {
		let newTabindex: 0 | -1 = -1;
		if (selected && !siblingTabHasFocus && !measuring) {
			newTabindex = 0;
		} else if (focused && !measuring) {
			newTabindex = 0;
		} else {
			newTabindex = -1;
		}

		if (tabIndexOverride != null) {
			newTabindex = tabIndexOverride;
		}

		return newTabindex;
	});

	const renameAction = $derived(actions?.find((action) => action.type === 'rename'));
	const duplicateAction = $derived(actions?.find((action) => action.type === 'duplicate'));
	const deleteAction = $derived(actions?.find((action) => action.type === 'delete'));

	const togglePopoverActive = () => {
		if (!actions?.length) {
			return;
		}
		popoverActive = !popoverActive;
	};

	const handleClick = () => {
		if (disabled) {
			return;
		}
		if (selected) {
			togglePopoverActive();
		} else {
			onAction?.();
		}
	};

	const handleModalOpen = (type: TabAction) => {
		activeModalType = type;
	};

	const handleModalClose = () => {
		activeModalType = null;
	};

	const handleSaveRenameModal = async (value: string) => {
		await renameAction?.onPrimaryAction?.(value);

		setTimeout(() => {
			if (node) {
				focusFirstFocusableNode(node);
			}
		}, 250);
	};

	const handleConfirmDeleteView = async () => {
		await deleteAction?.onPrimaryAction?.(content);
		handleModalClose();
	};

	const handleSaveDuplicateModal = async (duplicateName: string) => {
		await duplicateAction?.onPrimaryAction?.(duplicateName);
	};

	const actionContent = {
		rename: {
			icon: InfoIcon,
			content: 'Rename view'
		},
		duplicate: {
			icon: DuplicateIcon,
			content: 'Duplicate view'
		},
		edit: {
			icon: EditIcon,
			content: 'Edit view'
		},
		'edit-columns': {
			icon: LayoutColumns3Icon,
			content: 'Edit columns'
		},
		delete: {
			icon: DeleteIcon,
			content: 'Delete view',
			destructive: true
		}
	};

	const formattedActions = actions?.map(
		({ type, onAction, onPrimaryAction, ...additionalOptions }) => {
			const isModalActivator = !type.includes('edit');
			return {
				...actionContent[type],
				...additionalOptions,
				onAction: () => {
					onAction?.(content);
					togglePopoverActive();
					if (isModalActivator) {
						handleModalOpen(type);
					}
				}
			};
		}
	);

	const handleKeyDown = (event: KeyboardEvent) => {
		if (event.key === ' ') {
			event.preventDefault();
			handleClick();
		}
	};

	const tabContainerClassNames = $derived(
		classNames(styles.TabContainer, selected && styles.Underline)
	);

	const urlIfNotDisabledOrSelected = $derived(disabled || selected ? undefined : url);

	const tabClassName = $derived(
		classNames(
			styles.Tab,
			icon && styles['Tab-iconOnly'],
			popoverActive && styles['Tab-popoverActive'],
			selected && styles['Tab-active'],
			selected && actions?.length && styles['Tab-hasActions']
		)
	);

	const isPlainButton = !selected || !actions?.length;
</script>

{#snippet badgeMarkup()}
	{#if badge}
		<Badge tone={selected ? undefined : 'new'}>{badge}</Badge>
	{/if}
{/snippet}

{#snippet disclosureMarkup()}
	{#if selected && actions?.length}
		<div class={classNames(styles.IconWrap)}>
			<Icon source={ChevronDownIcon} />
		</div>
	{/if}
{/snippet}

{#snippet activator()}
	{@const BaseComponent = urlIfNotDisabledOrSelected ? UnstyledLink : UnstyledButton}
	<BaseComponent
		{id}
		class={tabClassName}
		{tabIndex}
		aria-selected={selected}
		aria-controls={panelID}
		aria-label={accessibilityLabel}
		role={tabIndexOverride == null ? 'tab' : undefined}
		{disabled}
		url={urlIfNotDisabledOrSelected}
		{onFocus}
		onMouseUp={handleMouseUpByBlurring}
		onClick={handleClick}
		onKeyDown={handleKeyDown}
	>
		<InlineStack gap="200" align="center" blockAlign="center" wrap={false}>
			<Text as="span" variant="bodySm" fontWeight="medium">
				{@render icon?.()}
				{content}
			</Text>
			{@render badgeMarkup()}
		</InlineStack>
		{@render disclosureMarkup()}
	</BaseComponent>
{/snippet}

<li class={tabContainerClassNames} bind:this={node} role="presentation">
	{@render activator()}
</li>

```

# components/tabs/components/tab/types.ts

```ts
// Type definitions for tab component
```

# components/tabs/tabs.module.css

```css
:root {
  --item-min-height: var(--p-space-400);
  --item-min-width: 50px;
  --item-vertical-padding: var(--p-space-200);
}

.Outer {
  @media (--p-breakpoints-md-down) {
    max-width: 100%;
    overflow: hidden;
    height: unset;
    padding: 0;
  }
}

.Wrapper {
  @media (--p-breakpoints-md-down) {
    overflow: auto;
    -webkit-overflow-scrolling: touch;
    padding: var(--p-space-200);
  }
}

.WrapperWithNewButton {
  @media (--p-breakpoints-md-up) {
    position: relative;
    display: inline-flex;
    padding-right: var(--p-space-800);
  }
}

.ButtonWrapper {
  @media (--p-breakpoints-md-down) {
    display: flex;
    align-items: center;
    justify-content: flex-start;
  }
}

.Tabs {
  display: flex;
  align-items: center;
  justify-content: flex-start;
  margin: 0;
  padding: 0;
  list-style: none;
  gap: var(--p-space-100);

  @media (--p-breakpoints-md-up) {
    padding: 0 var(--p-space-100);
    flex-wrap: wrap;
    align-items: stretch;
  }
}

.Tab {
  /* stylelint-disable-next-line -- no way to set focus ring without mixin currently */
  @mixin focus-ring wide;
  /* stylelint-disable-next-line -- required to reset button styles on touch screens */
  -webkit-tap-highlight-color: rgba(0, 0, 0, 0);
  position: relative;
  display: inline-flex;
  justify-content: center;
  align-items: center;
  padding: var(--p-space-100) var(--p-space-300);
  border: 0;
  border-radius: var(--p-border-radius-200);
  background-color: transparent;
  color: var(--p-color-text-brand);
  cursor: pointer;
  text-decoration: none;
  width: 100%;
  height: var(--p-height-700);
  min-width: 100%;
  /* IE11 fix for overflowing flex items from parent container */
  margin-top: var(--p-space-025);
  margin-bottom: calc(-1 * var(--p-space-025));
  outline: none;
  text-align: center;
  white-space: nowrap;

  &[aria-disabled='true'] {
    cursor: default;
    color: var(--p-color-text-disabled);

    path {
      fill: var(--p-color-icon-disabled);
    }
  }

  &:not([aria-disabled='true']):hover {
    background-color: var(--p-color-bg-fill-transparent-hover);
    color: var(--p-color-text-brand);
  }

  &:not([aria-disabled='true']):focus {
    background-color: var(--p-color-bg-surface-hover);
    color: var(--p-color-text);
  }

  &:not([aria-disabled='true']):focus-visible {
    background-color: transparent;
    color: var(--p-color-text-brand);
    /* stylelint-disable-next-line -- set focus ring using mixin */
    @mixin focus-ring wide, 0, focused;
  }

  /* stylelint-disable-next-line selector-max-specificity -- specificity required to override focus ring */
  &:not([aria-disabled='true']):focus-visible:not(:active) {
    /* stylelint-disable-next-line -- no way to set focus ring without mixin currently */
    @mixin focus-ring base, 0, focused;
    outline: 0;
  }

  &:not([aria-disabled='true']):active {
    background-color: var(--p-color-bg-surface-tertiary);
    color: var(--p-color-text-brand);
    z-index: var(--p-z-index-1);
  }

  path {
    fill: currentColor;
  }
}

.Tab-active {
  background: var(--p-color-bg-fill-transparent-selected);
  border-radius: var(--p-border-radius-200);
  color: var(--p-color-text);

  &[aria-disabled='true'] {
    background: var(--p-color-bg-surface-disabled);
    color: var(--p-color-text-disabled);
  }

  &:not([aria-disabled='true']):hover,
  &:not([aria-disabled='true']):focus {
    background-color: var(--p-color-bg-fill-transparent-hover);
    color: var(--p-color-text-brand);
  }

  &:not([aria-disabled='true']):active {
    background-color: var(--p-color-bg-fill-transparent-selected);
    color: var(--p-color-text-brand);
  }
}

.Tab-hasActions {
  padding-right: var(--p-space-200);
}

.Tab-iconOnly {
  padding-left: var(--p-space-100);
  padding-right: var(--p-space-100);
  width: var(--p-space-800);
}

.fillSpace {
  .TabContainer {
    flex: 1 1 auto;
  }
}

.fitted {
  flex-wrap: nowrap;

  .TabContainer {
    flex: 1 1 100%;
  }
}

.TabContainer {
  display: flex;
  margin: 0;
  padding: 0;
}

.titleWithIcon {
  display: flex;
}

.List {
  list-style: none;
  margin: 0;
  padding: var(--p-space-200);
}

.Item {
  /* stylelint-disable-next-line -- no way to set unstyled-button without mixin currently */
  @mixin unstyled-button;
  /* stylelint-disable-next-line -- no way to set focus ring without mixin currently */
  @mixin focus-ring base, 0, base;
  display: block;
  width: 100%;
  min-height: var(--item-min-height);
  padding: var(--item-vertical-padding) var(--p-space-400);
  text-align: left;
  text-decoration: none;
  cursor: pointer;
  border-radius: var(--p-border-radius-100);
  color: inherit;

  &::-moz-focus-inner {
    border: none;
  }

  &:hover {
    background-color: var(--p-color-bg-surface-hover);
    color: var(--p-color-text);
  }

  &:active {
    background-color: var(--p-color-bg-surface-active);
    color: var(--p-color-text);
  }

  &:focus-visible:not(:active) {
    /* stylelint-disable-next-line -- no way to set focus ring without mixin currently */
    @mixin focus-ring base, 0, focused;
  }

  &:visited {
    color: inherit;
  }
}

.DisclosureTab {
  display: none;
}

.DisclosureTab-visible {
  display: flex;
}

.DisclosureActivator {
  /* stylelint-disable-next-line -- generated by polaris-migrator DO NOT COPY */
  @mixin focus-ring base, 0, base;
  /* stylelint-disable-next-line -- generated by polaris-migrator DO NOT COPY */
  @mixin unstyled-button;
  height: 100%;
  background-color: transparent;
  color: var(--p-color-text-brand);
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  border-radius: var(--p-border-radius-200);
  padding: 0 var(--p-space-200) 0 var(--p-space-300);
  margin-top: var(--p-space-025);
  border: none;
  outline: none;

  svg {
    fill: var(--p-color-icon);
  }

  &:hover svg,
  &:focus svg {
    fill: var(--p-color-icon);
  }

  &:not([aria-disabled='true']):hover {
    background-color: var(--p-color-bg-fill-transparent-hover);
    color: var(--p-color-text-brand);
  }

  &:not([aria-disabled='true']):focus {
    background-color: transparent;
    color: var(--p-color-text-brand);
  }

  &:not([aria-disabled='true']):focus-visible {
    /* stylelint-disable-next-line -- generated by polaris-migrator DO NOT COPY */
    @mixin focus-ring base, 0, focused;
    outline: 0;
  }

  &:not([aria-disabled='true']):active {
    background-color: var(--p-color-bg-surface-tertiary);
    z-index: var(--p-z-index-1);
  }

  &[aria-disabled='true'] {
    cursor: default;
    color: var(--p-color-text-disabled);
    background: var(--p-color-bg-surface-disabled);

    path {
      fill: var(--p-color-icon-disabled);
    }
  }
}

.TabsMeasurer {
  display: flex;
  gap: 0;
  padding: 0;
  visibility: hidden;
  height: 0;
}

.NewTab {
  padding: 0 var(--p-space-200) 0 var(--p-space-100);

  @media (--p-breakpoints-md-up) {
    position: absolute;
    right: 0;
    top: 0;
    padding: 0;
  }
}

.ActionListWrap {
  display: block;
}

.Panel {
  display: block;

  &:focus {
    outline: none;
  }
}

.Panel-hidden {
  display: none;
}
```

# components/tabs/tabs.svelte

```svelte
<script lang="ts">
	import { UseBreakpoints } from '$lib/use/use-breakpoints.svelte.js';
	import { classNames } from '$utilities/css.js';
	import ChevronDownIcon from '@shopify/polaris-icons/dist/svg/ChevronDownIcon.svg?component';
	import Box from '../box/box.svelte';
	import Icon from '../icon/icon.svelte';
	import Popover from '../popover/popover.svelte';
	import List from './components/list/list.svelte';
	import TabMeasurer from './components/tab-measurer/tab-measurer.svelte';
	import Tab from './components/tab/tab.svelte';
	import styles from './tabs.module.css';
	import {
		CREATE_NEW_VIEW_ID,
		type TabMeasurements,
		type TabProps,
		type TabsProps,
		type TabsState
	} from './types.js';
	import Text from '../text/text.svelte';
	import UnstyledButton from '../button/unstyled-button.svelte';
	import PlusIcon from '@shopify/polaris-icons/dist/svg/PlusIcon.svg?component';
	import Panel from './components/panel/panel.svelte';
	import { getVisibleAndHiddenTabIndices } from './utilities.js';

	let {
		tabs,
		children,
		selected = 0,
		newViewAccessibilityLabel,
		canCreateNewView,
		disabled,
		onCreateNewView,
		onSelect,
		fitted,
		disclosureText,
		disclosureZIndexOverride
	}: TabsProps = $props();

	let bp = new UseBreakpoints();
	let breakpoints = $derived(bp.getCurrentBreakpoints());
	let scrollRef = $state<HTMLDivElement | null>(null);
	let wrapRef = $state<HTMLDivElement | null>(null);
	let selectedTabRef = $state<HTMLElement>();

	let states: TabsState = $state({
		disclosureWidth: 0,
		containerWidth: Infinity,
		tabWidths: [],
		visibleTabs: [],
		hiddenTabs: [],
		showDisclosure: false,
		tabToFocus: -1,
		isNewViewModalActive: false,
		modalSubmitted: false,
		isTabsFocused: false,
		isTabPopoverOpen: false,
		isTabModalOpen: false
	});

	let {
		tabToFocus,
		visibleTabs,
		hiddenTabs,
		showDisclosure,
		isNewViewModalActive,
		modalSubmitted,
		disclosureWidth,
		tabWidths,
		containerWidth,
		isTabsFocused,
		isTabModalOpen,
		isTabPopoverOpen
	} = $derived(states);

	let prevModalOpen = $derived(isTabModalOpen);
	let prevPopoverOpen = $derived(isTabPopoverOpen);

	/* $effect(() => {
		const hasModalClosed = prevModalOpen && !isTabModalOpen;
		const hasPopoverClosed = prevPopoverOpen && !isTabPopoverOpen;
		if (hasModalClosed) {
			states.isTabsFocused = true;
			states.tabToFocus = selected;
		} else if (hasPopoverClosed && !isTabModalOpen) {
			states.isTabsFocused = true;
			states.tabToFocus = selected;
		}
	}); */

	const handleTogglePopover = (isOpen: boolean) => {
		states.isTabPopoverOpen = isOpen;
	};

	const handleToggleModal = (isOpen: boolean) => {
		states.isTabModalOpen = isOpen;
	};

	const handleCloseNewViewModal = () => {
		states.isNewViewModalActive = false;
	};

	const handleSaveNewViewModal = async (value: string) => {
		if (!onCreateNewView) {
			return false;
		}
		const hasExecuted = await onCreateNewView?.(value);
		if (hasExecuted) {
			states.modalSubmitted = true;
		}
		return hasExecuted;
	};

	const handleClickNewTab = () => {
		states.isNewViewModalActive = true;
	};

	const handleTabClick = (id: string) => {
		const tab = tabs.find((aTab) => aTab.id === id);
		if (tab == null) {
			return null;
		}
		const selectedIndex = tabs.indexOf(tab);
		onSelect?.(selectedIndex);
	};

	const handleMeasurement = (measurements: TabMeasurements) => {
		const { hiddenTabWidths: tabWidths, containerWidth, disclosureWidth } = measurements;

		const { visibleTabs, hiddenTabs } = getVisibleAndHiddenTabIndices(
			tabs,
			selected,
			disclosureWidth,
			tabWidths,
			containerWidth
		);

		states.visibleTabs = visibleTabs;
		states.hiddenTabs = hiddenTabs;
		states.disclosureWidth = disclosureWidth;
		states.containerWidth = containerWidth;
		states.tabWidths = tabWidths;
	};

	const handleFocus = (event: FocusEvent) => {
		const target = event.target as HTMLElement;
		const isItem = target.classList.contains(styles.Item);
		const isInNaturalDOMOrder = target.closest(`[data-tabs-focus-catchment]`) || isItem;

		const isDisclosureActivator = target.classList.contains(styles.DisclosureActivator);

		if (isDisclosureActivator || !isInNaturalDOMOrder) {
			return;
		}

		states.isTabsFocused = true;
	};

	const handleBlur = (event: FocusEvent) => {
		const target = event.target as HTMLElement;
		const relatedTarget = event.relatedTarget as HTMLElement;
		const isInNaturalDOMOrder = relatedTarget?.closest?.(`.${styles.Tabs}`);
		const targetIsATab = target?.classList?.contains?.(styles.Tab);
		const focusReceiverIsAnItem = relatedTarget?.classList.contains(styles.Item);

		if (!relatedTarget && !isTabModalOpen && !targetIsATab && !focusReceiverIsAnItem) {
			states.tabToFocus = -1;
			return;
		}

		if (!isInNaturalDOMOrder && !isTabModalOpen && !targetIsATab && !focusReceiverIsAnItem) {
			states.tabToFocus = -1;
			return;
		}

		states.isTabsFocused = false;
	};

	const handleKeyDown = (event: KeyboardEvent) => {
		if (isTabPopoverOpen || isTabModalOpen || isNewViewModalActive) {
			return;
		}
		const { key } = event;

		if (key === 'ArrowLeft' || key === 'ArrowRight') {
			event.preventDefault();
			event.stopPropagation();
		}
	};

	$effect(() => {
		const { visibleTabs, hiddenTabs } = getVisibleAndHiddenTabIndices(
			tabs,
			selected,
			disclosureWidth,
			tabWidths,
			containerWidth
		);

		states.visibleTabs = visibleTabs;
		states.hiddenTabs = hiddenTabs;
	});

	const moveToActiveTab = (offsetLeft: number) => {
		setTimeout(() => {
			if (scrollRef && typeof scrollRef.scroll === 'function') {
				const scrollRefOffset = wrapRef?.offsetLeft || 0;
				scrollRef.scroll({
					left: offsetLeft - scrollRefOffset
				});
			}
		}, 0);
	};

	const moveToSelectedTab = () => {
		const activeButton = selectedTabRef?.querySelector(`.${styles['Tab-active']}`) as HTMLElement;
		if (activeButton) {
			moveToActiveTab(activeButton.offsetLeft);
		}
	};

	$effect(() => {
		if (breakpoints?.mdDown) {
			moveToSelectedTab();
		}
	});

	$effect(() => {
		if (isTabsFocused && !showDisclosure) {
			const tabToFocus = selected;
			states.tabToFocus = tabToFocus;
		}
	});

	const handleKeyPress = (event: KeyboardEvent) => {
		const { showDisclosure, visibleTabs, hiddenTabs, tabToFocus, isNewViewModalActive } = states;
		if (isTabModalOpen || isTabPopoverOpen || isNewViewModalActive) {
			return;
		}
		const key = event.key;
		const tabsArrayInOrder =
			showDisclosure || breakpoints?.mdDown ? visibleTabs.concat(hiddenTabs) : [...visibleTabs];

		let newFocus = tabsArrayInOrder.indexOf(tabToFocus);

		if (key === 'ArrowRight') {
			newFocus += 1;

			if (newFocus === tabsArrayInOrder.length) {
				newFocus = 0;
			}
		}

		if (key === 'ArrowLeft') {
			if (newFocus === -1 || newFocus === 0) {
				newFocus = tabsArrayInOrder.length - 1;
			} else {
				newFocus -= 1;
			}
		}

		const buttonToFocus = tabsArrayInOrder[newFocus];

		if (buttonToFocus != null) {
			states.tabToFocus = buttonToFocus;
		}
	};

	const handleDisclosureActivatorClick = () => {
		states.showDisclosure = !states.showDisclosure;
		states.tabToFocus = hiddenTabs[0];
	};

	const handleClose = () => {
		states.showDisclosure = false;
	};

	const handleListTabClick = (id: string) => {
		handleTabClick(id);
		handleClose();
		states.isTabsFocused = true;
	};

	const createViewA11yLabel = newViewAccessibilityLabel || 'Create new view';

	const tabsToShow = $derived(breakpoints?.mdDown ? [...visibleTabs, ...hiddenTabs] : visibleTabs);

	const disclosureActivatorVisible = $derived(
		visibleTabs.length < tabs.length && !breakpoints?.mdDown
	);

	const classname = $derived(
		classNames(styles.Tabs, fitted && styles.fitted, disclosureActivatorVisible && styles.fillSpace)
	);

	const wrapperClassNames = $derived(
		classNames(styles.Wrapper, canCreateNewView && styles.WrapperWithNewButton)
	);

	const disclosureTabClassName = $derived(
		classNames(styles.DisclosureTab, disclosureActivatorVisible && styles['DisclosureTab-visible'])
	);

	const disclosureButtonClassName = $derived(classNames(styles.DisclosureActivator));
	const disclosureTabs = $derived(hiddenTabs.map((tabIndex) => tabs[tabIndex]));
	const viewNames = $derived(tabs.map(({ content }) => content));
</script>

{#snippet disclosureButtonContent()}
	<Text as="span" variant="bodySm" fontWeight="medium">
		{disclosureText ?? 'More views'}
	</Text>
	<div
		class={classNames(
			styles.IconWrap,
			disclosureActivatorVisible && showDisclosure && styles['IconWrap-open']
		)}
	>
		<Icon source={ChevronDownIcon} tone="subdued" />
	</div>
{/snippet}

{#snippet disclosureButton()}
	<UnstyledButton
		type="button"
		className={disclosureButtonClassName}
		onClick={handleDisclosureActivatorClick}
		aria-label={disclosureText ?? 'More views'}
		{disabled}
	>
		{@render disclosureButtonContent()}
	</UnstyledButton>
{/snippet}

{#snippet renderTabMarkup(tab: TabProps, index: number)}
	{@const viewNames = tabs.map(({ content }) => content)}
	{@const tabPanelID = tab.panelID || `${tab.id}-panel`}
	{@const handleClick = () => {
		handleTabClick(tab.id);
		tab.onAction?.();
	}}
	<Tab
		{...tab}
		id={tab.id}
		panelID={children ? tabPanelID : undefined}
		disabled={disabled || tab.disabled}
		siblingTabHasFocus={tabToFocus > -1}
		focused={index === tabToFocus}
		selected={index === selected}
		onAction={handleClick}
		accessibilityLabel={tab.accessibilityLabel}
		url={tab.url}
		content={tab.content}
		onToggleModal={handleToggleModal}
		onTogglePopover={handleTogglePopover}
		{viewNames}
		{disclosureZIndexOverride}
		bind:ref={selectedTabRef}
	/>
{/snippet}

{#snippet tabsMarkup()}
	{#each tabsToShow as tabIndex}
		{@render renderTabMarkup(tabs[tabIndex], tabIndex)}
	{/each}
{/snippet}

{#snippet tabMeasurer()}
	<TabMeasurer
		{tabToFocus}
		activator={disclosureButton}
		{selected}
		{tabs}
		siblingTabHasFocus={tabToFocus > -1}
		{handleMeasurement}
	/>
{/snippet}

{#snippet newTabIcon()}
	<Icon source={PlusIcon} accessibilityLabel={createViewA11yLabel} />
{/snippet}

{#snippet newTab()}
	<Tab
		id={CREATE_NEW_VIEW_ID}
		content={createViewA11yLabel}
		actions={[]}
		onAction={handleClickNewTab}
		onFocus={() => {
			if (modalSubmitted) {
				states.tabToFocus = selected;
				modalSubmitted = false;
			}
		}}
		icon={newTabIcon}
		{disabled}
		onTogglePopover={handleTogglePopover}
		onToggleModal={handleToggleModal}
		tabIndexOverride={0}
	/>
{/snippet}

{#snippet panelMarkup()}
	{#if children}
		{#each tabs as tab, index}
			{#if selected === index}
				<Panel id={tabs[index].panelID || `${tabs[index].id}-panel`} tabID={tabs[index].id}>
					{@render children()}
				</Panel>
			{:else}
				<Panel
					id={tabs[index].panelID || `${tabs[index].id}-panel`}
					tabID={tabs[index].id}
					hidden
				/>
			{/if}
		{/each}
	{/if}
{/snippet}

<div class={styles.Outer}>
	<Box padding={{ md: '200' }}>
		{@render tabMeasurer()}
		<div class={wrapperClassNames} bind:this={scrollRef}>
			<div class={styles.ButtonWrapper} bind:this={wrapRef}>
				<ul
					role={tabsMarkup.length > 0 ? 'tablist' : undefined}
					class={classname}
					onfocus={handleFocus}
					onblur={handleBlur}
					onkeydown={handleKeyDown}
					onkeyup={handleKeyPress}
					data-tabs-focus-catchment
				>
					{@render tabsMarkup()}

					{#if !breakpoints?.mdDown && tabsToShow.length > 0}
						<li class={disclosureTabClassName} role="presentation">
							<Popover
								preferredPosition="below"
								preferredAlignment="left"
								active={disclosureActivatorVisible && showDisclosure}
								onClose={handleClose}
								autofocusTarget="first-node"
								zIndexOverride={disclosureZIndexOverride}
							>
								{#snippet trigger()}
									{@render disclosureButton()}
								{/snippet}
								<List
									focusIndex={hiddenTabs.indexOf(tabToFocus)}
									{disclosureTabs}
									onClick={handleListTabClick}
									onKeyPress={handleKeyPress}
								/>
							</Popover>
						</li>
					{/if}
				</ul>
			</div>
		</div>
	</Box>

	{@render panelMarkup()}
</div>

```

# components/tabs/types.ts

```ts
import type { ActionListItemDescriptor } from "$utilities/types.js";
import type { Snippet } from "svelte";

export type TabAction =
  | 'rename'
  | 'edit'
  | 'edit-columns'
  | 'duplicate'
  | 'delete';

interface TabActionDescriptor
  extends Omit<ActionListItemDescriptor, 'onAction'> {
  type: TabAction;
  onAction?: (name: string) => void;
  onPrimaryAction?: (name: string) => Promise<boolean> | void;
}

export interface TabProps {
  /** Optional callback invoked when a merchant clicks on a Tab when it is not active */
  onAction?(): void;
  /** The unique identifier for the Tab */
  id: string;
  /** The name of the Tab */
  content: string;
  /** A unique identifier for the panel */
  panelID?: string;
  /** The accessible label for the Tab, if the name alone does not give enough context */
  accessibilityLabel?: string;
  /** A badge to render next to the view name */
  badge?: string;
  /** An icon to render in place of a view name. Please pass the full Icon component, rather
   * than a reference to the particular icon source. */
  icon?: Snippet;
  /** Optional URL if the Tab points to a location */
  url?: string;
  /** If true, will remove the ability to edit/rename/delete the view. */
  isLocked?: boolean;
  /** Whether the Tab is disabled */
  disabled?: boolean;
  /** A list of actions which map to actions that a merchant can take with this  */
  actions?: TabActionDescriptor[];
  /** Optional array that has a list of names of currently existing views. Used to check if a view name is unique. */
  viewNames?: string[];
  /** If true, the primary button in the currently open Modal will show a loading state */
  isModalLoading?: boolean;
  /** If the Tab is currently focused */
  focused?: boolean;
  /** If a sibling Tab currently has focus */
  siblingTabHasFocus?: boolean;
  /** If the Tab is selected */
  selected?: boolean;
  /** If the Tab is currently being measured */
  measuring?: boolean;
  /** Overrides the tabIndex calculated by the Tabs component */
  tabIndexOverride?: 0 | -1;
  /** Override z-index of popovers and tooltips */
  disclosureZIndexOverride?: number;
  /** Optional callback invoked when the Tabs component is focused */
  onFocus?(): void;
}

export interface TabPropsWithAddedMethods extends TabProps {
  /** Callback to let the Tabs know that a Popover is open inside of a Tab. Used to control focus. */
  onTogglePopover: (value: boolean) => void;
  /** Callback to let the Tabs know that a Modal is open inside of a Tab. Used to control focus. */
  onToggleModal: (value: boolean) => void;
}

export interface TabMeasurements {
  containerWidth: number;
  disclosureWidth: number;
  hiddenTabWidths: number[];
}

export interface TabsState {
    disclosureWidth: number;
    tabWidths: number[];
    visibleTabs: number[];
    hiddenTabs: number[];
    containerWidth: number;
    showDisclosure: boolean;
    tabToFocus: number;
    isTabPopoverOpen: boolean;
    isTabModalOpen: boolean;
    isNewViewModalActive: boolean;
    modalSubmitted: boolean;
    isTabsFocused: boolean;
}

export interface TabsProps {
    /** The items that map to each Tab. */
    tabs: TabProps[];
    /** Content to display in tabs */
    children?: Snippet;
    /** The index of the currently selected Tab. */
    selected: number;
    /** Whether the Tabs are disabled or not. */
    disabled?: boolean;
    /** Whether to show the add new view Tab. */
    canCreateNewView?: boolean;
    /** Label for the new view Tab. Will override the default of "Create new view" */
    newViewAccessibilityLabel?: string;
    /** Fit tabs to container */
    fitted?: boolean;
    /** Text to replace disclosures horizontal dots */
    disclosureText?: string;
    /** Override z-index of popovers and tooltips */
    disclosureZIndexOverride?: number;
    /** Optional callback invoked when a Tab becomes selected. */
    onSelect?: (selectedTabIndex: number) => void;
    /** Optional callback invoked when a merchant saves a new view from the Modal */
    onCreateNewView?: (value: string) => Promise<boolean>;
}

export const CREATE_NEW_VIEW_ID = 'create-new-view';
```

# components/tabs/utilities.ts

```ts
import type {TabProps} from './types.js';

export function getVisibleAndHiddenTabIndices(
  tabs: TabProps[],
  selected: number,
  disclosureWidth: number,
  tabWidths: number[],
  containerWidth: number,
) {
  const sumTabWidths = tabWidths.reduce((sum, width) => sum + width, 0);
  const arrayOfTabIndices = tabs.map((_, index) => {
    return index;
  });

  const visibleTabs: number[] = [];
  const hiddenTabs: number[] = [];

  if (containerWidth > sumTabWidths) {
    visibleTabs.push(...arrayOfTabIndices);
  } else {
    visibleTabs.push(selected);

    let tabListWidth = tabWidths[selected];

    arrayOfTabIndices.forEach((currentTabIndex) => {
      if (currentTabIndex !== selected) {
        const currentTabWidth = tabWidths[currentTabIndex];

        if (
          tabListWidth + currentTabWidth >=
          containerWidth - disclosureWidth
        ) {
          hiddenTabs.push(currentTabIndex);
          return;
        }

        visibleTabs.push(currentTabIndex);
        tabListWidth += currentTabWidth;
      }
    });
  }

  return {
    visibleTabs,
    hiddenTabs,
  };
}

```

# components/tag/tag.module.css

```css
.Tag {
  position: relative;
  display: inline-flex;
  max-width: 100%;
  align-items: center;
  padding-inline: calc(var(--p-space-100) + var(--p-space-050));
  background-color: var(--p-color-bg-fill-tertiary);
  border-radius: var(--p-border-radius-200);
  color: var(--p-color-text);

  &.disabled {
    transition: none;
    background: var(--p-color-bg-fill-disabled);
    color: var(--p-color-text-disabled);

    svg {
      fill: var(--p-color-icon-disabled);
    }
  }

  &.clickable {
    /* stylelint-disable-next-line -- generated by polaris-migrator DO NOT COPY */
    @mixin unstyled-button;
    cursor: pointer;
    padding: 0 calc(var(--p-space-100) + var(--p-space-050));
    background-color: var(--p-color-bg-fill-tertiary);
    outline: var(--p-border-width-025) solid transparent;

    &:hover {
      background: var(--p-color-bg-fill-tertiary-hover);
    }

    /* stylelint-disable-next-line -- generated by polaris-migrator DO NOT COPY */
    @mixin focus-ring wide;

    /* stylelint-disable-next-line selector-max-specificity -- use focus-ring mixin */
    &:focus-visible:not(:active) {
      /* stylelint-disable-next-line -- generated by polaris-migrator DO NOT COPY */
      @mixin focus-ring base, 0, focused;
    }

    &:active {
      background: var(--p-color-bg-fill-tertiary-active);
    }

    &:disabled {
      background: var(--p-color-bg-fill-disabled);
      cursor: default;
      pointer-events: none;
      color: var(--p-color-text-disabled);
    }
  }

  &.linkable {
    &:hover {
      background: var(--p-color-bg-fill-tertiary-hover);
    }

    &:active {
      background: var(--p-color-bg-fill-tertiary-active);
    }
  }

  &.removable {
    padding-right: 0;
    padding-inline-end: 0;
  }
}

.Button {
  /* stylelint-disable-next-line -- generated by polaris-migrator DO NOT COPY */
  @mixin unstyled-button;
  display: block;
  flex-shrink: 0;
  height: 18px;
  width: 18px;
  margin: var(--p-space-025);
  margin-left: var(--p-space-050);
  /* stylelint-disable-next-line polaris/border/declaration-property-unit-disallowed-list -- override border-radius */
  border-radius: 7px;
  color: var(--p-color-icon-secondary);

  svg {
    fill: currentColor;
  }

  &:hover {
    background: var(--p-color-bg-fill-tertiary-hover);
    color: var(--p-color-icon-hover);
    outline: var(--p-border-width-025) solid transparent;
  }

  /* stylelint-disable-next-line -- generated by polaris-migrator DO NOT COPY */
  @mixin focus-ring wide;

  &:focus-visible {
    background: var(--p-color-bg-fill-tertiary-hover);
    color: var(--p-color-icon-hover);
  }

  &:focus-visible:not(:active) {
    /* stylelint-disable-next-line -- generated by polaris-migrator DO NOT COPY */
    @mixin focus-ring base, 0, focused;
  }

  &:active {
    background: var(--p-color-bg-fill-tertiary-active);
  }

  &:disabled {
    cursor: default;
    pointer-events: none;

    svg {
      fill: var(--p-color-icon-disabled);
    }
  }
}

.Link {
  display: inline-grid;
  color: var(--p-color-text);
  outline: none;
  border-radius: var(--p-border-radius-200);
  text-decoration: none;

  /* stylelint-disable-next-line -- generated by polaris-migrator DO NOT COPY */
  @mixin focus-ring wide;

  &:focus-visible:not(:active) {
    /* stylelint-disable-next-line -- generated by polaris-migrator DO NOT COPY */
    @mixin focus-ring base, 0, focused;
    text-decoration: underline;
  }

  &:hover {
    background: var(--p-color-bg-fill-tertiary-hover);
    text-decoration: underline;
  }

  &.segmented {
    &:hover {
      background: none;
    }

    &::after {
      margin-right: var(--p-space-100);
    }
  }

  &:active {
    background: var(--p-color-bg-fill-tertiary-active);
  }
}

.Text {
  line-height: var(--p-font-line-height-500);
}

.linkable.removable:hover {
  background: var(--p-color-bg-fill-tertiary-hover);

  /* stylelint-disable-next-line selector-max-class, selector-max-specificity -- override Button background color */
  .Button {
    background: var(--p-color-bg-fill-tertiary-active);
  }
}

.sizeLarge,
.sizeLarge:is(.removable, .linkable) {
  min-height: 24px;
  padding: 0 var(--p-space-200);

  /* stylelint-disable-next-line -- reveal on touch devices */
  @media (hover: none) {
    padding-right: 0;
  }
}

/* stylelint-disable-next-line selector-max-class, selector-max-specificity -- override code above */
.sizeLarge .Link.segmented::after {
  margin-right: 0;
}

.sizeLarge .Button {
  opacity: 0;
  position: absolute;
  right: var(--p-space-050);
  left: auto;
  width: 20px;
  height: 20px;
  margin: 0;
  background-color: var(--p-color-bg-fill-tertiary);

  /* stylelint-disable-next-line -- reveal on touch devices */
  @media (hover: none) {
    opacity: 1;
    position: unset;
  }

  &:hover {
    color: var(--p-color-icon-secondary-hover);
  }

  &:active,
  &:focus {
    color: var(--p-color-icon-secondary-active);
  }
}

.sizeLarge:hover .Button,
.sizeLarge .Button:focus-visible {
  opacity: 1;
}

.sizeLarge:hover .overlay {
  position: absolute;
  top: 0;
  right: 20px;
  bottom: 0;
  width: 12px;
  pointer-events: none;
  background: linear-gradient(to left,
      var(--p-color-bg-fill-tertiary) 0%,
      transparent 100%);
}

/* stylelint-disable-next-line selector-max-class -- match tag hover color */
.sizeLarge.removable.linkable {

  /* stylelint-disable-next-line selector-max-class, selector-max-specificity  -- match tag hover color */
  .Button {
    background-color: var(--p-color-bg-fill-tertiary-hover);

    /* stylelint-disable-next-line -- reveal on touch devices */
    @media (hover: none) {
      background-color: var(--p-color-bg-fill-tertiary);
    }
  }

  /* stylelint-disable-next-line selector-max-class, selector-max-specificity  -- match tag hover color */
  &:hover .overlay {
    background: linear-gradient(to left,
        var(--p-color-bg-fill-tertiary-hover) 0%,
        transparent 100%);
  }
}
```

# components/tag/tag.svelte

```svelte
<script lang="ts">
	import { classNames, variationName } from '$utilities/css.js';
	import styles from './tag.module.css';
	import type { TagProps } from './types.js';
	import Text from '$lib/components/text/text.svelte';
	import { handleMouseUpByBlurring } from '$utilities/focus.js';
	import Icon from '../icon/icon.svelte';
	import XSmallIcon from '@shopify/polaris-icons/dist/svg/XSmallIcon.svg?component';
	let {
		children,
		disabled = false,
		onClick,
		onRemove,
		accessibilityLabel,
		url,
		size
	}: TagProps = $props();

	const segmented = $derived(onRemove && url);
	const className = $derived(
		classNames(
			styles.Tag,
			disabled && styles.disabled,
			onClick && styles.clickable,
			onRemove && styles.removable,
			url && !disabled && styles.linkable,
			segmented && styles.segmented,
			size && styles[variationName('size', size)]
		)
	);
</script>

{#snippet tagText()}
	<Text as="span" variant="bodySm" truncate>
		<span
			title={accessibilityLabel
				? accessibilityLabel
				: typeof children === 'string'
					? children
					: undefined}
			class={styles.Text}
		>
			{@render children?.()}
		</span>
	</Text>
{/snippet}

{#snippet removeButton()}
	{#if onRemove}
		<button
			type="button"
			class={classNames(styles.Button, segmented && styles.segmented)}
			onclick={onRemove}
			onmouseup={handleMouseUpByBlurring}
			{disabled}
		>
			<Icon source={XSmallIcon} />
		</button>
	{/if}
{/snippet}

{#snippet tagContent()}
	{#if url && !disabled}
		<a class={classNames(styles.Link, segmented && styles.segmented)} href={url}>
			{@render tagText()}
		</a>
	{:else}
		{@render tagText()}
	{/if}
{/snippet}

{#if onClick}
	<button
		type="button"
		class={className}
		{disabled}
		onclick={onClick}
		aria-label={accessibilityLabel}
	>
		{@render tagText()}
	</button>
{:else}
	<span class={className} aria-disabled={disabled}>
		{@render tagContent()}
		{#if size === 'large'}
			<span class={styles.overlay}></span>
		{/if}
		{@render removeButton()}
	</span>
{/if}

```

# components/tag/types.ts

```ts
import type { Snippet } from "svelte";

export interface NonMutuallyExclusiveProps {
  /** Content to display in the tag */
  children?: Snippet;
  /** Disables the tag  */
  disabled?: boolean;
  /** Callback when tag is clicked or keypressed. Renders without remove button or url when set. */
  onClick?(): void;
  /** Callback when remove button is clicked or keypressed. */
  onRemove?(): void;
  /** A string to use when tag has more than textual content */
  accessibilityLabel?: string;
  /** Url to navigate to when tag is clicked or keypressed. */
  url?: string;
  /** The size of the tag */
  size?: 'large';
}

export type TagProps = NonMutuallyExclusiveProps &
  (
    | { onClick?(): void; onRemove?: undefined; url?: undefined }
    | { onClick?: undefined; onRemove?(): void; url?: string }
  );
```

# components/text-container/text-container.module.css

```css
.TextContainer {
    /* stylelint-disable-next-line -- Polaris component custom properties */
    --pc-text-container-spacing: var(--p-space-400);

    >*:not(:first-child) {
        /* stylelint-disable-next-line -- generated by polaris-migrator DO NOT COPY */
        margin-top: var(--pc-text-container-spacing);
    }
}

.spacingTight {
    /* stylelint-disable-next-line -- Polaris component custom properties */
    --pc-text-container-spacing: var(--p-space-200);
}

.spacingLoose {
    /* stylelint-disable-next-line -- Polaris component custom properties */
    --pc-text-container-spacing: var(--p-space-500);
}
```

# components/text-container/text-container.svelte

```svelte
<script lang="ts">
	import styles from './text-container.module.css';
	import type { TextContainerProps } from './types.ts';
	import { classNames, variationName } from '$utilities/css.js';
	let { spacing, children }: TextContainerProps = $props();

	const className = $derived(classNames(
    styles.TextContainer,
    spacing && styles[variationName('spacing', spacing)],
  ));
</script>

<div class={className}>{@render children?.()}</div>

```

# components/text-container/types.ts

```ts
// Type definitions for text-container

import type { Snippet } from "svelte";

export type Spacing = 'tight' | 'loose';

export interface TextContainerProps {
  /** The amount of vertical spacing children will get between them */
  spacing?: Spacing;
  /** The content to render in the text container. */
  children?: Snippet;
}
```

# components/text-field/components/resizer/text-field-resizer.svelte

```svelte
<script lang="ts">
	import styles from '../../text-field.module.css';
	import type { ResizerProps } from '../../types.js';
	let {
		contents,
		currentHeight: currentHeightProp = null,
		minimumLines,
		onHeightChange
	}: ResizerProps = $props();

	let animationFrame = $state<number>();
	let currentHeight = $derived<number | null>(currentHeightProp);
	let minimumLinesNode: HTMLDivElement | undefined = $state();
	let contentNode: HTMLDivElement | undefined = $state();

	const handleHeightCheck = () => {
		if (animationFrame) {
			cancelAnimationFrame(animationFrame);
		}

		animationFrame = requestAnimationFrame(() => {
			if (!contentNode || !minimumLinesNode) {
				return;
			}

			const newHeight = Math.max(contentNode.offsetHeight, minimumLinesNode.offsetHeight);

			if (newHeight !== currentHeight) {
				onHeightChange(newHeight);
			}
		});
	};
	const ENTITIES_TO_REPLACE = {
		'&': '&amp;',
		'<': '&lt;',
		'>': '&gt;',
		'\n': '<br>',
		'\r': ''
	};

	const REPLACE_REGEX = new RegExp(`[${Object.keys(ENTITIES_TO_REPLACE).join()}]`, 'g');

	function replaceEntity(matchedSubstring: string): string {
		const entityKey = matchedSubstring as keyof typeof ENTITIES_TO_REPLACE;
		return ENTITIES_TO_REPLACE[entityKey];
	}
</script>

{#snippet minimumLinesMarkup()}
	{#if minimumLines}
		<div bind:this={minimumLinesNode} class={styles.DummyInput}>
			{#each Array.from({ length: minimumLines }) as _}
				<br />
			{/each}
		</div>
	{/if}
{/snippet}

<div class={styles.Resizer} onresize={handleHeightCheck}>
	<div bind:this={contentNode} class={styles.DummyInput}>
		{#if contents}
			{contents.replace(REPLACE_REGEX, replaceEntity)}
		{:else}
			<br />
		{/if}
	</div>
	{@render minimumLinesMarkup()}
</div>

```

# components/text-field/components/spinner/spinner.svelte

```svelte
<script lang="ts">
	import Icon from '$lib/components/icon/icon.svelte';
	import ChevronUpIcon from '@shopify/polaris-icons/dist/svg/ChevronUpIcon.svg?component';
	import ChevronDownIcon from '@shopify/polaris-icons/dist/svg/ChevronDownIcon.svg?component';
	import styles from '../../text-field.module.css';
	import type { HandleStepFn, SpinnerProps } from '../../types.js';
	let { onChange, onClick, onMouseDown, onMouseUp, onBlur, ref }: SpinnerProps = $props();

	function handleStep(step: number) {
		return () => onChange(step);
	}

	function handleMouseDown(onChange: HandleStepFn) {
		return (event: MouseEvent) => {
			if (event.button !== 0) return;
			onMouseDown?.(onChange);
		};
	}
</script>

<div class={styles.Spinner} onclick={onClick} bind:this={ref}>
	<div
		role="button"
		class={styles.Segment}
		tabindex={-1}
		onclick={handleStep(1)}
		onmousedown={handleMouseDown(handleStep(1))}
		onmouseup={onMouseUp}
		onblur={onBlur}
	>
		<div class={styles.SpinnerIcon}>
			<Icon source={ChevronUpIcon} />
		</div>
	</div>
	<div
		role="button"
		class={styles.Segment}
		tabindex={-1}
		onclick={handleStep(-1)}
		onmousedown={handleMouseDown(handleStep(-1))}
		onmouseup={onMouseUp}
		onblur={onBlur}
	>
		<div class={styles.SpinnerIcon}>
			<Icon source={ChevronDownIcon} />
		</div>
	</div>
</div>

```

# components/text-field/create-element.svelte

```svelte
<script lang="ts">
	import type { HTMLInputAttributes, HTMLTextareaAttributes } from 'svelte/elements';

	// Define the expected props. Many are optional.
	// We use intersection for attributes and add custom/logic props.
	type BaseProps = {
		multiline?: boolean;
		value?: string | number; // For direct value control or initial value
		class?: string; // Svelte uses 'class' instead of 'className'

		// For refs, Svelte uses bind:this.
		// If the parent needs the ref, it's best to pass a callback.
		elementRef?: HTMLInputElement | HTMLTextAreaElement | null;

		// Event handlers: Svelte 5 uses lowercase direct properties or on:event
		// We'll assume they are passed in lowercase if spread, or handle specific ones.
		onfocus?: (e: FocusEvent & { currentTarget: HTMLInputElement | HTMLTextAreaElement }) => void;
		onblur?: (e: FocusEvent & { currentTarget: HTMLInputElement | HTMLTextAreaElement }) => void;
		onclick?: (e: MouseEvent & { currentTarget: HTMLInputElement | HTMLTextAreaElement }) => void;
		onkeypress?: (
			e: KeyboardEvent & { currentTarget: HTMLInputElement | HTMLTextAreaElement }
		) => void;
		onkeydown?: (
			e: KeyboardEvent & { currentTarget: HTMLInputElement | HTMLTextAreaElement }
		) => void;
		oninput?: (e: Event & { currentTarget: HTMLInputElement | HTMLTextAreaElement }) => void; // More specific: InputEvent
		onchange?: (e: Event & { currentTarget: HTMLInputElement | HTMLTextAreaElement }) => void;

		// All other HTML attributes (name, id, disabled, readOnly, type, aria-*, data-*, etc.)
		// will be caught by {...restProps}
		[key: string]: any;
	};

	// Props specific to <input> not already in HTMLInputAttributes if needed
	// interface CustomInputProps { /* ... */ }
	// Props specific to <textarea> not already in HTMLTextareaAttributes if needed
	// interface CustomTextareaProps { /* ... */ }

	type AllProps = BaseProps &
		Partial<Omit<HTMLInputAttributes & HTMLTextareaAttributes, 'value' | 'class'>>;

	let {
		multiline = false,
		value: currentValue = $bindable(),
		className,
		elementRef = $bindable(),
		// Event handlers can be destructured if special logic is needed,
		// otherwise they'll be in restProps.
		onfocus,
		onblur,
		onclick,
		onkeypress,
		onkeydown,
		oninput,
		onchange,
		...restProps // Captures all other attributes like name, id, type, aria-*, data-*, etc.
	}: AllProps = $props();

	const tagName = $derived(multiline ? 'textarea' : 'input');
</script>

{#if tagName == 'input'}
	<input
		bind:this={elementRef}
		class={className}
		bind:value={currentValue}
		{...restProps}
		{onfocus}
		{onblur}
		{onclick}
		{onkeypress}
		{onkeydown}
		{oninput}
		{onchange}
	/>
{:else if tagName == 'textarea'}
	<textarea
		bind:this={elementRef}
		class={className}
		bind:value={currentValue}
		{...restProps}
		{onfocus}
		{onblur}
		{onclick}
		{onkeypress}
		{onkeydown}
		{oninput}
		{onchange}
	></textarea>
{/if}

```

# components/text-field/text-field.module.css

```css
.TextField {
    /* stylelint-disable -- Polaris component custom properties */
    --pc-text-field-contents: 20;
    --pc-text-field-backdrop: 10;
    /* stylelint-enable */
    /* stylelint-disable-next-line -- polaris-migrator DO NOT COPY */
    @mixin text-style-input;
    position: relative;
    display: flex;
    align-items: center;
    color: var(--p-color-text);
    cursor: text;

    svg {
        fill: var(--p-color-icon-secondary);
    }

    /* only show the clear button when focused within the textfield */
    &:focus-within {
        .ClearButton {
            visibility: visible;
            opacity: 1;
        }

        /* stylelint-disable-next-line -- needed to remove extra margin between loading indicator and clear button when visible */
        .Loading:has(+ .ClearButton) {
            margin-right: 0;
        }
    }

    &:not(:focus-within) {
        .ClearButton {
            visibility: hidden;
            opacity: 0;
            position: absolute;
            right: 0;
        }
    }

    /* stylelint-disable-next-line selector-max-specificity -- set Backdrop styles */
    &:not(.disabled):not(.error):not(.readOnly)>.Input:hover:not(:focus-visible) {

        /* stylelint-disable-next-line -- set Backdrop styles */
        ~.Backdrop {
            border-color: var(--p-color-input-border-hover);
            background-color: var(--p-color-input-bg-surface-hover);
        }
    }
}

.multiline {
    padding: 0;
    flex-wrap: wrap;

    >.Input {
        overflow: auto;
        padding-left: var(--p-space-300);
        padding-right: var(--p-space-300);
        resize: none;
    }
}

.hasValue {
    color: var(--p-color-text);
}

.focus>.Input,
.focus>.VerticalContent,
.focus>.InputAndSuffixWrapper,
.TextField:focus-within>.Input,
.Input:focus-visible {
    outline: none;

    /* stylelint-disable-next-line selector-max-class, selector-max-combinators, selector-max-specificity -- outline based on child focus requires complex specificity */
    ~.Backdrop {
        border-color: var(--p-color-input-border-active);
        border-width: var(--p-border-width-025);
        background-color: var(--p-color-input-bg-surface-active);

        /* stylelint-disable-next-line -- remove focus ring mixin */
        @mixin no-focus-ring;
        outline: var(--p-border-width-050) solid var(--p-color-border-focus);
        outline-offset: var(--p-space-025);
    }
}

.error {

    /* stylelint-disable-next-line -- set Backdrop styles */
    .Input:hover~.Backdrop,
    .Input:focus-visible~.Backdrop {
        border-color: var(--p-color-border-critical-secondary);
        background-color: var(--p-color-bg-surface-critical);
    }

    /* stylelint-disable-next-line -- set Backdrop styles */
    .Input:active~.Backdrop,
    .Input:focus-visible~.Backdrop {
        border-width: var(--p-border-width-025);
    }

    /* stylelint-disable-next-line selector-max-class, selector-max-combinators -- generated by polaris-migrator DO NOT COPY */
    >.Input~.Backdrop,
    >.InputAndSuffixWrapper~.Backdrop {
        background-color: var(--p-color-bg-surface-critical);
        border-color: var(--p-color-border-critical-secondary);

        /* stylelint-disable-next-line selector-max-class, selector-max-combinators, selector-max-specificity -- generated by polaris-migrator DO NOT COPY */
        &::after {
            border-color: var(--p-color-border-focus);
        }
    }
}

/* stylelint-disable -- specificity bump for readOnly styles to override */
.readOnly.readOnly {
    >.Input {
        color: var(--p-color-text-secondary);
    }

    >.Backdrop {
        background-color: var(--p-color-bg-surface-disabled);
        border-color: transparent;
    }

    &.focus {
        >.Backdrop {
            background-color: var(--p-color-bg-surface-disabled);
            border-color: transparent;
        }
    }
}

/* stylelint-enable */

/* stylelint-disable selector-max-specificity, selector-max-class, selector-max-combinators -- specificity bump for magic styles to override */
.toneMagic {

    .Prefix,
    .Suffix {
        color: var(--p-color-text-magic-secondary);
    }

    >.Input {
        color: var(--p-color-text-magic);
    }

    >.Backdrop {
        background-color: var(--p-color-bg-surface-magic);
        border-color: var(--p-color-border-magic-secondary);
    }

    svg {
        fill: var(--p-color-icon-magic);
    }

    &:not(.disabled):not(.error):not(.readOnly)>.Input:hover:not(:focus-visible) {
        ~.Backdrop {
            background-color: var(--p-color-bg-surface-magic-hover);
            border-color: var(--p-color-border-magic-secondary-hover);
        }
    }

    &.focus>.Input,
    &.focus>.VerticalContent,
    &.TextField:focus-within>.Input,
    &.Input:focus-visible {
        color: var(--p-color-text);
    }

    &.focus {

        .Prefix,
        .Suffix {
            color: var(--p-color-text-secondary);
        }

        svg {
            fill: var(--p-color-icon-secondary);
        }
    }
}

/* stylelint-enable */

.disabled {
    color: var(--p-color-text-disabled);
    cursor: initial;

    >.Backdrop {
        border: none;
        background-color: var(--p-color-bg-surface-disabled);
    }

    svg {
        fill: var(--p-color-icon-disabled);
    }
}

.InputAndSuffixWrapper {
    display: flex;
    align-items: center;
    flex: 1 1 0%;
    width: 100%;
}

.AutoSizeWrapper {
    position: relative;
    display: inline-grid;
    align-items: center;

    &::after {
        content: attr(data-auto-size-value);
        visibility: hidden;
        white-space: pre-wrap;

        /* needed to ensure the textfield doesn't grow in height when the text field content overgrows the available space */
        /* stylelint-disable-next-line -- polaris custom global property */
        max-height: var(--pg-control-height);
    }

    &::after,
    input,
    textarea {
        width: auto;
        min-width: 1em;
        grid-area: 1 / 2;
        padding: 0 var(--p-space-300);
        font-size: var(--p-font-size-400);
        font-weight: var(--p-font-weight-regular);
        line-height: var(--p-font-line-height-600);

        @media (--p-breakpoints-md-up) {
            font-size: var(--p-font-size-325);
            line-height: var(--p-font-line-height-500);
        }
    }
}

.Prefix+.InputAndSuffixWrapper {

    /* stylelint-disable-next-line selector-max-combinators, selector-max-class, selector-max-specificity -- necessary to remove padding when autosizing and with prefix */
    .AutoSizeWrapper::after,
    input,
    textarea {
        padding-left: 0;
    }
}

.AutoSizeWrapperWithSuffix {

    &::after,
    input,
    textarea {
        padding-right: 0;
    }
}

.Input {
    font-size: var(--p-font-size-400);
    font-weight: var(--p-font-weight-regular);
    line-height: var(--p-font-line-height-600);
    letter-spacing: initial;
    position: relative;
    /* stylelint-disable-next-line -- generated by polaris-migrator DO NOT COPY */
    z-index: var(--pc-text-field-contents);
    display: flex;
    flex: 1 1 0%;
    width: 100%;
    min-width: 0;
    /* stylelint-disable-next-line -- polaris custom global property */
    min-height: var(--pg-control-height);
    padding: var(--p-space-150) var(--p-space-300);
    background: none;
    border: none;
    font-family: var(--p-font-family-sans);
    appearance: none;
    caret-color: var(--p-color-text);
    color: var(--p-color-text);
    align-items: center;

    @media (--p-breakpoints-md-up) {
        font-size: var(--p-font-size-325);
        line-height: var(--p-font-line-height-500);
    }

    .Prefix+& {
        padding-left: 0;
    }

    &:disabled {
        opacity: 1;
        background: none;
        color: var(--p-color-text-disabled);
        -webkit-text-fill-color: var(--p-color-text-disabled);
    }

    /* remove the box shadow in Firefox when the input is invalid */
    &:invalid {
        box-shadow: none;
    }

    &::placeholder {
        color: var(--p-color-text-secondary);
    }

    /* These properties are used to remove the default "spinner" controls
       for number fields, since we add our own, custom versions instead. */
    &[type='number'] {
        appearance: textfield;

        &::-webkit-outer-spin-button,
        &::-webkit-inner-spin-button {
            appearance: none;
            margin: 0;
        }
    }

    &:-webkit-autofill {
        border-radius: var(--p-border-radius-100);
    }

    &.suggestion {
        &::selection {
            color: var(--p-color-text-disabled);
            background: transparent;
        }
    }
}

.borderless {

    .Input,
    .Backdrop {
        border: none;
        min-height: var(--p-space-800);
    }
}

.slim {

    .Input,
    .Backdrop {
        min-height: 28px;
        padding-block: var(--p-space-050);
    }
}

/* stylelint-disable -- override focus ring offset by increasing specificity */
.slim.borderless.slim.borderless {

    .Input,
    .Backdrop {
        outline-offset: 0;
    }
}

/* stylelint-enable */

.Input-hasClearButton {

    /* Hide webkit search input clear button */
    &[type='search'] {
        &::-webkit-search-cancel-button {
            appearance: none;
        }
    }
}

.Input-suffixed {
    padding-right: 0;
}

.Input-alignRight {
    text-align: right;
}

.Input-alignLeft {
    text-align: left;
}

.Input-alignCenter {
    text-align: center;
}

.Input-autoSize {
    flex: initial;
    width: auto;
}

.Backdrop {
    /* stylelint-disable-next-line -- generated by polaris-migrator DO NOT COPY */
    @mixin focus-ring base, 1px;
    position: absolute;
    /* stylelint-disable-next-line -- generated by polaris-migrator DO NOT COPY */
    z-index: var(--pc-text-field-backdrop);
    top: 0;
    right: 0;
    bottom: 0;
    left: 0;
    background-color: var(--p-color-input-bg-surface);
    border: var(--p-border-width-0165) solid var(--p-color-input-border);
    /* stylelint-disable-next-line -- hard coded to address accessbility issue https://github.com/Shopify/polaris/issues/7838 */
    border-top-color: #898f94;
    border-radius: var(--p-border-radius-200);
    pointer-events: none;
}

.Prefix,
.Suffix {
    position: relative;
    /* stylelint-disable-next-line -- generated by polaris-migrator DO NOT COPY */
    z-index: var(--pc-text-field-contents);
    flex: 0 0 auto;
    color: var(--p-color-text-secondary);
    user-select: none;
}

.Prefix {
    margin-left: var(--p-space-300);
    margin-right: var(--p-space-150);
}

.PrefixIcon {
    margin-left: var(--p-space-200);
    margin-right: var(--p-space-100);
}

.Suffix {
    margin-left: var(--p-space-100);
    margin-right: var(--p-space-300);
}

.VerticalContent {
    position: relative;
    /* stylelint-disable-next-line -- generated by polaris-migrator DO NOT COPY */
    z-index: var(--pc-text-field-contents);
    color: var(--p-color-text-secondary);
    padding: var(--p-space-200) var(--p-space-200) 0 var(--p-space-200);
    max-height: 140px;
    overflow: auto;
    border: var(--p-border-width-025) solid transparent;
    width: 100%;

    >.Input {
        padding-left: 0;
        padding-right: 0;
    }

    @media (--p-breakpoints-sm-up) {
        max-height: 328px;
    }
}

.Loading {
    /* stylelint-disable-next-line -- Needed to render the spinner above the Backdrop */
    z-index: var(--pc-text-field-contents);
    margin-right: var(--p-space-300);

    svg {
        display: block;
    }
}

.CharacterCount {
    color: var(--p-color-text-secondary);
    /* stylelint-disable-next-line -- generated by polaris-migrator DO NOT COPY */
    z-index: var(--pc-text-field-contents);
    margin: 0 var(--p-space-300) 0 var(--p-space-100);
    pointer-events: none;
    text-align: right;
}

.AlignFieldBottom {
    align-self: flex-end;
    width: 100%;
    padding-bottom: var(--p-space-200);
}

.ClearButton {
    /* stylelint-disable-next-line -- generated by polaris-migrator DO NOT COPY */
    @mixin focus-ring base, 0, base;
    /* stylelint-disable-next-line -- generated by polaris-migrator DO NOT COPY */
    @mixin unstyled-button;
    /* stylelint-disable-next-line -- generated by polaris-migrator DO NOT COPY */
    z-index: var(--pc-text-field-contents);
    margin: 0 var(--p-space-300) 0 var(--p-space-100);
    transition: visibility var(--p-motion-duration-100) var(--p-motion-ease-out),
        opacity var(--p-motion-duration-100) var(--p-motion-ease-out);

    &:focus-visible:enabled {
        /* stylelint-disable-next-line -- generated by polaris-migrator DO NOT COPY */
        @mixin focus-ring base, 0, focused;
    }

    &:disabled {
        cursor: default;
    }
}

.Spinner {
    /* stylelint-disable-next-line -- generated by polaris-migrator DO NOT COPY */
    z-index: var(--pc-text-field-contents);
    margin: var(--p-space-100);
    color: var(--p-color-icon);
    display: flex;
    visibility: hidden;
    align-self: stretch;
    flex-direction: column;
    width: 22px;
    cursor: pointer;

    justify-content: center;

    .focus &,
    .TextField:hover & {
        visibility: visible;
    }
}

.SpinnerIcon {
    position: absolute;

    /* Safari: prevent highlighting icon */
    user-select: none;

    svg {
        fill: var(--p-color-icon);
    }
}

.Resizer {
    position: absolute;
    bottom: 0;
    left: 0;
    right: 0;
    height: 0;
    visibility: hidden;
    overflow: hidden;
}

.DummyInput {
    /* stylelint-disable-next-line -- polaris-migrator DO NOT COPY */
    @mixin text-style-input;
    /* stylelint-disable-next-line -- polaris custom global property */
    padding: var(--pg-control-vertical-padding) var(--p-space-300);

    /* We need the following properties in order to have long, unbroken
       strings wrap in the same way they do in textareas. */
    /* stylelint-disable-next-line -- polaris-migrator DO NOT COPY */
    @mixin text-breakword;
    white-space: pre-wrap;
}

.Segment {
    background: var(--p-color-bg-fill-tertiary);
    border-radius: var(--p-border-radius-100);
    display: flex;
    flex: 1 1 0%;
    justify-content: center;
    align-items: center;
    appearance: none;
    border: none;

    &:hover {
        background: var(--p-color-bg-fill-tertiary-hover);
    }

    &:focus {
        outline: none;
    }

    &:active {
        background: var(--p-color-bg-fill-tertiary-active);
    }

    &:first-child {
        margin-bottom: 0;
        border-bottom-left-radius: 0;
        border-bottom-right-radius: 0;
    }

    &:last-child {
        border-top-left-radius: 0;
        border-top-right-radius: 0;
    }

    &:not(:first-child) {
        margin-top: 0;
    }
}

.monospaced {
    font-family: var(--p-font-family-mono);
}
```

# components/text-field/text-field.svelte

```svelte
<script lang="ts">
	import { classNames, variationName } from '$utilities/css.js';
	import styles from './text-field.module.css';
	import type { SpinnerProps, TextFieldProps } from './types.js';
	import Text from '../text/text.svelte';
	import LoadingSpinner from '../spinner/spinner.svelte';
	import XCircleIcon from '@shopify/polaris-icons/dist/svg/XCircleIcon.svg?component';
	import Icon from '../icon/icon.svelte';
	import { browser } from '$app/environment';
	import TextFieldResizer from './components/resizer/text-field-resizer.svelte';
	import { Key } from '$utilities/types.js';
	import CreateElement from './create-element.svelte';
	import Labelled from '../labelled/labelled.svelte';
	import Connected from '../connected/connected.svelte';
	import Spinner from './components/spinner/spinner.svelte';

	let {
		prefix,
		suffix,
		verticalContent,
		placeholder,
		value = $bindable(''),
		helpText,
		label,
		labelAction,
		labelHidden,
		disabled,
		clearButton,
		readOnly,
		autoFocus,
		focused,
		multiline,
		error,
		connectedRight,
		connectedLeft,
		type = 'text',
		name,
		id: idProp,
		role,
		step,
		largeStep,
		autoComplete,
		max,
		maxLength,
		maxHeight,
		min,
		minLength,
		pattern,
		inputMode,
		spellCheck,
		ariaOwns,
		ariaControls,
		ariaExpanded,
		ariaActiveDescendant,
		ariaAutocomplete,
		showCharacterCount,
		align,
		requiredIndicator,
		monospaced,
		selectTextOnFocus,
		suggestion,
		variant = 'inherit',
		size = 'medium',
		onClearButtonClick,
		onChange,
		onSpinnerChange,
		onFocus,
		onBlur,
		tone,
		autoSize,
		loading
	}: TextFieldProps = $props();

	let height = $state<number | null>(null);
	let focus = $derived(focused ?? false);
	const uniqId = $props.id();
	const id = idProp ?? uniqId;

	let textFieldRef = $state<HTMLDivElement>();
	let inputRef = $state<HTMLInputElement>();
	let textAreaRef = $state<HTMLTextAreaElement>();
	let prefixRef = $state<HTMLDivElement>();
	let suffixRef = $state<HTMLDivElement>();
	let loadingRef = $state<HTMLDivElement>();
	let verticalContentRef = $state<HTMLDivElement>();
	let buttonPressTimer = $state<number>();
	let spinnerRef = $state<HTMLDivElement>();
	let describedBy: string[] = $derived.by(() => {
		const newDescribedByArray: string[] = [];
		if (error) {
			newDescribedByArray.push(`${id}Error`);
		}
		if (helpText) {
			newDescribedByArray.push(helpTextID(id));
		}
		if (showCharacterCount) {
			newDescribedByArray.push(`${id}-CharacterCounter`);
		}
		return newDescribedByArray;
	});
	const labelledBy: string[] = $derived.by(()=>{
		const newLabelledByArray: string[] = [];
		if (prefix) {
			newLabelledByArray.push(`${id}-Prefix`);
		}

		if (suffix) {
			newLabelledByArray.push(`${id}-Suffix`);
		}

		if (verticalContent) {
			newLabelledByArray.push(`${id}-VerticalContent`);
		}

		newLabelledByArray.unshift(labelID(id));
		return newLabelledByArray;
	});

	const isSupportedInputType = $derived(
		type === 'text' ||
		type === 'tel' ||
		type === 'search' ||
		type === 'url' ||
		type === 'password'
	);

	const getInputRef = () => {
		return multiline ? textAreaRef : inputRef;
	};

	function helpTextID(id: string) {
		return `${id}HelpText`;
	}

	function labelID(id: string) {
		return `${id}Label`;
	}


	let normalizedValue = $derived(suggestion ? suggestion : value);
	const normalizedStep = $derived(step != null ? step : 1);
	const normalizedMax = $derived(max != null ? max : Infinity);
	const normalizedMin = $derived(min != null ? min : -Infinity);

	const className = $derived(
		classNames(
			styles.TextField,
			Boolean(normalizedValue) && styles.hasValue,
			disabled && styles.disabled,
			readOnly && styles.readOnly,
			error && styles.error,
			tone && styles[variationName('tone', tone)],
			multiline && styles.multiline,
			focus && !disabled && styles.focus,
			variant !== 'inherit' && styles[variant],
			size === 'slim' && styles.slim
		)
	);

	const inputType = type === 'currency' ? 'text' : type;
	const isNumericType = type === 'number' || type === 'integer';
	const characterCountClassName = $derived(
		classNames(styles.CharacterCount, multiline && styles.AlignFieldBottom)
	);

	function handleClearButtonPress() {
		onClearButtonClick && onClearButtonClick(id);
	}

	const handleNumberChange = (steps: number, stepAmount = normalizedStep) => {
		if (onChange == null && onSpinnerChange == null) {
			return;
		}

		const dpl = (num: number) => (num.toString().split('.')[1] || []).length;

		const numericValue = value ? parseFloat(value) : 0;
		if (isNaN(numericValue)) {
			return;
		}

		// Making sure the new value has the same length of decimal places as the
		// step / value has.
		const decimalPlaces = type === 'integer' ? 0 : Math.max(dpl(numericValue), dpl(stepAmount));

		const newValue = Math.min(
			Number(normalizedMax),
			Math.max(numericValue + steps * stepAmount, Number(normalizedMin))
		);

		if (onSpinnerChange != null) {
			onSpinnerChange(String(newValue.toFixed(decimalPlaces)), id);
		} else if (onChange != null) {
			onChange(String(newValue.toFixed(decimalPlaces)), id);
		}
	};

	const handleSpinnerButtonRelease = () => {
		clearTimeout(buttonPressTimer);
	};

	const handleSpinnerButtonPress: SpinnerProps['onMouseDown'] = (onChange) => {
		const minInterval = 50;
		const decrementBy = 10;
		let interval = 200;

		const onChangeInterval = () => {
			if (interval > minInterval) interval -= decrementBy;
			onChange(0);
			buttonPressTimer = window.setTimeout(onChangeInterval, interval);
		};

		buttonPressTimer = window.setTimeout(onChangeInterval, interval);

		document.addEventListener('mouseup', handleSpinnerButtonRelease, {
			once: true
		});
	};

	const style = $derived(multiline && height ? { height, maxHeight } : null);

	const handleExpandingResize = (height: number) => {
		height = height;
	};

	const inputClassName = $derived(
		classNames(
			styles.Input,
			align && styles[variationName('Input-align', align)],
			suffix && styles['Input-suffixed'],
			clearButton && styles['Input-hasClearButton'],
			monospaced && styles.monospaced,
			suggestion && styles.suggestion,
			autoSize && styles['Input-autoSize']
		)
	);

	const handleOnFocus = (event: FocusEvent | MouseEvent) => {
		focus = true;
		if (selectTextOnFocus && !suggestion) {
			const input = getInputRef();
			input?.select();
		}

		if (onFocus) {
			onFocus(event as FocusEvent);
		}
	};

	function handleOnWheel(event: WheelEvent) {
		if (document.activeElement === event.target && isNumericType) {
			event.stopPropagation();
		}
	}

	function handleOnBlur(event: FocusEvent) {
		focus = false;

		// Return early if new focus target is inside the TextField component
		if (textFieldRef?.contains(event.relatedTarget as Node)) {
			return;
		}

		if (onBlur) {
			onBlur(event);
		}
	}

	function isInput(target: HTMLElement | EventTarget) {
		const input = getInputRef();
		return (
			target instanceof HTMLElement &&
			input &&
			(input.contains(target) || input.contains(document.activeElement))
		);
	}

	function isPrefixOrSuffix(target: Element | EventTarget) {
		return (
			target instanceof Element &&
			((prefixRef && prefixRef.contains(target)) || (suffixRef && suffixRef.contains(target)))
		);
	}

	function isSpinner(target: Element | EventTarget) {
		return target instanceof Element && spinnerRef && spinnerRef.contains(target);
	}

	function isLoadingSpinner(target: Element | EventTarget) {
		return target instanceof Element && loadingRef && loadingRef.contains(target);
	}

	function isVerticalContent(target: Element | EventTarget) {
		return (
			target instanceof Element &&
			verticalContentRef &&
			(verticalContentRef.contains(target) || verticalContentRef.contains(document.activeElement))
		);
	}

	function getRows(multiline?: boolean | number) {
		if (!multiline) return undefined;

		return typeof multiline === 'number' ? multiline : 1;
	}

	function normalizeAriaMultiline(multiline?: boolean | number) {
		if (!multiline) return undefined;

		return Boolean(multiline) || (typeof multiline === 'number' && multiline > 0)
			? { 'aria-multiline': true }
			: undefined;
	}

	function handleClickChild(event: MouseEvent) {
		if (!isSpinner(event.target as Element) && !isInput(event.target as Element)) {
			event.stopPropagation();
		}

		if (
			isPrefixOrSuffix(event.target as Element) ||
			isVerticalContent(event.target as Element) ||
			isInput(event.target as Element) ||
			isLoadingSpinner(event.target as Element) ||
			focus
		) {
			return;
		}

		focus = true;
		getInputRef()?.focus();
	}

	function handleClick(event: MouseEvent) {
		const { target } = event;

		// For TextFields used with Combobox, focus needs to be set again even
		// if the TextField is already focused to trigger the logic to open the
		// Combobox activator
		const inputRefRole = inputRef?.getAttribute('role');
		if (target === inputRef && inputRefRole === 'combobox') {
			inputRef?.focus();
			handleOnFocus(event);
			return;
		}

		if (
			isPrefixOrSuffix(target as Element) ||
			isVerticalContent(target as Element) ||
			isInput(target as Element) ||
			isSpinner(target as Element) ||
			isLoadingSpinner(target as Element) ||
			focus
		) {
			return;
		}

		getInputRef()?.focus();
	}

	function handleKeyPress(event: KeyboardEvent) {
		const { key, which } = event;
		const numbersSpec = /[\d.,eE+-]$/;
		const integerSpec = /[\deE+-]$/;

		if (
			!isNumericType ||
			which === Key.Enter ||
			(type === 'number' && numbersSpec.test(key)) ||
			(type === 'integer' && integerSpec.test(key))
		) {
			return;
		}

		event.preventDefault();
	}

	function handleKeyDown(event: KeyboardEvent) {
		if (!isNumericType) {
			return;
		}

		const { key, which } = event;

		if (type === 'integer' && (key === 'ArrowUp' || which === Key.UpArrow)) {
			handleNumberChange(1);
			event.preventDefault();
		}
		if (type === 'integer' && (key === 'ArrowDown' || which === Key.DownArrow)) {
			handleNumberChange(-1);
			event.preventDefault();
		}

		if ((which === Key.Home || key === 'Home') && min !== undefined) {
			if (onSpinnerChange != null) {
				onSpinnerChange(String(min), id);
			} else if (onChange != null) {
				onChange(String(min), id);
			}
		}

		if ((which === Key.End || key === 'End') && max !== undefined) {
			if (onSpinnerChange != null) {
				onSpinnerChange(String(max), id);
			} else if (onChange != null) {
				onChange(String(max), id);
			}
		}

		if ((which === Key.PageUp || key === 'PageUp') && largeStep !== undefined) {
			handleNumberChange(1, largeStep);
		}

		if ((which === Key.PageDown || key === 'PageDown') && largeStep !== undefined) {
			handleNumberChange(-1, largeStep);
		}
	}

	function handleChange(event: Event) {
		if(inputRef && suggestion){
			inputRef.value = suggestion;
			inputRef.setSelectionRange(value.length, suggestion.length);
		}
		onChange && onChange((event.target as HTMLInputElement).value, id);
	}

	const inputProps = $derived.by(() => {
		const props: Record<string, any> = {
			name,
			id,
			disabled,
			readOnly,
			role,
			autoFocus,
			multiline,
			value: normalizedValue,
			placeholder,
			style,
			autoComplete,
			className: inputClassName,
			min,
			max,
			step,
			minLength,
			maxLength,
			spellCheck,
			pattern,
			inputMode,
			type: inputType,
			size: autoSize ? 1 : undefined,
			'aria-describedby': describedBy.length ? describedBy.join(' ') : undefined,
			'aria-labelledby': labelledBy.join(' '),
			'aria-invalid': Boolean(error),
			'aria-owns': ariaOwns,
			'aria-activedescendant': ariaActiveDescendant,
			'aria-autocomplete': ariaAutocomplete,
			'aria-controls': ariaControls,
			'aria-expanded': ariaExpanded,
			'aria-required': requiredIndicator,
			...normalizeAriaMultiline(multiline),
			onfocus: handleOnFocus,
			onblur: handleOnBlur,
			onclick: handleClickChild,
			onkeypress: handleKeyPress,
			onkeydown: handleKeyDown,
			onchange: !suggestion ? handleChange : undefined,
			oninput: suggestion ? handleChange : undefined,
			// 1Password disable data attribute
			'data-1p-ignore': autoComplete === 'off' || undefined,
			// LastPass disable data attribute
			'data-lpignore': autoComplete === 'off' || undefined,
			// Dashlane disable data attribute
			'data-form-type': autoComplete === 'off' ? 'other' : undefined
		};
		
		if (!multiline) {
			props.type = inputType;
			props.size = autoSize ? 1 : undefined;
		} else {
			props.rows = getRows(multiline);
		}

		return props;
	});

	const characterCount = $derived(normalizedValue.length);
	const characterCountLabel = $derived(maxLength
		? `${characterCount} of ${maxLength} characters used`
		: `${characterCount} characters`);
	const characterCountText = $derived(!maxLength ? characterCount : `${characterCount}/${maxLength}`);
	const clearButtonVisible = $derived(normalizedValue !== '');
</script>

{#snippet prefixMarkup()}
	{#if prefix}
		<div
			class={classNames(styles.Prefix, styles.PrefixIcon)}
			id={`${id}-Prefix`}
			bind:this={prefixRef}>
			{#if  typeof prefix === "string"}
				<Text as="span" variant="bodyMd">
					{prefix}
				</Text>
			{:else}
				{@render prefix()}
			{/if}
		</div>
	{/if}
{/snippet}

{#snippet suffixMarkup()}
	{#if suffix}
		<div class={styles.Suffix} id={`${id}-Suffix`} bind:this={suffixRef}>
			{#if typeof suffix === "string"}
				<Text as="span" variant="bodyMd">
					{suffix}
				</Text>
			{:else}
				{@render suffix()}
			{/if}
		</div>
	{/if}
{/snippet}

{#snippet loadingMarkup()}
	{#if loading}
		<div class={styles.Loading} id={`${id}-Loading`} bind:this={loadingRef}>
			<LoadingSpinner size="small" />
		</div>
	{/if}
{/snippet}

{#snippet characterCountMarkup()}
	{#if showCharacterCount}
		<div
			id={`${id}-CharacterCounter`}
			class={characterCountClassName}
			aria-label={characterCountLabel}
			aria-live={focus ? 'polite' : 'off'}
			aria-atomic="true"
		>
			<Text as="span" variant="bodyMd">
				{characterCountText}
			</Text>
		</div>
	{/if}
{/snippet}

{#snippet clearButtonMarkup()}
	{#if clearButton && clearButtonVisible}
		<button type="button" class={styles.ClearButton} onclick={handleClearButtonPress} {disabled}>
			<Text as="span" visuallyHidden>Clear</Text>
			<Icon source={XCircleIcon} tone="base" />
		</button>
	{/if}
{/snippet}

{#snippet spinnerMarkup()}
	{#if isNumericType && step !== 0 && !disabled && !readOnly}
		<Spinner 
			onClick={handleClickChild}
			onChange={handleNumberChange}
			onMouseDown={handleSpinnerButtonPress}
			onMouseUp={handleSpinnerButtonRelease}
			ref={spinnerRef}
			onBlur={handleOnBlur}
		/>
	{/if}
{/snippet}

{#snippet resizerMarkup()}
	{#if multiline && browser}
		<TextFieldResizer
			contents={normalizedValue || placeholder}
			currentHeight={height}
			minimumLines={typeof multiline === 'number' ? multiline : 1}
			onHeightChange={handleExpandingResize}
		/>
	{/if}
{/snippet}

{#snippet inputWithVerticalContentMarkup()}
	{#if verticalContent}
		<!-- svelte-ignore a11y_no_static_element_interactions -->
		<!-- svelte-ignore a11y_click_events_have_key_events -->
		<div
			class={styles.VerticalContent}
			id={`${id}-VerticalContent`}
			bind:this={verticalContentRef}
			onclick={handleClickChild}
		>
			{@render verticalContent()}
			<CreateElement bind:elementRef={inputRef} bind:value {...inputProps} />
		</div>
	{/if}
{/snippet}

{#snippet inputMarkup()}
	{#if verticalContent}
		{@render inputWithVerticalContentMarkup()}
	{:else}
		<CreateElement bind:elementRef={inputRef} bind:value {...inputProps} />
	{/if}
{/snippet}

{#snippet backdropMarkup()}
	<div
		class={classNames(
			styles.Backdrop,
			connectedLeft && styles['Backdrop-connectedLeft'],
			connectedRight && styles['Backdrop-connectedRight']
		)}
	></div>
{/snippet}

{#snippet inputAndSuffixMarkup()}
	{#if autoSize}
		<div class={styles.InputAndSuffixWrapper}>
			<div
				class={classNames(styles.AutoSizeWrapper, suffix && styles.AutoSizeWrapperWithSuffix)}
				data-auto-size-value={value || placeholder}
			>
				{@render inputMarkup()}
			</div>
			{@render suffixMarkup()}
		</div>
	{:else}
		{@render inputMarkup()}
		{@render suffixMarkup()}
	{/if}
{/snippet}

<Labelled
	{label}
	{id}
	{error}
	action={labelAction}
	{labelHidden}
	{helpText}
	{requiredIndicator}
	{disabled}
	{readOnly}
>
	<Connected left={connectedLeft} right={connectedRight}>
		<!--  svelte-ignore a11y_no_static_element_interactions -->
		<!--  svelte-ignore a11y_click_events_have_key_events -->
		<div class={className} onclick={handleClick} bind:this={textFieldRef}>
			{@render prefixMarkup()}
			{@render inputAndSuffixMarkup()}
			{@render characterCountMarkup()}
			{@render loadingMarkup()}
			{@render clearButtonMarkup()}
			{@render spinnerMarkup()}
			{@render backdropMarkup()}
			{@render resizerMarkup()}
		</div>
	</Connected>
</Labelled>

```

# components/text-field/types.ts

```ts
import type { Snippet } from "svelte";
import type { LabelledProps } from "../labelled/types.js";
import type { Error } from "$utilities/types.js";

export interface ResizerProps {
    contents?: string;
    currentHeight?: number | null;
    minimumLines?: number;
    onHeightChange(height: number): void;
}

export type HandleStepFn = (step: number) => void;

export interface SpinnerProps {
    onChange: HandleStepFn;
    onClick?(event: MouseEvent): void;
    onMouseDown(onChange: HandleStepFn): void;
    onMouseUp(): void;
    onBlur(event: FocusEvent): void;
    ref?: HTMLDivElement;
}

type Type =
  | 'text'
  | 'email'
  | 'number'
  | 'integer'
  | 'password'
  | 'search'
  | 'tel'
  | 'url'
  | 'date'
  | 'datetime-local'
  | 'month'
  | 'time'
  | 'week'
  | 'currency';

type Alignment = 'left' | 'center' | 'right';

type InputMode =
  | 'none'
  | 'text'
  | 'decimal'
  | 'numeric'
  | 'tel'
  | 'search'
  | 'email'
  | 'url';

export interface SelectSuggestion {
  suggestion?: string;
}

export interface SelectTextOnFocus {
  selectTextOnFocus?: true;
}

export interface Readonly {
  readonly?: true;
}

export interface Disabled {
  disabled?: true;
}

export interface Interactive {
  onChange(value: string, id: string): void;
}

export interface NonMutuallyExclusiveProps {
  /** Text to display before value */
  prefix?: Snippet | string;
  /** Text to display after value */
  suffix?: Snippet | string;
  /** Content to vertically display above the input value */
  verticalContent?: Snippet;
  /** Hint text to display */
  placeholder?: string;
  /** Initial value for the input */
  value?: string;
  /** Additional hint text to display */
  helpText?: string|Snippet;
  /** Label for the input */
  label: string;
  /** Adds an action to the label */
  labelAction?: LabelledProps['action'];
  /** Visually hide the label */
  labelHidden?: boolean;
  /** Disable the input */
  disabled?: boolean;
  /** Show a clear text button in the input */
  clearButton?: boolean;
  /** Indicates whether or not the entire value should be selected on focus. */
  selectTextOnFocus?: boolean;
  /** An inline autocomplete suggestion containing the input value. The characters that complete the input value are selected for ease of deletion on input change or keypress of Backspace/Delete. The selected substring is visually highlighted with subdued styling. */
  suggestion?: string;
  /** Disable editing of the input */
  readOnly?: boolean;
  /** Automatically focus the input */
  autoFocus?: boolean;
  /** Force the focus state on the input */
  focused?: boolean;
  /** Allow for multiple lines of input */
  multiline?: boolean | number;
  /** Error to display beneath the label */
  error?: Error | boolean;
  /** An element connected to the right of the input */
  connectedRight?: Snippet;
  /** An element connected to the left of the input */
  connectedLeft?: Snippet;
  /** Determine type of input */
  type?: Type;
  /** Name of the input */
  name?: string;
  /** ID for the input */
  id?: string;
  /** Defines a specific role attribute for the input */
  role?: string;
  /** Limit increment value for numeric and date-time inputs */
  step?: number;
  /** Increment value for numeric and date-time inputs when using Page Up or Page Down */
  largeStep?: number;
  /** Enable automatic completion by the browser. Set to "off" when you do not want the browser to fill in info */
  autoComplete: string;
  /** Mimics the behavior of the native HTML attribute, limiting the maximum value */
  max?: number | string;
  /** Maximum character length for an input */
  maxLength?: number;
  /** Maximum height of the input element. Only applies when `multiline` is `true` */
  maxHeight?: number | string;
  /** Mimics the behavior of the native HTML attribute, limiting the minimum value */
  min?: number | string;
  /** Minimum character length for an input */
  minLength?: number;
  /** A regular expression to check the value against */
  pattern?: string;
  /** Choose the keyboard that should be used on mobile devices */
  inputMode?: InputMode;
  /** Indicate whether value should have spelling checked */
  spellCheck?: boolean;
  /** Indicates the id of a component owned by the input */
  ariaOwns?: string;
  /** Indicates whether or not a Popover is displayed */
  ariaExpanded?: boolean;
  /** Indicates the id of a component controlled by the input */
  ariaControls?: string;
  /** Indicates the id of a related componentâ€™s visually focused element to the input */
  ariaActiveDescendant?: string;
  /** Indicates what kind of user input completion suggestions are provided */
  ariaAutocomplete?: string;
  /** Indicates whether or not the character count should be displayed */
  showCharacterCount?: boolean;
  /** Determines the alignment of the text in the input */
  align?: Alignment;
  /** Visual required indicator, adds an asterisk to label */
  requiredIndicator?: boolean;
  /** Indicates whether or not a monospaced font should be used */
  monospaced?: boolean;
  /** Visual styling options for the TextField
   * @default 'inherit'
   */
  variant?: 'inherit' | 'borderless';
  /**
   * Changes the size of the input, giving it more or less padding
   * @default 'medium'
   */
  size?: 'slim' | 'medium';
  /** Callback fired when clear button is clicked */
  onClearButtonClick?(id: string): void;
  /** Callback fired when value is changed */
  onChange?(value: string, id: string): void;
  /** When provided, callback fired instead of onChange when value is changed via the number step control  */
  onSpinnerChange?(value: string, id: string): void;
  /** Callback fired when input is focused */
  onFocus?: (event?: FocusEvent) => void;
  /** Callback fired when input is blurred */
  onBlur?(event?: FocusEvent): void;
  /** Indicates the tone of the text field */
  tone?: 'magic';
  /** Whether the TextField will grow as the text within the input changes */
  autoSize?: boolean;
  /** Indicates the loading state */
  loading?: boolean;
}

export type MutuallyExclusiveSelectionProps =
  | SelectSuggestion
  | SelectTextOnFocus;

export type MutuallyExclusiveInteractionProps =
  | Interactive
  | Readonly
  | Disabled;

export type TextFieldProps = NonMutuallyExclusiveProps &
  MutuallyExclusiveInteractionProps &
  MutuallyExclusiveSelectionProps;
```

# components/text/index.ts

```ts

```

# components/text/text.module.css

```css
.root {
    margin: 0;
    text-align: inherit;
}

.block {
    display: block;
}

.truncate {
    overflow: hidden;
    white-space: nowrap;
    text-overflow: ellipsis;
}

.visuallyHidden {
    @mixin visually-hidden;
}

.start {
    text-align: start;
}

.center {
    text-align: center;
}

.end {
    text-align: end;
}

.justify {
    text-align: justify;
}

.base {
    color: var(--p-color-text);
}

.inherit {
    color: inherit;
}

.disabled {
    color: var(--p-color-text-disabled);
}

.success {
    color: var(--p-color-text-success);
}

.critical {
    color: var(--p-color-text-critical);
}

.caution {
    color: var(--p-color-text-caution);
}

.subdued {
    color: var(--p-color-text-secondary);
}

.magic {
    color: var(--p-color-text-magic);
}

.magic-subdued {
    color: var(--p-color-text-magic-secondary);
}

.text-inverse {
    color: var(--p-color-text-inverse);
}

.text-inverse-secondary {
    color: var(--p-color-text-inverse-secondary);
}

.headingXs {
    font-size: var(--p-text-heading-xs-font-size);
    font-weight: var(--p-text-heading-xs-font-weight);
    letter-spacing: var(--p-text-heading-xs-font-letter-spacing);
    line-height: var(--p-text-heading-xs-font-line-height);
}

.headingSm {
    font-size: var(--p-text-heading-sm-font-size);
    font-weight: var(--p-text-heading-sm-font-weight);
    letter-spacing: var(--p-text-heading-sm-font-letter-spacing);
    line-height: var(--p-text-heading-sm-font-line-height);
}

.headingMd {
    font-size: var(--p-text-heading-md-font-size);
    font-weight: var(--p-text-heading-md-font-weight);
    letter-spacing: var(--p-text-heading-md-font-letter-spacing);
    line-height: var(--p-text-heading-md-font-line-height);
}

.headingLg {
    font-size: var(--p-text-heading-lg-font-size);
    font-weight: var(--p-text-heading-lg-font-weight);
    letter-spacing: var(--p-text-heading-lg-font-letter-spacing);
    line-height: var(--p-text-heading-lg-font-line-height);
}

.headingXl {
    font-size: var(--p-font-size-500);
    font-weight: var(--p-font-weight-semibold);
    letter-spacing: var(--p-font-letter-spacing-dense);
    line-height: var(--p-font-line-height-600);

    @media (--p-breakpoints-md-up) {
        font-size: var(--p-text-heading-xl-font-size);
        font-weight: var(--p-text-heading-xl-font-weight);
        letter-spacing: var(--p-text-heading-xl-font-letter-spacing);
        line-height: var(--p-text-heading-xl-font-line-height);
    }
}

.heading2xl {
    font-size: var(--p-font-size-600);
    font-weight: var(--p-font-weight-bold);
    letter-spacing: var(--p-font-letter-spacing-dense);
    line-height: var(--p-font-line-height-800);

    @media (--p-breakpoints-md-up) {
        font-size: var(--p-text-heading-2xl-font-size);
        font-weight: var(--p-text-heading-2xl-font-weight);
        letter-spacing: var(--p-text-heading-2xl-font-letter-spacing);
        line-height: var(--p-text-heading-2xl-font-line-height);
    }
}

.heading3xl {
    font-size: var(--p-font-size-750);
    font-weight: var(--p-font-weight-bold);
    letter-spacing: var(--p-font-letter-spacing-denser);
    line-height: var(--p-font-line-height-1000);

    @media (--p-breakpoints-md-up) {
        font-size: var(--p-text-heading-3xl-font-size);
        font-weight: var(--p-text-heading-3xl-font-weight);
        letter-spacing: var(--p-text-heading-3xl-font-letter-spacing);
        line-height: var(--p-text-heading-3xl-font-line-height);
    }
}

.bodyXs {
    font-size: var(--p-text-body-xs-font-size);
    font-weight: var(--p-text-body-xs-font-weight);
    letter-spacing: var(--p-text-body-xs-font-letter-spacing);
    line-height: var(--p-text-body-xs-font-line-height);
}

.bodySm {
    font-size: var(--p-text-body-sm-font-size);
    font-weight: var(--p-text-body-sm-font-weight);
    letter-spacing: var(--p-text-body-sm-font-letter-spacing);
    line-height: var(--p-text-body-sm-font-line-height);
}

.bodyMd {
    font-size: var(--p-text-body-md-font-size);
    font-weight: var(--p-text-body-sm-font-weight);
    letter-spacing: var(--p-text-body-md-font-letter-spacing);
    line-height: var(--p-text-body-md-font-line-height);
}

.bodyLg {
    font-size: var(--p-text-body-lg-font-size);
    font-weight: var(--p-text-body-sm-font-weight);
    letter-spacing: var(--p-text-body-lg-font-letter-spacing);
    line-height: var(--p-text-body-lg-font-line-height);
}

/* font-weight must be below variant styles so
     it can override the styles when necessary. */
.regular {
    font-weight: var(--p-font-weight-regular);
}

.medium {
    font-weight: var(--p-font-weight-medium);
}

.semibold {
    font-weight: var(--p-font-weight-semibold);
}

.bold {
    font-weight: var(--p-font-weight-bold);
}

.break {
    overflow-wrap: anywhere;
    word-break: normal;
}

.numeric {
    font-variant-numeric: tabular-nums lining-nums;
}

.line-through {
    text-decoration-line: line-through;
}
```

# components/text/text.svelte

```svelte
<script lang="ts">
	import { classNames } from '../../utilities/css.js';
	import styles from './text.module.css';
	import type { TextProps } from './types.js';
	let {
		alignment,
		as,
		breakWord,
		children,
		tone,
		fontWeight,
		id,
		numeric = false,
		truncate = false,
		variant,
		visuallyHidden = false,
		textDecorationLine
	}: TextProps = $props();

	const className = $derived(
		classNames(
			styles.root,
			variant && styles[variant],
			fontWeight && styles[fontWeight],
			(alignment || truncate) && styles.block,
			alignment && styles[alignment],
			breakWord && styles.break,
			tone && styles[tone],
			numeric && styles.numeric,
			truncate && styles.truncate,
			visuallyHidden && styles.visuallyHidden,
			textDecorationLine && styles[textDecorationLine]
		)
	);

    const Component = $derived(as || (visuallyHidden ? 'span' : 'p'));
</script>

<svelte:element this={Component} class={className} {...id && { id }}>
	{@render children?.()}
</svelte:element>

```

# components/text/types.ts

```ts
import type { Snippet } from "svelte";

type Element =
    | 'dt'
    | 'dd'
    | 'h1'
    | 'h2'
    | 'h3'
    | 'h4'
    | 'h5'
    | 'h6'
    | 'p'
    | 'span'
    | 'strong'
    | 'legend';

type Variant =
    | 'headingXs'
    | 'headingSm'
    | 'headingMd'
    | 'headingLg'
    | 'headingXl'
    | 'heading2xl'
    | 'heading3xl'
    | 'bodyXs'
    | 'bodySm'
    | 'bodyMd'
    | 'bodyLg';

type Alignment = 'start' | 'center' | 'end' | 'justify';

type FontWeight = 'regular' | 'medium' | 'semibold' | 'bold';

type Tone =
    | 'base'
    | 'disabled'
    | 'inherit'
    | 'success'
    | 'critical'
    | 'caution'
    | 'subdued'
    | 'text-inverse'
    | 'text-inverse-secondary'
    | 'magic'
    | 'magic-subdued';

type TextDecorationLine = 'line-through';

const deprecatedVariants: { [V in Variant]?: Variant } = {
    heading3xl: 'heading2xl',
};
export interface TextProps {
    /** Adjust horizontal alignment of text */
    alignment?: Alignment;
    /** The element type */
    as: Element;
    /** Prevent text from overflowing */
    breakWord?: boolean;
    /** Text to display */
    children: Snippet;
    /** Adjust tone of text */
    tone?: Tone;
    /** Adjust weight of text */
    fontWeight?: FontWeight;
    /** HTML id attribute */
    id?: string;
    /** Use a numeric font variant with monospace appearance */
    numeric?: boolean;
    /** Truncate text overflow with ellipsis */
    truncate?: boolean;
    /** Typographic style of text */
    variant?: Variant;
    /** Visually hide the text */
    visuallyHidden?: boolean;
    /** Add a line-through to the text */
    textDecorationLine?: TextDecorationLine;
}
```

# components/theme-provider/theme-provider.module.css

```css
.themeContainer {
  color: var(--p-color-text);
}
```

# components/theme-provider/theme-provider.svelte

```svelte
<script lang="ts">
	import { createThemeClassName, themeNameDefault } from '@shopify/polaris-tokens';
	import styles from './theme-provider.module.css';
	import type { ThemeProviderProps } from './types.js';
	import { classNames } from '$utilities/css.js';
	import ThemeNameContextProvider from '../app-provider/theme-name-context-provider.svelte';
	import ThemeContextProvider from '../app-provider/theme-context-provider.svelte';
	import { getTheme } from './types.js';
	let {
		as: ThemeContainer = 'div',
		children,
		className,
		theme: themeName = themeNameDefault,
		...restProps
	}: ThemeProviderProps = $props();
</script>

<ThemeNameContextProvider value={themeName}>
	<ThemeContextProvider value={getTheme(themeName)}>
		<svelte:element
			this={ThemeContainer}
			data-portal-id={restProps['data-portal-id']}
			class={classNames(createThemeClassName(themeName), styles.themeContainer, className)}
		>
			{@render children?.()}
		</svelte:element>
	</ThemeContextProvider>
</ThemeNameContextProvider>

```

# components/theme-provider/types.ts

```ts
import { themes, type Theme, type ThemeName } from "@shopify/polaris-tokens";
import type { Snippet } from "svelte";

export const themeNamesLocal = ['light', 'dark-experimental'] as const;

export type ThemeNameLocal = (typeof themeNamesLocal)[number];

export const isThemeNameLocal = (name: string): name is ThemeNameLocal => themeNamesLocal.includes(name as any);

export interface ThemeProviderProps {
    as?: keyof HTMLElementTagNameMap;
    children: Snippet;
    className?: string;
    theme?: ThemeNameLocal;
    'data-portal-id'?: string;
}

export function getTheme(themeName: ThemeName): Theme {
    return themes[themeName];
}

```

# components/thumbnail/thumbnail.module.css

```css
.Thumbnail {
  /* stylelint-disable -- Polaris component custom properties */
  --pc-thumbnail-extra-small-size: 24px;
  --pc-thumbnail-small-size: 40px;
  --pc-thumbnail-medium-size: 60px;
  --pc-thumbnail-large-size: 80px;
  /* stylelint-enable */
  position: relative;
  display: block;
  overflow: hidden;
  background: var(--p-color-bg-surface);
  /* stylelint-disable-next-line -- generated by polaris-migrator DO NOT COPY */
  min-width: var(--pc-thumbnail-extra-small-size);
  max-width: 100%;
  border-radius: var(--p-border-radius-200);

  &::after {
    content: '';
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    position: absolute;
    border-radius: var(--p-border-radius-200);
    box-shadow: var(--p-shadow-border-inset);
    display: block;
    /* stylelint-disable-next-line -- generated by polaris-migrator DO NOT COPY */
    padding-bottom: 100%;
  }

  &.sizeExtraSmall,
  &.sizeExtraSmall::after {
    border-radius: var(--p-border-radius-150);
  }

  &::before {
    content: '';
    display: block;
    /* stylelint-disable-next-line -- set padding */
    padding-bottom: 100%;
  }
}

.sizeExtraSmall {
  /* stylelint-disable-next-line -- generated by polaris-migrator DO NOT COPY */
  width: var(--pc-thumbnail-extra-small-size);
}

.sizeSmall {
  /* stylelint-disable-next-line -- generated by polaris-migrator DO NOT COPY */
  width: var(--pc-thumbnail-small-size);
}

.sizeMedium {
  /* stylelint-disable-next-line -- generated by polaris-migrator DO NOT COPY */
  width: var(--pc-thumbnail-medium-size);
}

.sizeLarge {
  /* stylelint-disable-next-line -- generated by polaris-migrator DO NOT COPY */
  width: var(--pc-thumbnail-large-size);
}

.transparent {
  background: transparent;
}

.Thumbnail>* {
  position: absolute;
  top: 0;
  right: 0;
  bottom: 0;
  left: 0;
  margin: auto;
  max-width: 100%;
  max-height: 100%;
  color: var(--p-color-icon-secondary);

  /* stylelint-disable-next-line -- generated by polaris-migrator DO NOT COPY */
  svg {
    fill: currentColor;
  }
}
```

# components/thumbnail/thumbnail.svelte

```svelte
<script lang="ts">
	import styles from './thumbnail.module.css';
	import type { ThumbnailProps } from './types.js';
	import { classNames } from '$utilities/css.js';
	import { variationName } from '$utilities/css.js';
	import Image from '$lib/components/image/image.svelte';
	import Icon from '../icon/icon.svelte';
	let { source, alt, size = 'medium', transparent }: ThumbnailProps = $props();

	const className = $derived(
		classNames(
			styles.Thumbnail,
			size && styles[variationName('size', size)],
			transparent && styles.transparent
		)
	);
</script>

<span class={className}>
	{#if typeof source === 'string'}
		<Image {alt} {source} />
	{:else}
		<Icon accessibilityLabel={alt} {source} />
	{/if}
</span>

```

# components/thumbnail/types.ts

```ts
import type { Component } from "svelte";

export type Size = 'extraSmall' | 'small' | 'medium' | 'large';

export interface ThumbnailProps {
  /**
   * Size of thumbnail
   * @default 'medium'
   */
  size?: Size;
  /** URL for the image */
  source: string | Component;
  /** Alt text for the thumbnail image */
  alt: string;
  /** Transparent background */
  transparent?: boolean;
}
```

# components/tooltip/components/tooltip-overlay/tooltip-overlay.module.css

```css
.TooltipOverlay {
    @mixin scope-custom-property tooltip, chevron-x-pos;
    @mixin scope-custom-property tooltip, border-radius;
    @mixin scope-custom-property tooltip, padding;

    /* stylelint-disable -- Polaris component custom properties */
    --pc-tooltip-overlay-offset: var(--p-space-300);
    --pc-tooltip-shadow-bevel-z-index: 1;
    --pc-tooltip-tail-z-index: calc(var(--pc-tooltip-shadow-bevel-z-index) + 1);
    /* stylelint-enable */
    position: relative;
    /* stylelint-disable-next-line -- generated by polaris-migrator DO NOT COPY */
    margin: var(--pc-tooltip-overlay-offset) var(--p-space-100) var(--p-space-100);
    opacity: 1;
    box-shadow: var(--p-shadow-400);
    /* stylelint-disable-next-line -- Polaris component custom properties */
    border-radius: var(--pc-tooltip-border-radius);
    pointer-events: none;
    will-change: opacity, left, top, transform;
    transform: none;
    transition: none;
    min-width: 4ch;

    @mixin shadow-bevel var(--p-shadow-300), var(--pc-tooltip-border-radius), null,
    '', var(--pc-tooltip-shadow-bevel-z-index);

    @media screen and (-ms-high-contrast: active) {
        border: var(--p-border-width-050) solid windowText;
    }

    /* TailUp */
    .Tail {
        position: absolute;
        top: calc(-1 * var(--p-space-200) + 0.8px);
        /* stylelint-disable-next-line -- Custom positioning not expected to align with Polaris tokens */
        left: calc(var(--pc-tooltip-chevron-x-pos) - var(--p-space-150) - var(--p-space-400));
        /* stylelint-disable-next-line -- set z-index */
        z-index: var(--pc-tooltip-tail-z-index);
    }

    &.positionedAbove {
        &::after {
            top: auto;
            bottom: calc(var(--p-space-400) * -1);
            border-color: var(--p-color-bg-surface) transparent transparent transparent;
        }

        /* TailDown */
        /* stylelint-disable-next-line -- TailDown styles */
        .Tail {
            top: unset;
            bottom: calc(-1 * var(--p-space-200));
            /* stylelint-disable-next-line -- set filter styles */
            filter: drop-shadow(0 3px 2px rgba(26, 26, 26, 0.1));
        }
    }
}

.measuring {
    opacity: 0;
}

.measured:not(.instant) {
    animation: var(--p-motion-keyframes-appear-below) var(--p-motion-duration-50) var(--p-motion-ease-out) var(--p-motion-duration-100) 1 both;

    @media (prefers-reduced-motion) {
        animation: none;
    }
}

.measured.positionedAbove:not(.instant) {
    animation: var(--p-motion-keyframes-appear-above) var(--p-motion-duration-50) var(--p-motion-ease-out) var(--p-motion-duration-100) 1 both;

    @media (prefers-reduced-motion) {
        animation: none;
    }
}

.positionedAbove {
    /* stylelint-disable-next-line -- generated by polaris-migrator DO NOT COPY */
    margin: var(--p-space-100) var(--p-space-100) var(--pc-tooltip-overlay-offset);
}

.Content {
    position: relative;
    background-color: var(--p-color-bg-surface);
    color: var(--p-color-text);
    word-break: break-word;
    /* stylelint-disable-next-line -- Polaris component custom properties */
    border-radius: var(--pc-tooltip-border-radius);
    /* stylelint-disable-next-line -- Polaris component custom properties */
    padding: var(--pc-tooltip-padding);
}

/* Width of Content */
.default {
    max-width: 200px;
}

.wide {
    max-width: 275px;
}

[data-polaris-tooltip-activator] {
    outline: 0;
    /* stylelint-disable-next-line -- generated by polaris-migrator DO NOT COPY */
    @mixin focus-ring base, 0, base;

    &:focus-visible {
        /* stylelint-disable-next-line -- generated by polaris-migrator DO NOT COPY */
        @mixin focus-ring base, 0, focused;
    }
}
```

# components/tooltip/components/tooltip-overlay/tooltip-overlay.svelte

```svelte
<script lang="ts">
	import PositionedOverlay from '$lib/components/positioned-overlay/positioned-overlay.svelte';
	import type { OverlayDetails } from '$lib/components/positioned-overlay/types.js';
	import { applyStyles, classNames } from '$utilities/css.js';
	import { Rect } from '$utilities/geometry.js';
	import { layer } from '$utilities/shared.js';
	import styles from './tooltip-overlay.module.css';
	import type { TooltipOverlayProps } from './types.js';
	let {
		active,
		activator,
		preferredPosition = 'above',
		preventInteraction,
		id,
		children,
		accessibilityLabel,
		width,
		padding,
		borderRadius,
		zIndexOverride,
		instant
	}: TooltipOverlayProps = $props();

	let overlayDetails = $state<OverlayDetails>({
		activatorRect: new Rect({}),
		left: undefined,
		right: undefined,
		desiredHeight: 0,
		positioning: 'below',
		measuring: false,
		chevronOffset: 0
	});

	const tooltipContainerClassName = $derived(
		classNames(
			styles.TooltipOverlay,
			overlayDetails.measuring && styles.measuring,
			!overlayDetails.measuring && styles.measured,
			instant && styles.instant,
			overlayDetails.positioning === 'above' && styles.positionedAbove
		)
	);

	const contentClassName = $derived(classNames(styles.Content, width && styles[width]));

	const contentStyles = $derived(
		overlayDetails.measuring ? undefined : { minHeight: overlayDetails.desiredHeight }
	);

	const style = $derived({
		'--pc-tooltip-chevron-x-pos': `${overlayDetails.chevronOffset}px`,
		'--pc-tooltip-border-radius': borderRadius
			? `var(--p-border-radius-${borderRadius})`
			: undefined,
		'--pc-tooltip-padding':
			padding && padding === 'default'
				? 'var(--p-space-100) var(--p-space-200)'
				: `var(--p-space-${padding})`
	});
</script>

{#snippet tailUpPaths()}
	<path
		d="M18.829 8.171 11.862.921A3 3 0 0 0 7.619.838L0 8.171h1.442l6.87-6.612a2 2 0 0 1 2.83.055l6.3 6.557h1.387Z"
		fill="var(--p-color-tooltip-tail-up-border)"
	/>
	<path
		d="M17.442 10.171h-16v-2l6.87-6.612a2 2 0 0 1 2.83.055l6.3 6.557v2Z"
		fill="var(--p-color-bg-surface)"
	/>
{/snippet}

{#snippet tailDownPaths()}
	<path
		d="m0 2 6.967 7.25a3 3 0 0 0 4.243.083L18.829 2h-1.442l-6.87 6.612a2 2 0 0 1-2.83-.055L1.387 2H0Z"
		fill="var(--p-color-tooltip-tail-down-border)"
	/>
	<path
		d="M1.387 0h16v2l-6.87 6.612a2 2 0 0 1-2.83-.055L1.387 2V0Z"
		fill="var(--p-color-bg-surface)"
	/>
{/snippet}

{#snippet tooltipContent()}
	{@const tooltipStyles = { ...style, ...contentStyles }}
	<div style={applyStyles(tooltipStyles)} class={tooltipContainerClassName} {...layer.props}>
		<svg class={styles.Tail} width="19" height="11" fill="none">
            {#if overlayDetails.positioning === 'above'}
                {@render tailDownPaths()}
            {:else}
                {@render tailUpPaths()}
            {/if}
		</svg>
		<div
			{id}
			role="tooltip"
			class={contentClassName}
			style={applyStyles(contentStyles)}
			aria-label={accessibilityLabel ? `Tooltip: ${accessibilityLabel}` : undefined}
		>
			{@render children?.()}
		</div>
	</div>
{/snippet}

{#if active}
	<PositionedOverlay
		bind:overlayDetails
		{active}
		{activator}
		preferredAlignment="center"
		{preferredPosition}
		{preventInteraction}
		{zIndexOverride}>
		{@render tooltipContent?.()}
	</PositionedOverlay>
{/if}

```

# components/tooltip/components/tooltip-overlay/types.ts

```ts
import type { PositionedOverlayProps } from "$lib/components/positioned-overlay/types.js";
import type { Snippet } from "svelte";
import type { BorderRadius, Padding, Width } from "../../types.js";

export interface TooltipOverlayProps {
    id: string;
    active: boolean;
    preventInteraction?: PositionedOverlayProps['preventInteraction'];
    preferredPosition?: PositionedOverlayProps['preferredPosition'];
    children?: Snippet;
    activator?: HTMLElement;
    accessibilityLabel?: string;
    width?: Width;
    padding?: Padding;
    borderRadius?: BorderRadius;
    zIndexOverride?: number;
    onClose(): void;
    instant?: boolean;
}
```

# components/tooltip/tooltip.module.css

```css
.TooltipContainer {
    display: flex;
}

.HasUnderline {
    border-bottom: var(--p-border-width-050) dotted var(--p-color-border);
}
```

# components/tooltip/tooltip.svelte

```svelte
<script lang="ts">
	import { UseToggle } from '$lib/use/use-toggle.svelte.js';
	import { findFirstFocusableNode } from '$utilities/focus.js';
	import { noop } from '$utilities/noop.js';
	import Portal from '../portal/portal.svelte';
	import TooltipOverlay from './components/tooltip-overlay/tooltip-overlay.svelte';
	import styles from './tooltip.module.css';
	import { HOVER_OUT_TIMEOUT, type TooltipProps } from './types.js';
	import Text from '$lib/components/text/text.svelte';
	import { classNames } from '$utilities/css.js';
	import { useContext } from '$utilities/contexts.js';
	import { EPHEMERAL_PRESENCE_MANAGER_CONTEXT_KEY, type EphemeralPresenceManagerContextType } from '../app-provider/types.js';

	let {
		children,
		content,
		dismissOnMouseOut,
		active: originalActive = false,
		hoverDelay,
		preferredPosition = 'above',
		activatorWrapper = 'span',
		accessibilityLabel,
		width = 'default',
		padding = 'default',
		borderRadius: borderRadiusProp,
		zIndexOverride,
		hasUnderline,
		persistOnClick = false,
		onOpen,
		onClose
	}: TooltipProps = $props();

	const borderRadius = $derived(borderRadiusProp || '200');

	const active = new UseToggle(Boolean(originalActive));
	const handleBlur = active.setFalse;
	const setActiveTrue = active.setTrue;

	const persist = new UseToggle(Boolean(originalActive) && Boolean(persistOnClick));
	const togglePersisting = persist.toggle;

	let activatorNode = $state<HTMLDivElement>();
	const useEphemeralPresenceManager = useContext<EphemeralPresenceManagerContextType>(EPHEMERAL_PRESENCE_MANAGER_CONTEXT_KEY)
	const { presenceList, addPresence, removePresence } = $derived(useEphemeralPresenceManager());
	const id = $props.id();
	let activatorContainer = $state<HTMLDivElement>();
	let mouseEntered = $state(false);
	let shouldAnimate = $state(Boolean(!originalActive));
	let hoverDelayTimeout = $state<NodeJS.Timeout | null>(null);
	let hoverOutTimeout = $state<NodeJS.Timeout | null>(null);

	const handleFocus = () => {
		if (originalActive !== false) {
			setActiveTrue();
		}
	};

	const handleOpen = () => {
		shouldAnimate = !presenceList.tooltip && !active.value;
		onOpen?.();
		addPresence('tooltip');
	};

	const handleClose = () => {
		onClose?.();
		shouldAnimate = false;
		hoverOutTimeout = setTimeout(() => {
			removePresence('tooltip');
		}, HOVER_OUT_TIMEOUT);
	};

	const handleKeyUp = (event: KeyboardEvent) => {
		if (event.key !== 'Escape') return;
		handleClose?.();
		handleBlur();
		persistOnClick && togglePersisting();
	};

	function setActivator(node: HTMLElement | null) {
		let activatorContainerRef: any = activatorContainer;
		if (node == null) {
			activatorContainerRef.current = null;
			activatorNode = undefined;
			return;
		}

		if (node.firstElementChild) {
			activatorNode = node.firstElementChild as HTMLDivElement;
		}

		activatorContainerRef = node;
	}

	function handleMouseEnter() {
		mouseEntered = true;
		if (hoverDelay && !presenceList.tooltip) {
			hoverDelayTimeout = setTimeout(() => {
				handleOpen();
				handleFocus();
			}, hoverDelay);
		} else {
			handleOpen();
			handleFocus();
		}
	}

	function handleMouseLeave() {
		if (hoverDelayTimeout) {
			clearTimeout(hoverDelayTimeout);
			hoverDelayTimeout = null;
		}

		mouseEntered = false;
		handleClose();
		if (!persist.value) {
			handleBlur();
		}
	}

	function handleMouseEnterFix() {
		!mouseEntered && handleMouseEnter();
	}

	const firstFocusable = $derived(
		activatorContainer ? findFirstFocusableNode(activatorContainer) : null
	);

	$effect(() => {
		const accessibilityNode = firstFocusable || activatorContainer;
		if (!accessibilityNode) return;

		accessibilityNode.tabIndex = 0;
		accessibilityNode.setAttribute('aria-describedby', id);
		accessibilityNode.setAttribute('data-polaris-tooltip-activator', 'true');

		return () => {
			if (hoverDelayTimeout) {
				clearTimeout(hoverDelayTimeout);
			}
			if (hoverOutTimeout) {
				clearTimeout(hoverOutTimeout);
			}
		};
	});

	$effect(() => {
		if (originalActive === false && active.value) {
			handleClose();
			handleBlur();
		}
	});

	const wrapperClassNames = $derived(
		classNames(
			activatorWrapper === 'div' && styles.TooltipContainer,
			hasUnderline && styles.HasUnderline
		)
	);
</script>

{#snippet portalMarkup()}
	{#if activatorNode}
		<Portal idPrefix="tooltip">
			<TooltipOverlay
				{id}
				{preferredPosition}
				activator={activatorNode}
				active={active.value}
				{accessibilityLabel}
				onClose={noop}
				preventInteraction={dismissOnMouseOut}
				{width}
				{padding}
				{borderRadius}
				{zIndexOverride}
				instant={!shouldAnimate}
			>
				<Text as="span" variant="bodyMd">
					{content}
				</Text>
			</TooltipOverlay>
		</Portal>
	{/if}
{/snippet}

<!-- svelte-ignore a11y_no_static_element_interactions -->
<svelte:element
	this={activatorWrapper}
	class={wrapperClassNames}
	onfocus={() => {
		handleOpen();
		handleFocus();
	}}
	onblur={() => {
		originalActive === false;
		handleClose();
		handleBlur();

		if (persistOnClick) {
			togglePersisting();
		}
	}}
	onmouseleave={handleMouseLeave}
	onmouseover={handleMouseEnterFix}
	onmousedown={persistOnClick ? togglePersisting : undefined}
>
	<div bind:this={activatorContainer} use:setActivator>
		{@render children?.()}
	</div>
	{@render portalMarkup()}
</svelte:element>

```

# components/tooltip/types.ts

```ts
import type { BorderRadiusAliasOrScale, SpaceScale } from "@shopify/polaris-tokens";
import type { TooltipOverlayProps } from "./components/tooltip-overlay/types.js";
import type { Snippet } from "svelte";

export type Width = 'default' | 'wide';
export type Padding = 'default' | Extract<SpaceScale, '400'>;
export type BorderRadius = Extract<BorderRadiusAliasOrScale, '100' | '200'>;

export interface TooltipProps {
    /** The element that will activate to tooltip */
    children?: Snippet;
    /** The content to display within the tooltip */
    content: Snippet | string;
    /** Toggle whether the tooltip is visible */
    active?: boolean;
    /** Delay in milliseconds while hovering over an element before the tooltip is visible */
    hoverDelay?: number;
    /** Dismiss tooltip when not interacting with its children */
    dismissOnMouseOut?: TooltipOverlayProps['preventInteraction'];
    /**
     * The direction the tooltip tries to display
     * @default 'above'
     */
    preferredPosition?: TooltipOverlayProps['preferredPosition'];
    /**
     * The element type to wrap the activator in
     * @default 'span'
     */
    activatorWrapper?: string;
    /** Visually hidden text for screen readers */
    accessibilityLabel?: string;
    /**
     * Width of content
     * @default 'default'
     */
    width?: Width;
    /**
     * Padding of content
     * @default 'default'
     */
    padding?: Padding;
    /**
     * Border radius of the tooltip
     * @default '200'
     */
    borderRadius?: BorderRadius;
    /** Override on the default z-index of 400 */
    zIndexOverride?: number;
    /** Whether to render a dotted underline underneath the tooltip's activator */
    hasUnderline?: boolean;
    /** Whether the tooltip's content remains open after clicking the activator */
    persistOnClick?: boolean;
    /* Callback fired when the tooltip is activated */
    onOpen?(): void;
    /* Callback fired when the tooltip is dismissed */
    onClose?(): void;
  }
  
  export const HOVER_OUT_TIMEOUT = 150;
```

# components/unstyled-link/types.ts

```ts
import type { LinkLikeComponentProps } from "$utilities/link/types.js";

export interface UnstyledLinkProps extends LinkLikeComponentProps {}
```

# components/unstyled-link/unstyled-link.svelte

```svelte
<script lang="ts">
	import { unstyled } from "$utilities/shared.js";
	import type { UnstyledLinkProps } from "./types.js";

	let { external, url, target: targetProp, ref, ...rest }: UnstyledLinkProps = $props();

	let target = $derived(external ? '_blank' : (targetProp ?? undefined));
	const rel = $derived(target === '_blank' ? 'noopener noreferrer' : undefined);
</script>

<a {target} {...rest} href={url} {rel} {...unstyled.props} bind:this={ref}>
</a>

```

# icons/complete-icon.svelte

```svelte
<svg viewBox="0 0 20 20">
	<path
		d="M6 10c0-.93 0-1.395.102-1.776a3 3 0 0 1 2.121-2.122C8.605 6 9.07 6 10 6c.93 0 1.395 0 1.776.102a3 3 0 0 1 2.122 2.122C14 8.605 14 9.07 14 10s0 1.395-.102 1.777a3 3 0 0 1-2.122 2.12C11.395 14 10.93 14 10 14s-1.395 0-1.777-.102a3 3 0 0 1-2.12-2.121C6 11.395 6 10.93 6 10Z"
	/>
</svg>

```

# icons/incomplete-icon.svelte

```svelte
<svg viewBox="0 0 20 20">
	<path
		fillRule="evenodd"
		d="M8.547 12.69c.183.05.443.06 1.453.06s1.27-.01 1.453-.06a1.75 1.75 0 0 0 1.237-1.237c.05-.182.06-.443.06-1.453s-.01-1.27-.06-1.453a1.75 1.75 0 0 0-1.237-1.237c-.182-.05-.443-.06-1.453-.06s-1.27.01-1.453.06A1.75 1.75 0 0 0 7.31 8.547c-.05.183-.06.443-.06 1.453s.01 1.27.06 1.453a1.75 1.75 0 0 0 1.237 1.237ZM6.102 8.224C6 8.605 6 9.07 6 10s0 1.395.102 1.777a3 3 0 0 0 2.122 2.12C8.605 14 9.07 14 10 14s1.395 0 1.777-.102a3 3 0 0 0 2.12-2.121C14 11.395 14 10.93 14 10c0-.93 0-1.395-.102-1.776a3 3 0 0 0-2.121-2.122C11.395 6 10.93 6 10 6c-.93 0-1.395 0-1.776.102a3 3 0 0 0-2.122 2.122Z"
	/>
</svg>

```

# icons/partially-complete-icon.svelte

```svelte
<svg viewBox="0 0 20 20">
	<path fillRule="evenodd" d="m8.888 6.014-.017-.018-.02.02c-.253.013-.45.038-.628.086a3 3 0 0 0-2.12 2.122C6 8.605 6 9.07 6 10s0 1.395.102 1.777a3 3 0 0 0 2.121 2.12C8.605 14 9.07 14 10 14c.93 0 1.395 0 1.776-.102a3 3 0 0 0 2.122-2.121C14 11.395 14 10.93 14 10c0-.93 0-1.395-.102-1.776a3 3 0 0 0-2.122-2.122C11.395 6 10.93 6 10 6c-.475 0-.829 0-1.112.014ZM8.446 7.34a1.75 1.75 0 0 0-1.041.94l4.314 4.315c.443-.2.786-.576.941-1.042L8.446 7.34Zm4.304 2.536L10.124 7.25c.908.001 1.154.013 1.329.06a1.75 1.75 0 0 1 1.237 1.237c.047.175.059.42.06 1.329ZM8.547 12.69c.182.05.442.06 1.453.06h.106L7.25 9.894V10c0 1.01.01 1.27.06 1.453a1.75 1.75 0 0 0 1.237 1.237Z" />
</svg>

```

# index.ts

```ts
import ActionMenu from "./components/action-menu/index.js";
import ActionList from "./components/action-list/index.js";
import type { ActionListProps } from "./components/action-list/types.js";
import AccountConnection from "./components/account-connection/account-connection.svelte";
import type { AccountConnectionProps } from "./components/account-connection/types.js";
import type { ActionMenuProps } from "./components/action-menu/types.js";
import PolarisAppProvider from "./components/polaris-app-provider.svelte";
import AutoComplete from "./components/autocomplete/index.js";
import type { AutocompleteProps } from "./components/autocomplete/types.js";
import Avatar from "./components/avatar/avatar.svelte";
import type { AvatarProps } from "./components/avatar/types.js";
import Badge from "./components/badge/badge.svelte";
import type { BadgeProps } from "./components/badge/types.js";
import Bleed from "./components/bleed/bleed.svelte";
import BlockStack from "./components/block-stack/block-stack.svelte";
import type { BlockStackProps } from "./components/block-stack/types.js";
import Box from "./components/box/box.svelte";
import type { BoxProps } from "./components/box/types.js";
import Button from "./components/button/button.svelte";
import type { ButtonProps } from "./components/button/button.types.ts";
import ButtonFrom from "./components/button/button-from.svelte";
import ButtonGroup from "./components/button-group/index.js";
import type { ButtonGroupProps } from "./components/button-group/types.ts";
import CalloutCard from "./components/callout-card/callout-card.svelte";
import type { CalloutCardProps } from "./components/callout-card/types.js";
import Card from "./components/card/card.svelte";
import type { CardProps } from "./components/card/types.js";
import Checkbox from "./components/checkbox/checkbox.svelte";
import type { CheckboxProps } from "./components/checkbox/types.js";
import ChoiceList from "./components/choice-list/choice-list.svelte";
import type { ChoiceListProps } from "./components/choice-list/types.js";
import Combobox from "./components/combobox/index.js";
import type { ComboboxProps } from "./components/combobox/types.js";
import Datepicker from "./components/datepicker/datepicker.svelte";
import type { DatePickerProps, Range } from "./components/datepicker/types.js";
import DescriptionList from "./components/description-list/description-list.svelte";
import type { DescriptionListProps } from "./components/description-list/types.js";
import Divider from "./components/divider/divider.svelte";
import type { DividerProps } from "./components/divider/types.js";
import EmptySearchResult from "./components/empty-search-result/empty-search-result.svelte";
import type { EmptySearchResultProps } from "./components/empty-search-result/types.js";
import EmptyState from "./components/empty-state/empty-state.svelte";
import type { EmptyStateProps } from "./components/empty-state/types.js";
import Filters from "./components/filters/filters.svelte";
import type { FiltersProps } from "./components/filters/types.js";
import Form from "./components/form/form.svelte";
import type { FormProps } from "./components/form/types.js";
import FormLayout from "./components/form-layout/form-layout.svelte";
import type { FormLayoutProps } from "./components/form-layout/types.js";
import Grid from "./components/grid/index.js";
import type { GridProps, CellProps } from "./components/grid/types.js";
import Icon from "./components/icon/icon.svelte";
import type { IconProps } from "./components/icon/types.js";
import Image from "./components/image/image.svelte";
import type { ImageProps } from "./components/image/types.js";
import IndexTable from "./components/index-table/index.js";
import type { IndexTableProps } from "./components/index-table/types.js";
import Indicator from "./components/indicator/indicator.svelte";
import type { IndicatorProps } from "./components/indicator/types.js";
import InlineError from "./components/inline-error/inline-error.svelte";
import type { InlineErrorProps } from "./components/inline-error/types.js";
import InlineGrid from "./components/inline-grid/inline-grid.svelte";
import type { InlineGridProps } from "./components/inline-grid/types.js";
import InlineStack from "./components/inline-stack/inline-stack.svelte";
import type { InlineStackProps } from "./components/inline-stack/types.js";
import KeypressListener from "./components/keypress-listener/keypress-listener.svelte";
import type { KeypressListenerProps } from "./components/keypress-listener/types.js";
import Label from "./components/label/label.svelte";
import type { LabelProps } from "./components/label/types.js";
import Labelled from "./components/labelled/labelled.svelte";
import type { LabelledProps } from "./components/labelled/types.js";
import Layout from "./components/layout/index.js";
import type { LayoutProps } from "./components/layout/types.js";
import LegacyCard from "./components/legacy-card/index.js";
import type { LegacyCardProps } from "./components/legacy-card/types.js";
import type { LegacyCardHeaderProps } from "./components/legacy-card/components/header/types.ts";
import type { LegacyCardSectionProps } from "./components/legacy-card/components/section/types.ts";
import type { LegacyCardSubsectionProps } from "./components/legacy-card/components/sub-section/types.ts";
import Link from "./components/link/link.svelte";
import type { LinkProps } from "./components/link/types.js";
import List from "./components/list/list.svelte";
import type { ListProps } from "./components/list/types.js";
import Listbox from "./components/listbox/index.js";
import type { ListboxProps } from "./components/listbox/types.js";
import MediaCard from "./components/media-card/media-card.svelte";
import type { MediaCardProps } from "./components/media-card/types.js";
import OptionList from "./components/option-list/option-list.svelte";
import type { OptionListProps } from "./components/option-list/types.js";
import Page from "./components/page/page.svelte";
import type { PageProps } from "./components/page/types.js";
import PageActions from "./components/page-actions/page-actions.svelte";
import type { PageActionsProps } from "./components/page-actions/types.js";
import Pagination from "./components/pagination/pagination.svelte";
import type { PaginationProps } from "./components/pagination/types.js";
import Popover from "./components/popover/index.js";
import type { PopoverProps } from "./components/popover/types.js";
import Portal from "./components/portal/portal.svelte";
import type { PortalProps } from "./components/portal/types.js";
import RadioButton from "./components/radio-button/radio-button.svelte";
import type { RadioButtonProps } from "./components/radio-button/types.js";
import ResourceItem from "./components/resource-item/resource-item.svelte";
import type { ResourceItemProps } from "./components/resource-item/types.js";
import ResourceList from "./components/resource-list/resource-list.svelte";
import type { ResourceListProps } from "./components/resource-list/types.js";
import Scrollable from "./components/scrollable/scrollable.svelte";
import type { ScrollableProps } from "./components/scrollable/types.js";
import Select from "./components/select/select.svelte";
import type { SelectProps } from "./components/select/types.js";
import SettingAction from "./components/setting-action/setting-action.svelte";
import type { SettingActionProps } from "./components/setting-action/types.js";
import Spinner from "./components/spinner/spinner.svelte";
import type { SpinnerProps } from "./components/spinner/types.js";
import Sticky from "./components/sticky/sticky.svelte";
import type { StickyProps } from "./components/sticky/types.js";
import Tabs from "./components/tabs/tabs.svelte";
import type { TabsProps, TabProps } from "./components/tabs/types.js";
import Tag from "./components/tag/tag.svelte";
import type { TagProps } from "./components/tag/types.js";
import Text from "./components/text/text.svelte";
import type { TextProps } from "./components/text/types.js";
import TextContainer from "./components/text-container/text-container.svelte";
import type { TextContainerProps } from "./components/text-container/types.js";
import TextField from "./components/text-field/text-field.svelte";
import type { TextFieldProps } from "./components/text-field/types.js";
import ThemeProvider from "./components/theme-provider/theme-provider.svelte";
import type { ThemeProviderProps } from "./components/theme-provider/types.js";
import Thumbnail from "./components/thumbnail/thumbnail.svelte";
import type { ThumbnailProps } from "./components/thumbnail/types.js";
import Tooltip from "./components/tooltip/tooltip.svelte";
import type { TooltipProps } from "./components/tooltip/types.js";
import UnstyledLink from "./components/unstyled-link/unstyled-link.svelte";
import type { UnstyledLinkProps } from "./components/unstyled-link/types.js";
import UnstyledButton from "./components/button/unstyled-button.svelte";
import type { UnstyledButtonProps } from "./components/button/unstyled-button.types.js";

export { PolarisAppProvider };
export { AccountConnection, type AccountConnectionProps };
export { ActionList, type ActionListProps }
export { ActionMenu, type ActionMenuProps };
export { AutoComplete, type AutocompleteProps };
export { Avatar, type AvatarProps };
export { Badge, type BadgeProps };
export { Bleed };
export { BlockStack, type BlockStackProps };
export { Box, type BoxProps };  
export { Button, ButtonFrom, type ButtonProps };
export { ButtonGroup, type ButtonGroupProps };
export { CalloutCard, type CalloutCardProps };
export { Card, type CardProps };
export { Checkbox, type CheckboxProps };
export { ChoiceList, type ChoiceListProps };
export { Combobox, type ComboboxProps };
export { Datepicker, type DatePickerProps, type Range };
export { DescriptionList, type DescriptionListProps };
export { Divider, type DividerProps }
export { EmptySearchResult, type EmptySearchResultProps };
export { EmptyState, type EmptyStateProps };
export { Filters, type FiltersProps }
export { Form, type FormProps }
export { FormLayout, type FormLayoutProps }
export { Grid, type GridProps, type CellProps as GridCellProps }
export { Icon, type IconProps}
export { Image, type ImageProps }
export { IndexTable, type IndexTableProps as IndexTableRowProps }
export { Indicator, type IndicatorProps }
export { InlineError, type InlineErrorProps }
export { InlineGrid, type InlineGridProps }
export { InlineStack, type InlineStackProps }
export { KeypressListener, type KeypressListenerProps }
export { Label, type LabelProps }
export { Labelled, type LabelledProps }
export { Layout, type LayoutProps }
export { LegacyCard, type LegacyCardProps, type LegacyCardHeaderProps, type LegacyCardSectionProps, type LegacyCardSubsectionProps }
export { Link, type LinkProps }
export { List, type ListProps }
export { Listbox, type ListboxProps }
export { MediaCard, type MediaCardProps }
export { OptionList, type OptionListProps }
export { Page, type PageProps }
export { PageActions, type PageActionsProps }
export { Pagination, type PaginationProps }
export { Popover, type PopoverProps }
export { Portal, type PortalProps }
export { RadioButton, type RadioButtonProps }
export { ResourceItem, type ResourceItemProps }
export { ResourceList, type ResourceListProps }
export { Scrollable, type ScrollableProps }
export { Select, type SelectProps }
export { SettingAction, type SettingActionProps }
export { Spinner, type SpinnerProps }
export { Sticky, type StickyProps }
export { Tabs, type TabsProps, type TabProps }
export { Tag, type TagProps }
export { Text, type TextProps }
export { TextContainer, type TextContainerProps }
export { TextField, type TextFieldProps }
export { ThemeProvider, type ThemeProviderProps }
export { Thumbnail, type ThumbnailProps }
export { Tooltip, type TooltipProps }
export { UnstyledButton, type UnstyledButtonProps }
export { UnstyledLink, type UnstyledLinkProps }


export type {
    RGBColor,
    HSBColor,
    RGBAColor,
    HSBAColor,
    HSLColor,
    HSLAColor,
    HSBLAColor,
  } from './utilities/color-types.js';

  export {
    rgbToHex,
    rgbToHsb,
    rgbToHsl,
    hsbToRgb,
    hsbToHex,
    hslToRgb,
    rgbString,
    rgbaString,
    hexToRgb,
  } from './utilities/color-transformers.js';

























```

# styles/polaris.css

```css
@charset "UTF-8";
@import "@shopify/polaris-tokens/css/styles.css";
@import "@shopify/polaris-tokens/css/media-queries.css";

:root {
    /* stylelint-disable -- Polaris component custom properties */
    --polaris-version-number: '{{POLARIS_VERSION}}';

    --pg-navigation-width: 240px;
    /* @TODO simplify media queries so this isn't needed */
    --pg-dangerous-magic-space-4: 16px;
    --pg-dangerous-magic-space-5: 20px;
    --pg-dangerous-magic-space-8: 32px;

    --pg-layout-width-primary-min: 480px;
    --pg-layout-width-primary-max: 662px;
    --pg-layout-width-secondary-min: 240px;
    --pg-layout-width-secondary-max: 320px;
    --pg-layout-width-one-half-width-base: 450px;
    --pg-layout-width-one-third-width-base: 240px;
    --pg-layout-width-nav-base: var(--pg-navigation-width);
    --pg-layout-width-page-content-partially-condensed: 450px;
    --pg-layout-width-inner-spacing-base: var(--pg-dangerous-magic-space-4);
    --pg-layout-width-outer-spacing-min: var(--pg-dangerous-magic-space-5);
    --pg-layout-width-outer-spacing-max: var(--pg-dangerous-magic-space-8);
    /*
      We need the result of this calcluation without rem;
      calc(
        var(--pg-layout-width-primary-min) / var(--pg-layout-width-secondary-min)
      );
  
      Previously scss would drop the rem suffix and resolve this to (480 / 240) = 2
      In CSS however this resolves to (480rem / 240rem) = 2rem
    */
    --pg-layout-relative-size: 2;

    --pg-dismiss-icon-size: 32px;

    --pg-top-bar-height: 56px;

    --pg-mobile-nav-width: calc(100vw - (var(--pg-dismiss-icon-size) + var(--pg-dangerous-magic-space-8)));

    --pg-control-height: 32px;
    --pg-control-vertical-padding: calc((36px - var(--p-font-line-height-600) - var(--p-space-050)) / 2);
    /* eslint-enable */
}

html,
body {
    font-size: var(--p-font-size-325);
    line-height: var(--p-font-line-height-500);
    font-weight: var(--p-font-weight-regular);
    font-feature-settings: 'calt' 0;
    letter-spacing: initial;
    color: var(--p-color-text);
    -webkit-tap-highlight-color: transparent;
}

html,
body,
button {
    font-family: var(--p-font-family-sans);
}

html {
    position: relative;
    font-size: 100%;
    -webkit-font-smoothing: antialiased;

    /* This needs to come after -webkit-font-smoothing */
    -moz-osx-font-smoothing: grayscale;

    text-size-adjust: 100%;
    text-rendering: optimizeLegibility;

    /* Safari scrollbar styles until it adopts scrollbar-color, scrollbar-width */
    &::-webkit-scrollbar {
        /* Matches scrollbar-width: thin */
        width: 11px;
        background-color: var(--p-color-bg);
    }

    &::-webkit-scrollbar-thumb {
        background-color: var(--p-color-bg);
        border: var(--p-border-width-050) solid transparent;
        border-radius: var(--p-border-radius-300);
        background-clip: content-box;
    }

    scrollbar-width: thin;
    scrollbar-color: var(--p-color-bg) var(--p-color-bg);
    transition: scrollbar-color var(--p-motion-duration-100) var(--p-motion-ease-in);

    &:hover {
        scrollbar-color: var(--p-color-scrollbar-thumb-bg-hover) var(--p-color-bg);

        &::-webkit-scrollbar-thumb {
            background-color: var(--p-color-scrollbar-thumb-bg-hover);
        }
    }
}

/*
    To support dynamic type in iOS, we need to set Apple's
    system font and then define font-families and rem-based
    font-sizes on descendant elements:
  */
@supports (font: -apple-system-body) {
    @media (--p-breakpoints-sm-down) {
        html {
            font: -apple-system-body;
        }
    }
}

body {
    min-height: 100%;
    margin: 0;
    padding: 0;

    /* hardcoding background color because app provider does not have access to */
    /* the --p-color-bg custom property. Will revisit best way to address in */
    /* follow-up. PR convo for reference */
    /* https://github.com/Shopify/polaris-react/pull/4636/files#r748646268 */
    background-color: rgba(241, 242, 244, 1);
    /* Set all nested scroll container scrolltrack backgrounds to transparent */
    scrollbar-color: var(--p-color-scrollbar-thumb-bg-hover) transparent;

    @media print {
        /* AppProvider sets styles on the body. These needs to */
        /* be overridden using !important. */
        background-color: transparent !important;
    }
}

*,
*::before,
*::after {
    box-sizing: border-box;
}

h1,
h2,
h3,
h4,
h5,
h6,
p {
    margin: 0;
    font-size: 1em;
    font-weight: var(--p-font-weight-regular);
}

button::-moz-focus-inner,
[type='button']::-moz-focus-inner,
[type='reset']::-moz-focus-inner,
[type='submit']::-moz-focus-inner {
    border-style: none;
}

html[class~='Polaris-Safari-16-Font-Optical-Sizing-Patch'] {
    /* Inter's "opsz" axis ranges from 14 to 32. This patch optimizes for smaller and less legible text by setting "opsz" 14 for all font sizes. */
    font-variation-settings: 'opsz' 14;
}
```

# use/use-breakpoints.svelte.ts

```ts
import { browser } from "$app/environment";
import { getMediaConditions, themeDefault, type BreakpointsAlias, type BreakpointsAliasDirection, type BreakpointsTokenGroup } from "@shopify/polaris-tokens";

const Breakpoints = {
  // TODO: Update to smDown
  navigationBarCollapsed: '767.95px',
  // TODO: Update to lgDown
  stackedContent: '1039.95px',
};

const noWindowMatches: MediaQueryList = {
  media: '',
  addListener: noop,
  removeListener: noop,
  matches: false,
  onchange: noop,
  addEventListener: noop,
  removeEventListener: noop,
  dispatchEvent: (_: Event) => true,
};

function noop() { }

export function navigationBarCollapsed() {
  return !browser
    ? noWindowMatches
    : window.matchMedia(`(max-width: ${Breakpoints.navigationBarCollapsed})`);
}

export function stackedContent() {
  return !browser
    ? noWindowMatches
    : window.matchMedia(`(max-width: ${Breakpoints.stackedContent})`);
}

/**
 * Directional alias for each Polaris `breakpoints` token.
 *
 * @example 'smUp' | 'smDown' | 'smOnly' | 'mdUp' | etc.
 */
export type BreakpointsDirectionAlias =
  `${BreakpointsAlias}${Capitalize<BreakpointsAliasDirection>}`;

/**
 * Match results for each directional Polaris `breakpoints` alias.
 */
type BreakpointsMatches = {
  [DirectionAlias in BreakpointsDirectionAlias]: boolean;
};

const hookCallbacks = new Set<
  (breakpointAlias: BreakpointsDirectionAlias, matches: boolean) => void
>();

const breakpointsQueryEntries = getBreakpointsQueryEntries(
  themeDefault.breakpoints,
);

export function getBreakpointsQueryEntries(breakpoints: BreakpointsTokenGroup) {
  const mediaConditionEntries = Object.entries(getMediaConditions(breakpoints));

  return mediaConditionEntries
    .map(([breakpointsToken, mediaConditions]) =>
      Object.entries(mediaConditions).map(([direction, mediaCondition]) => {
        const breakpointsAlias = breakpointsToken.split('-')[1];

        // e.g. smUp, smDown, smOnly, etc.
        const directionAlias = `${breakpointsAlias}${capitalize(direction)}`;

        return [directionAlias, mediaCondition];
      }),
    )
    .flat() as [BreakpointsDirectionAlias, string][];
}

function capitalize(str: string) {
  return str.charAt(0).toUpperCase() + str.slice(1);
}

function getDefaultMatches(defaults?: UseBreakpointsOptions['defaults']) {
  return Object.fromEntries(
    breakpointsQueryEntries.map(([directionAlias]) => [
      directionAlias,
      typeof defaults === 'boolean'
        ? defaults
        : defaults?.[directionAlias] ?? false,
    ]),
  ) as BreakpointsMatches;
}

function getLiveMatches() {
  return Object.fromEntries(
    breakpointsQueryEntries.map(([directionAlias, query]) => [
      directionAlias,
      window.matchMedia(query).matches,
    ]),
  ) as BreakpointsMatches;
}

export interface UseBreakpointsOptions {
  /**
   * Default values applied during SSR. Accepts a single value to use for each
   * breakpoint alias, or an object for configuring select breakpoints.
   *
   * @default false
   */
  defaults:
  | boolean
  | {
    [DirectionAlias in BreakpointsDirectionAlias]?: boolean;
  };
}

export class UseBreakpoints {
  breakpoints = $state<BreakpointsMatches>();
  options?: UseBreakpointsOptions;

  constructor(options?: UseBreakpointsOptions) {
    this.options = options;
    this.breakpoints = getDefaultMatches(options?.defaults);
    this.startTracking();
    this.registerCallbacks();
  }

  registerCallbacks() {
    if (browser) {
      breakpointsQueryEntries.forEach(([breakpointAlias, query]) => {
        const eventListener = (event: { matches: boolean }) => {
          for (const hookCallback of hookCallbacks) {
            hookCallback(breakpointAlias, event.matches);
          }
        };
        const mql = window.matchMedia(query);
        if (mql.addListener) {
          mql.addListener(eventListener);
        } else {
          mql.addEventListener('change', eventListener);
        }
      });
    }
  }

  startTracking() {
    $effect(() => {
      this.breakpoints = getLiveMatches();
      const callback = (
        breakpointAlias: BreakpointsDirectionAlias,
        matches: boolean,
      ) => {
        // @ts-ignore
        this.breakpoints = {
          ...(this.breakpoints ?? {}),
          [breakpointAlias]: matches,
        }
      };

      hookCallbacks.add(callback);
      return () => {
        hookCallbacks.delete(callback);
      }
    })
  }

  getCurrentBreakpoints() {
    return this.breakpoints;
  }
}

export function useBreakpoints(options?: UseBreakpointsOptions) {
  return new UseBreakpoints(options);
}

```

# use/use-bulk-selection.svelte.ts

```ts
import { SelectionType, type HandleBulkSelectionOptions, type HandleSelectionChange } from "$utilities/index-provider/types.js";
import type { Range } from "./use-index-resource-state.svelte.js";

export class HandleBulkSelection {
    private readonly onSelectionChange: HandleSelectionChange;
    lastSelected = $state<number | null>(null);

    constructor(options: HandleBulkSelectionOptions) {
        if (!options || typeof options.onSelectionChange !== 'function') {
            throw new Error("BulkSelectionHandler: 'onSelectionChange' callback option is required and must be a function.");
        }
        this.onSelectionChange = options.onSelectionChange;
    }


    public handleSelectionChange =(selectionType: SelectionType, toggleType: boolean, selection?: string | Range, sortOrder?: number): void => {
        const prevSelected = this.lastSelected;
        
        if (selectionType === SelectionType.Multi && typeof sortOrder === 'number') {
            this.lastSelected = sortOrder;
        }

        if (
            selectionType === SelectionType.Single ||
            (selectionType === SelectionType.Multi &&
                (typeof prevSelected !== 'number' || typeof sortOrder !== 'number'))
        ) {
            this.onSelectionChange(SelectionType.Single, toggleType, selection);
        } else if (selectionType === SelectionType.Multi) {
            const min = Math.min(prevSelected as number, sortOrder as number);
            const max = Math.max(prevSelected as number, sortOrder as number);
            this.onSelectionChange(selectionType, toggleType, [min, max]);
        } else if (
            selectionType === SelectionType.Page ||
            selectionType === SelectionType.All
        ) {
            this.onSelectionChange(selectionType, toggleType);
        } else if (selectionType === SelectionType.Range) {
            this.onSelectionChange(SelectionType.Range, toggleType, selection);
        }
    }
}

/* export function useHandleBulkSelection({
    onSelectionChange = () => { },
}: HandleBulkSelectionOptions) {
    let lastSelected = $state<number | null>(null);
    console.log("lastSelected", lastSelected);

    const handleSelectionChange: HandleSelectionChange = (
        selectionType: SelectionType,
        toggleType: boolean,
        selection?: string | Range,
        sortOrder?: number,
    ) => {
        const prevSelected = lastSelected;
        console.log("prevSelected", prevSelected);
        console.log("selectionType", selectionType);

        if (SelectionType.Multi && typeof sortOrder === 'number') {
            lastSelected = sortOrder;
        }

        if (
            selectionType === SelectionType.Single ||
            (selectionType === SelectionType.Multi &&
                (typeof prevSelected !== 'number' || typeof sortOrder !== 'number'))
        ) {
            onSelectionChange(SelectionType.Single, toggleType, selection);
        } else if (selectionType === SelectionType.Multi) {
            const min = Math.min(prevSelected as number, sortOrder as number);
            const max = Math.max(prevSelected as number, sortOrder as number);
            onSelectionChange(selectionType, toggleType, [min, max]);
        } else if (
            selectionType === SelectionType.Page ||
            selectionType === SelectionType.All
        ) {
            onSelectionChange(selectionType, toggleType);
        } else if (selectionType === SelectionType.Range) {
            onSelectionChange(SelectionType.Range, toggleType, selection);
        }
    };

    return handleSelectionChange;
} */
```

# use/use-index-resource-state.svelte.ts

```ts
export enum SelectionType {
  All = 'all',
  Page = 'page',
  Multi = 'multi',
  Single = 'single',
  Range = 'range',
}

export type Range = [number, number];

export type ResourceIDResolver<T extends {[key: string]: unknown}> = (
  resource: T,
) => string;

function defaultResourceIDResolver(resource: {[key: string]: any}): string {
  if ('id' in resource) {
    return resource.id;
  }

  throw new Error(
    'Your resource does not directly contain an `id`. Pass a `resourceIDResolver` to `useIndexResourceState`',
  );
}

export class IndexResourceState<T extends { [key: string]: unknown }> {
    private readonly initialResources: ReadonlyArray<T>;
    private readonly resourceIDResolver: ResourceIDResolver<T>;
    private readonly resourceFilter?: (value: T, index: number, array: ReadonlyArray<T>) => boolean;
  
    selectedResources = $state<string[]>([]);
    allResourcesSelected = $state<boolean>(false);
  
    constructor(
      initialResources: ReadonlyArray<T>,
      options: {
        selectedResources?: string[];
        allResourcesSelected?: boolean;
        resourceIDResolver?: ResourceIDResolver<T>;
        resourceFilter?: (value: T, index: number, array: ReadonlyArray<T>) => boolean;
      } = {},
    ) {
      this.initialResources = initialResources;
  
      const {
        selectedResources: initSelectedResources = [],
        allResourcesSelected: initAllResourcesSelected = false,
        resourceIDResolver = defaultResourceIDResolver as ResourceIDResolver<T>, // Cast if defaultResolver is not generic enough
        resourceFilter,
      } = options;
  
      // Initialize $state fields by assigning to them
      // Svelte 5 handles this initialization for $state fields within the constructor or as field initializers
      this.selectedResources = initSelectedResources;
      this.allResourcesSelected = initAllResourcesSelected;
  
      this.resourceIDResolver = resourceIDResolver;
      this.resourceFilter = resourceFilter;
    }
  
    handleSelectionChange = (
      selectionType: SelectionType,
      isSelecting: boolean,
      selection?: string | Range,
      // _position is unused
    ) => {
      if (selectionType === SelectionType.All) {
        this.allResourcesSelected = isSelecting;
      } else if (this.allResourcesSelected) {
        this.allResourcesSelected = false;
      }
  
      const currentSelected = this.selectedResources; // Access reactive state
  
      switch (selectionType) {
        case SelectionType.Single:
          if (typeof selection === 'string') {
            if (isSelecting) {
              if (!currentSelected.includes(selection)) {
                this.selectedResources = [...currentSelected, selection];
              }
            } else {
              this.selectedResources = currentSelected.filter((id) => id !== selection);
            }
          }
          break;
  
        case SelectionType.All:
        case SelectionType.Page:
          {
            const targetResources = this.resourceFilter
              ? this.initialResources.filter(this.resourceFilter)
              : this.initialResources;
            this.selectedResources = isSelecting
              ? targetResources.map(this.resourceIDResolver)
              : [];
          }
          break;
  
        case SelectionType.Multi:
          if (!selection || !Array.isArray(selection)) break;
          {
            const range = selection as Range;
            const idsToConsider: string[] = [];
  
            for (let i = range[0]; i <= range[1]; i++) {
              const resource = this.initialResources[i];
              if (resource) {
                if (this.resourceFilter && !this.resourceFilter(resource, i, this.initialResources)) {
                  continue;
                }
                idsToConsider.push(this.resourceIDResolver(resource));
              }
            }
  
            if (isSelecting) {
              const newIdsToAdd = idsToConsider.filter(id => !currentSelected.includes(id));
              this.selectedResources = [...currentSelected, ...newIdsToAdd];
            } else {
              this.selectedResources = currentSelected.filter(id => !idsToConsider.includes(id));
            }
          }
          break;
  
        case SelectionType.Range:
          if (!selection || !Array.isArray(selection)) break;
          {
            const targetResources = this.resourceFilter
              ? this.initialResources.filter(this.resourceFilter)
              : this.initialResources;
            
            const rangeIndices = selection as Range;
            const startIndex = Math.max(0, Number(rangeIndices[0]));
            const endIndex = Math.min(targetResources.length - 1, Number(rangeIndices[1]));
  
            const idsInRange: string[] = [];
            if (startIndex <= endIndex) {
              for (let i = startIndex; i <= endIndex; i++) {
                if (targetResources[i]) {
                  idsInRange.push(this.resourceIDResolver(targetResources[i]));
                }
              }
            }
            
            const isAnyInRangeSelected = idsInRange.some(id => currentSelected.includes(id));
            const areAllInRangeSelected = idsInRange.length > 0 && idsInRange.every(id => currentSelected.includes(id));
  
            if (isSelecting) {
               const newSelected = new Set([...currentSelected, ...idsInRange]);
               this.selectedResources = Array.from(newSelected);
            } else {
              if (areAllInRangeSelected || isAnyInRangeSelected) {
                  this.selectedResources = currentSelected.filter(id => !idsInRange.includes(id));
              }
            }
          }
          break;
      }
    };
  
    clearSelection = () => {
      this.selectedResources = [];
      this.allResourcesSelected = false;
    };
  
    removeSelectedResources = (removeResourceIds: string[]) => {
      this.selectedResources = this.selectedResources.filter(
        (id) => !removeResourceIds.includes(id),
      );
      if (this.allResourcesSelected && this.selectedResources.length < this.initialResources.filter(this.resourceFilter || (() => true)).length) {
        this.allResourcesSelected = false;
      }
    };
  }

/* export function useIndexResourceState<T extends {[key: string]: unknown}>(
  resources: T[],
  {
    selectedResources: initSelectedResources = [],
    allResourcesSelected: initAllResourcesSelected = false,
    resourceIDResolver = defaultResourceIDResolver,
    resourceFilter = undefined,
  }: {
    selectedResources?: string[];
    allResourcesSelected?: boolean;
    resourceIDResolver?: ResourceIDResolver<T>;
    resourceFilter?: (value: T, index: number) => boolean;
  } = {
    selectedResources: [],
    allResourcesSelected: false,
    resourceIDResolver: defaultResourceIDResolver,
    resourceFilter: undefined,
  },
) {
  
    let selectedResources = $state(initSelectedResources);
    let allResourcesSelected = $state(initAllResourcesSelected);

  const handleSelectionChange = (selectionType: SelectionType,
      isSelecting: boolean,
      selection?: string | Range,
      // This is not used in the function, but needed to keep the type compatible with IndexProviderProps onSelectionChange
      _position?: number,
    ) => {
      if (selectionType === SelectionType.All) {
        allResourcesSelected = isSelecting;
      } else if (allResourcesSelected) {
        allResourcesSelected = false;
      }

      switch (selectionType) {
        case SelectionType.Single:
          selectedResources =
            isSelecting
              ? [...selectedResources, selection as string]
              : selectedResources.filter((id) => id !== selection);
          break;
        case SelectionType.All:
        case SelectionType.Page:
          if (resourceFilter) {
            const filteredResources = resources.filter(resourceFilter);
            selectedResources =
              isSelecting && selectedResources.length < filteredResources.length
                ? filteredResources.map(resourceIDResolver)
                : [];
          } else {
            selectedResources =
              isSelecting ? resources.map(resourceIDResolver) : [];
          }

          break;
        case SelectionType.Multi:
          if (!selection) break;
          selectedResources = () => {
            const ids: string[] = [];
            const filteredResources = resourceFilter
              ? resources.filter(resourceFilter)
              : resources;
            for (
              let i = selection[0] as number;
              i <= (selection[1] as number);
              i++
            ) {
              if (filteredResources.includes(resources[i])) {
                const id = resourceIDResolver(resources[i]);

                if (
                  (isSelecting && !selectedResources.includes(id)) ||
                  (!isSelecting && selectedResources.includes(id))
                ) {
                  ids.push(id);
                }
              }
            }

            return isSelecting
              ? [...selectedResources, ...ids]
              : selectedResources.filter((id) => !ids.includes(id));
          };

          break;
        case SelectionType.Range:
          if (!selection) break;

          setSelectedResources((currentSelectedResources) => {
            const filteredResources = resourceFilter
              ? resources.filter(resourceFilter)
              : resources;

            const resourceIds = filteredResources.map(resourceIDResolver);

            const selectedIds = resourceIds.slice(
              Number(selection[0]),
              Number(selection[1]) + 1,
            );

            const isIndeterminate = selectedIds.some((id) => {
              return selectedResources.includes(id);
            });

            const isChecked = selectedIds.every((id) => {
              return selectedResources.includes(id);
            });

            const isSelectingAllInRange =
              !isChecked && (isSelecting || isIndeterminate);

            const nextSelectedResources = isSelectingAllInRange
              ? [
                  ...new Set([
                    ...currentSelectedResources,
                    ...selectedIds,
                  ]).values(),
                ]
              : currentSelectedResources.filter(
                  (id) => !selectedIds.includes(id),
                );

            return nextSelectedResources;
          });
          break;
      }
    };

  const clearSelection = () => {
    setSelectedResources([]);
    allResourcesSelected = false);
  };

  const removeSelectedResources = (removeResources: string[]) => {
      const selectedResourcesCopy = [...selectedResources];

      const newSelectedResources = selectedResourcesCopy.filter(
        (resource) => !removeResources.includes(resource),
      );

      setSelectedResources(newSelectedResources);

      if (newSelectedResources.length === 0) {
        allResourcesSelected = false);
      }
    };

  return {
    selectedResources,
    allResourcesSelected,
    handleSelectionChange,
    clearSelection,
    removeSelectedResources,
  };
} */

```

# use/use-toggle.svelte.ts

```ts
export class UseToggle {
  value = $state<boolean>(false);
  //set initial state
  constructor(initialState: boolean) {
    this.value = initialState;
  }

  toggle = () => {
    this.value = !this.value;
  }

  setTrue = () => {
    this.value = true;
  }

  setFalse = () => {
    this.value = false;
  }
}
```

# utilities/arrays.ts

```ts
export interface ArrayComparator<T> {
  (firstArray: T, SecondArray: T): boolean;
}

export function arraysAreEqual<T>(
  firstArray: T[],
  secondArray: T[],
  comparator?: ArrayComparator<T>,
) {
  if (firstArray.length !== secondArray.length) {
    return false;
  }
  return firstArray.every((firstItem, index) => {
    const secondItem = secondArray[index];
    if (comparator != null) {
      return comparator(firstItem, secondItem);
    }
    return firstItem === secondItem;
  });
}

```

# utilities/clamp.ts

```ts
export function clamp(number: number, min: number, max: number) {
  if (number < min) return min;
  if (number > max) return max;
  return number;
}

```

# utilities/color-transformers.ts

```ts
import {clamp} from './clamp.js';
import type {
  RGBColor,
  RGBAColor,
  HSBColor,
  HSBAColor,
  HSLColor,
  HSLAColor,
  HSBLAColor,
} from './color-types.js';
import {roundNumberToDecimalPlaces} from './roundNumberToDecimalPlaces.js';

export function rgbString(color: RGBColor | RGBAColor) {
  const {red, green, blue} = color;

  if ('alpha' in color) {
    return `rgba(${red}, ${green}, ${blue}, ${color.alpha})`;
  } else {
    return `rgb(${red}, ${green}, ${blue})`;
  }
}

export const rgbaString = rgbString;

export function rgbToHex({red, green, blue}: RGBColor) {
  return `#${componentToHex(red)}${componentToHex(green)}${componentToHex(
    blue,
  )}`;
}

function componentToHex(component: number) {
  const hex = component.toString(16);
  return hex.length === 1 ? `0${hex}` : hex;
}

export function hsbToHex(color: HSBColor) {
  return rgbToHex(hsbToRgb(color));
}

function rgbFromHueAndChroma(hue: number, chroma: number) {
  const huePrime = hue / 60;
  const hueDelta = 1 - Math.abs((huePrime % 2) - 1);
  const intermediateValue = chroma * hueDelta;

  let red = 0;
  let green = 0;
  let blue = 0;
  if (huePrime >= 0 && huePrime <= 1) {
    red = chroma;
    green = intermediateValue;
    blue = 0;
  }

  if (huePrime >= 1 && huePrime <= 2) {
    red = intermediateValue;
    green = chroma;
    blue = 0;
  }

  if (huePrime >= 2 && huePrime <= 3) {
    red = 0;
    green = chroma;
    blue = intermediateValue;
  }

  if (huePrime >= 3 && huePrime <= 4) {
    red = 0;
    green = intermediateValue;
    blue = chroma;
  }

  if (huePrime >= 4 && huePrime <= 5) {
    red = intermediateValue;
    green = 0;
    blue = chroma;
  }

  if (huePrime >= 5 && huePrime <= 6) {
    red = chroma;
    green = 0;
    blue = intermediateValue;
  }

  return {red, green, blue};
}

// implements https://en.wikipedia.org/wiki/HSL_and_HSV#From_HSV
export function hsbToRgb(color: HSBColor): RGBColor;
export function hsbToRgb(color: HSBAColor): RGBAColor;
export function hsbToRgb(color: HSBAColor): RGBAColor {
  const {hue, saturation, brightness, alpha = 1} = color;
  const chroma = brightness * saturation;

  let {red, green, blue} = rgbFromHueAndChroma(hue, chroma);

  const chromaBrightnessDelta = brightness - chroma;
  red += chromaBrightnessDelta;
  green += chromaBrightnessDelta;
  blue += chromaBrightnessDelta;

  return {
    red: Math.round(red * 255),
    green: Math.round(green * 255),
    blue: Math.round(blue * 255),
    alpha,
  };
}

// implements https://en.wikipedia.org/wiki/HSL_and_HSV#From_HSV
export function hslToRgb(color: HSLColor): RGBColor;
export function hslToRgb(color: HSLAColor): RGBAColor;
export function hslToRgb(color: HSLAColor): RGBAColor {
  const {hue, saturation, lightness, alpha = 1} = color;
  const chroma = (1 - Math.abs(2 * (lightness / 100) - 1)) * (saturation / 100);

  let {red, green, blue} = rgbFromHueAndChroma(hue, chroma);

  const lightnessVal = lightness / 100 - chroma / 2;
  red += lightnessVal;
  green += lightnessVal;
  blue += lightnessVal;

  return {
    red: Math.round(red * 255),
    green: Math.round(green * 255),
    blue: Math.round(blue * 255),
    alpha,
  };
}

// ref https://en.wikipedia.org/wiki/HSL_and_HSV
function rgbToHsbl(color: RGBAColor, type: 'b' | 'l' = 'b'): HSBLAColor {
  const {alpha = 1} = color;

  const red = color.red / 255;
  const green = color.green / 255;
  const blue = color.blue / 255;

  const largestComponent = Math.max(red, green, blue);
  const smallestComponent = Math.min(red, green, blue);

  const delta = largestComponent - smallestComponent;
  const lightness = (largestComponent + smallestComponent) / 2;
  let saturation = 0;
  if (largestComponent === 0) {
    saturation = 0;
  } else if (type === 'b') {
    saturation = delta / largestComponent;
  } else if (type === 'l') {
    const baseSaturation =
      lightness > 0.5
        ? delta / (2 - largestComponent - smallestComponent)
        : delta / (largestComponent + smallestComponent);
    saturation = isNaN(baseSaturation) ? 0 : baseSaturation;
  }

  let huePercentage = 0;
  switch (largestComponent) {
    case red:
      huePercentage = (green - blue) / delta + (green < blue ? 6 : 0);
      break;
    case green:
      huePercentage = (blue - red) / delta + 2;
      break;
    case blue:
      huePercentage = (red - green) / delta + 4;
  }

  const hue = (huePercentage / 6) * 360;
  const clampedHue = clamp(hue, 0, 360);

  return {
    hue: clampedHue ? roundNumberToDecimalPlaces(clampedHue, 2) : 0,
    saturation: roundNumberToDecimalPlaces(clamp(saturation, 0, 1), 4),
    brightness: roundNumberToDecimalPlaces(clamp(largestComponent, 0, 1), 4),
    lightness: roundNumberToDecimalPlaces(lightness, 4),
    alpha: roundNumberToDecimalPlaces(alpha, 4),
  };
}

export function rgbToHsb(color: RGBColor): HSBColor;
export function rgbToHsb(color: RGBAColor): HSBAColor {
  const {hue, saturation, brightness, alpha = 1} = rgbToHsbl(color, 'b');
  return {hue, saturation, brightness, alpha};
}

export function rgbToHsl(color: RGBColor): HSLAColor;
export function rgbToHsl(color: RGBAColor): HSLAColor {
  const {
    hue,
    saturation: rawSaturation,
    lightness: rawLightness,
    alpha = 1,
  } = rgbToHsbl(color, 'l');

  const saturation = roundNumberToDecimalPlaces(rawSaturation * 100, 2);
  const lightness = roundNumberToDecimalPlaces(rawLightness * 100, 2);

  return {hue, saturation, lightness, alpha};
}

export function hexToRgb(color: string) {
  if (color.length === 4) {
    const repeatHex = (hex1: number, hex2: number) =>
      color.slice(hex1, hex2).repeat(2);
    const red = parseInt(repeatHex(1, 2), 16);
    const green = parseInt(repeatHex(2, 3), 16);
    const blue = parseInt(repeatHex(3, 4), 16);

    return {red, green, blue};
  }

  const red = parseInt(color.slice(1, 3), 16);
  const green = parseInt(color.slice(3, 5), 16);
  const blue = parseInt(color.slice(5, 7), 16);

  return {red, green, blue};
}

type ColorType = 'hex' | 'rgb' | 'rgba' | 'hsl' | 'hsla' | 'default';

function getColorType(color: string): ColorType {
  if (color.includes('#')) {
    return 'hex';
  } else if (color.includes('rgb')) {
    return 'rgb';
  } else if (color.includes('rgba')) {
    return 'rgba';
  } else if (color.includes('hsl')) {
    return 'hsl';
  } else if (color.includes('hsla')) {
    return 'hsla';
  } else {
    if (process.env.NODE_ENV === 'development') {
      /* eslint-disable-next-line no-console */
      console.warn('Accepted colors formats are: hex, rgb, rgba, hsl and hsla');
    }
    return 'default';
  }
}

function rgbToObject(color: string): RGBAColor {
  // eslint-disable-next-line @typescript-eslint/prefer-regexp-exec
  const colorMatch = color.match(/\(([^)]+)\)/);

  if (!colorMatch) {
    return {red: 0, green: 0, blue: 0, alpha: 0};
  }

  const [red, green, blue, alpha] = colorMatch[1].split(',');
  const objColor = {
    red: parseInt(red, 10),
    green: parseInt(green, 10),
    blue: parseInt(blue, 10),
    alpha: parseInt(alpha, 10) || 1,
  };
  return objColor;
}

function hexToHsla(color: string): HSLAColor {
  return rgbToHsl(hexToRgb(color));
}

function rbgStringToHsla(color: string): HSLAColor {
  return rgbToHsl(rgbToObject(color));
}

function hslToObject(color: string): HSLAColor {
  // eslint-disable-next-line @typescript-eslint/prefer-regexp-exec
  const colorMatch = color.match(/\(([^)]+)\)/);

  if (!colorMatch) {
    return {hue: 0, saturation: 0, lightness: 0, alpha: 0};
  }

  const [hue, saturation, lightness, alpha] = colorMatch[1].split(',');
  const objColor = {
    hue: roundNumberToDecimalPlaces(parseFloat(hue), 2),
    saturation: roundNumberToDecimalPlaces(parseFloat(saturation), 2),
    lightness: roundNumberToDecimalPlaces(parseFloat(lightness), 2),
    alpha: roundNumberToDecimalPlaces(parseFloat(alpha), 2) || 1,
  };
  return objColor;
}

export function colorToHsla(color: string): HSLAColor {
  const type = getColorType(color);
  switch (type) {
    case 'hex':
      return hexToHsla(color);
    case 'rgb':
    case 'rgba':
      return rbgStringToHsla(color);
    case 'hsl':
    case 'hsla':
      return hslToObject(color);
    case 'default':
    default:
      throw new Error(
        'Accepted color formats are: hex, rgb, rgba, hsl and hsla',
      );
  }
}

```

# utilities/color-types.ts

```ts
export interface RGBColor {
  red: number;
  green: number;
  blue: number;
}

export interface RGBAColor extends RGBColor {
  alpha: number;
}

export interface HSColor {
  /** The color */
  hue: number;
  /** Saturation of the color */
  saturation: number;
}

export interface HSBColor extends HSColor {
  /** Brightness of the color */
  brightness: number;
}

export interface HSLColor extends HSColor {
  /** Lightness of the color */
  lightness: number;
}

export type HSBLAColor = HSBAColor & HSLAColor;

export interface HSBAColor extends HSBColor {
  /** Level of transparency */
  alpha: number;
}

export interface HSLAColor extends HSLColor {
  /** Level of transparency */
  alpha: number;
}

```

# utilities/color-validation.ts

```ts
import type {RGBColor, RGBAColor} from './color-types.js';

// implements: https://www.w3.org/WAI/ER/WD-AERT/#color-contrast
export function isLight({red, green, blue}: RGBColor | RGBAColor): boolean {
  const contrast = (red * 299 + green * 587 + blue * 114) / 1000;
  return contrast > 125;
}

export function isDark(color: RGBColor | RGBAColor): boolean {
  return !isLight(color);
}

```

# utilities/combobox/hooks.ts

```ts
import { useContext } from "$utilities/contexts.js";
import { COMBOBOX_LIST_BOX_CONTEXT_KEY, COMBOBOX_TEXT_FIELD_CONTEXT_KEY, type ComboboxListboxType, type ComboboxTextFieldType } from "./types.js";

/* export function useComboboxTextField(): ComboboxTextFieldType {
    const context = useContext<ComboboxTextFieldType>(COMBOBOX_TEXT_FIELD_CONTEXT_KEY);
    if (!context) {
        throw new Error(
            'No Combobox was provided. Your component must be wrapped in a <Combobox> component.',
        );
    }
    return context();
} */
```

# utilities/combobox/types.ts

```ts
export interface ComboboxTextFieldType {
    // Value for the TextField aria-activedescendant. (also on list context when not in combobox)
    activeOptionId?: string;
    // Value for the Combobox aria-owns and TextField aria-control
    listboxId?: string;
    // Value for aria-expanded on TextField
    expanded?: boolean;
    // Sets the value for the Listbox aria-labelledby
    setTextFieldLabelId?(id: string): void;
    // Sets a boolean to enable/disable keyboard control for the Listbox
    setTextFieldFocused?(value: boolean): void;
    // Callback fired when TextField is focused
    onTextFieldFocus?(): void;
    // Callback fired when TextField is blurred
    onTextFieldBlur?(): void;
    // Callback fired when TextField value changes
    onTextFieldChange?(value: string): void;
  }
  
  export interface ComboboxListboxType {
    // Value of the Texfields ID for listbox aria-labelledby
    textFieldLabelId?: string;
    // Enables/disables keyboard control
    textFieldFocused?: boolean;
    // Unique ID to set on the listbox. Used to set the Combobox aria-owns and TextField aria-controls attributes.
    listboxId?: string;
    // Whethor or not more options are available to lazy load. Use the hasMoreResults boolean provided by the GraphQL API of the paginated data. */
    willLoadMoreOptions?: boolean;
    // Sets the value for the TextField aria-activedescendant attribute.
    setActiveOptionId?(id: string): void;
    // Callback to set a generated listbox ID.
    setListboxId?(id: string): void;
    // Callback fired when an option is selected.
    onOptionSelected?(): void;
    // Callback fired when keyboard user navigates to the last item. Use to lazy load when listbox option data is paginated.
    onKeyToBottom?(): void;
  }

export interface ComboboxListboxOptionType {
    // Whether the option should visually support multiple selection
    allowMultiple?: boolean;
}

export const COMBOBOX_TEXT_FIELD_CONTEXT_KEY = 'combobox-text-field-context';
export const COMBOBOX_LIST_BOX_CONTEXT_KEY = 'combobox-list-box-context';
export const COMBOBOX_LIST_BOX_OPTION_CONTEXT_KEY = 'combobox-list-box-option-context';

```

# utilities/contexts.ts

```ts
import { EPHEMERAL_PRESENCE_MANAGER_CONTEXT_KEY, type EphemeralPresenceManagerContextType } from "$lib/components/app-provider/types.js";
import type { ThemeName } from "@shopify/polaris-tokens";
import { getContext, setContext } from "svelte";
import { MAPPED_ACTION_CONTEXT_KEY, type MappedActionContextType } from "./listbox/types.js";

export const SCROLLABLE_CONTEXT_KEY = 'scrollable';
export type ScrollToPositionFn = (scrollY: number) => void;
export const useContext = <T>(key: string): (() => T | undefined) => {
  const context = getContext<T>(key) as any;
  if (!context) {
    return () => undefined;
  }
  return context;
}


// Define the types for your context value (mirroring your React types)
export type PortalsContainerElement = HTMLDivElement | null; // Or your actual definition
export interface PortalsManager {
  container?: PortalsContainerElement;
}

/* export function usePortalsManager() {
  const portalsManager = useContext<PortalsManager | undefined>(PORTALS_MANAGER_KEY);

  if (!portalsManager) {
    throw new Error(
      'No portals manager was provided. Your application must be wrapped in an <AppProvider> component. See https://polaris.shopify.com/components/app-provider for implementation instructions.',
    );
  }

  return portalsManager;
} */

export const THEME_NAME_KEY = 'ThemeName';
export function useThemeName() {
  const themeName = useContext<ThemeName | null>(THEME_NAME_KEY);

  if (!themeName) {
    throw new Error(
      'No themeName was provided. Your application must be wrapped in an <AppProvider> or <ThemeProvider> component. See https://polaris.shopify.com/components/app-provider for implementation instructions.',
    );
  }

  return themeName;
}

/* export function useEphemeralPresenceManager() {
    const ephemeralPresenceManager = useContext<EphemeralPresenceManagerContextType | undefined>(EPHEMERAL_PRESENCE_MANAGER_CONTEXT_KEY);

    if (!ephemeralPresenceManager) {
        throw new Error(
            'No ephemeral presence manager was provided. Your application must be wrapped in an <AppProvider> component. See https://polaris.shopify.com/components/app-provider for implementation instructions.',
        );
    }

    return ephemeralPresenceManager;
} */

/* export function useMappedAction() {
    const mappedAction = useContext<MappedActionContextType | undefined>(MAPPED_ACTION_CONTEXT_KEY);

    if (!mappedAction) {
        throw new Error(
            'No mapped action was provided. Your application must be wrapped in an <AppProvider> component. See https://polaris.shopify.com/components/app-provider for implementation instructions.',
        );
    }

    return mappedAction;
} */




```

# utilities/css.ts

```ts
import type { BreakpointsAlias } from '@shopify/polaris-tokens';
import { breakpointsAliases } from '@shopify/polaris-tokens';

import { isObject } from '$utilities/is-object.js';

type Falsy = boolean | undefined | null | 0;

type ResponsivePropConfig<T = string> = {
  [Breakpoint in BreakpointsAlias]?: T;
};

export type ResponsiveProp<T> = T | ResponsivePropConfig<T>;

export type ResponsiveValue<T = string> = undefined | ResponsiveProp<T>;

type ResponsiveVariables<T> = {
  [Breakpoint in `${string}-${BreakpointsAlias}`]?: T;
};

export function classNames(...classes: (string | Falsy)[]) {
  return classes.filter(Boolean).join(' ');
}

export function variationName(name: string, value: string) {
  return `${name}${value.charAt(0).toUpperCase()}${value.slice(1)}`;
}

export const isFalsyString = (value: string | undefined) => value != null && value !== '' && value != undefined;

export function sanitizeCustomProperties(
  styles: Record<string, string | number | undefined | null>,
): Record<string, string> {
  const nonNullValues: [string, string][] = Object.entries(styles).filter(
    ([_, value]) => value != null && value !== '' && value != undefined,
  ) as [string, string][];

  return nonNullValues.length ? Object.fromEntries(nonNullValues) : {};
}

/**
 * Given params like so:
 * (
 *   'button',
 *   'padding',
 *   'spacing',
 *   {
 *     sm: "4",
 *     lg: "6"
 *   }
 * )
 * Converts it to an object like so:
 * {
 *   '--pc-button-padding-sm': 'var(--p-spacing-4)',
 *   '--pc-button-padding-lg': 'var(--p-spacing-6)'
 * }
 *
 */
export function getResponsiveProps<T = string>(
  componentName: string,
  componentProp: string,
  tokenSubgroup: string,
  responsiveProp?: ResponsiveProp<T>,
): ResponsiveVariables<T> {
  if (!responsiveProp) return {};

  let result: ResponsivePropConfig;

  if (!isObject(responsiveProp)) {
    result = {
      [breakpointsAliases[0]]: `var(--p-${tokenSubgroup}-${responsiveProp})`,
    };
  } else {
    result = Object.fromEntries(
      Object.entries(responsiveProp).map(([breakpointAlias, aliasOrScale]) => [
        breakpointAlias,
        `var(--p-${tokenSubgroup}-${aliasOrScale})`,
      ]),
    );
  }

  // Prefix each responsive key with the correct token name
  return Object.fromEntries(
    Object.entries(result).map(([breakpointAlias, value]) => [
      `--pc-${componentName}-${componentProp}-${breakpointAlias}`,
      value,
    ]),
  ) as unknown as ResponsiveVariables<T>;
}

export function getResponsiveValue<T = string>(
  componentName: string,
  componentProp: string,
  responsiveProp?: ResponsiveValue<T>,
): ResponsiveVariables<T> {
  if (!responsiveProp) return {};

  if (!isObject(responsiveProp)) {
    return {
      [`--pc-${componentName}-${componentProp}-${breakpointsAliases[0]}`]:
        responsiveProp,
    } as ResponsiveVariables<T>;
  }

  return Object.fromEntries(
    Object.entries(responsiveProp).map(([breakpointAlias, responsiveValue]) => [
      `--pc-${componentName}-${componentProp}-${breakpointAlias}`,
      responsiveValue,
    ]),
  );
}

export function createStyleString(styleObject: Record<string, string>) {
  let styleString = '';
  for (const property in styleObject) {
    if (Object.prototype.hasOwnProperty.call(styleObject, property)) {
      // For CSS custom properties (which start with '--'),
      // they are directly used as property names in the style string.
      styleString += `${property}: ${styleObject[property]}; `;
    }
  }
  return styleString.trim(); // Trim any trailing space
}

export function mapResponsiveProp(
  responsiveProp: ResponsiveProp<boolean>,
  callback: (value: boolean) => string,
): ResponsiveProp<string> {
  if (typeof responsiveProp === 'boolean') {
    return callback(responsiveProp);
  }

  return Object.fromEntries(
    Object.entries(responsiveProp).map(([breakpointsAlias, value]) => [
      breakpointsAlias,
      callback(value),
    ]),
  );
}

export function applyStyles(styles: Record<string, string | number | undefined> | undefined): string {
    if (!styles) return '';
    return createStyleString(sanitizeCustomProperties(styles));
}
```

# utilities/dates.ts

```ts
export interface Range {
    start: Date;
    end: Date;
}

export type Week = (Date | null)[];

const WEEK_LENGTH = 7;

export function getWeeksForMonth(
    month: number,
    year: number,
    weekStartsOn = 0,
): Week[] {
    const firstOfMonth = new Date(year, month, 1);
    const firstDayOfWeek = firstOfMonth.getDay();
    const weeks: Week[] = [[]];

    let currentWeek = weeks[0];
    let currentDate = firstOfMonth;

    const orderedWeekday = getOrderedWeekdays(weekStartsOn);
    for (let i = 0; i < orderedWeekday.indexOf(firstDayOfWeek); i++) {
        currentWeek.push(null);
    }

    while (currentDate.getMonth() === month) {
        if (currentWeek.length === WEEK_LENGTH) {
            currentWeek = [];
            weeks.push(currentWeek);
        }

        currentWeek.push(currentDate);
        currentDate = new Date(year, month, currentDate.getDate() + 1);
    }

    while (currentWeek.length < 7) {
        currentWeek.push(null);
    }

    return weeks;
}

export function dateIsInRange(day: Date | null, range: Range) {
    if (day == null) {
        return false;
    }

    const { start, end } = range;

    return Boolean(start && day > start && end && day < end);
}

export function dateIsSelected(day: Date | null, range: Range) {
    if (day == null) {
        return false;
    }
    const { start, end } = range;

    return Boolean(
        (start && isSameDay(start, day)) || (end && isSameDay(end, day)),
    );
}

export function isSameDay(day1: Date, day2: Date) {
    return (
        day1.getDate() === day2.getDate() &&
        day1.getMonth() === day2.getMonth() &&
        day1.getFullYear() === day2.getFullYear()
    );
}

export function getNewRange(range: Range | undefined, selected: Date): Range {
    if (range == null) {
        return { start: selected, end: selected };
    }

    const { start, end } = range;

    if (end && (isDateAfter(start, end) || isDateBefore(start, end))) {
        return { start: selected, end: selected };
    }

    if (start) {
        if (isDateBefore(selected, start)) {
            return { start: selected, end: selected };
        }
        return { start, end: selected };
    }

    if (end) {
        if (isDateBefore(selected, end)) {
            return { start: selected, end };
        }
        return { start: start || end, end: selected };
    }

    return { start: selected, end: selected };
}

export function getNextDisplayMonth(month: number): number {
    if (month === 11) {
        return 0;
    }
    return month + 1;
}

export function getNextDisplayYear(month: number, year: number): number {
    if (month === 11) {
        return year + 1;
    }
    return year;
}

export function getPreviousDisplayMonth(month: number): number {
    if (month === 0) {
        return 11;
    }
    return month - 1;
}

export function getPreviousDisplayYear(month: number, year: number): number {
    if (month === 0) {
        return year - 1;
    }
    return year;
}

export function isDateAfter(date: Date, dateToCompare: Date) {
    return date.getTime() > dateToCompare.getTime();
}

export function isDateBefore(date: Date, dateToCompare: Date) {
    return date.getTime() < dateToCompare.getTime();
}

export function isDateDisabled(date: Date, datesToCompare: Date[]) {
    return datesToCompare.some((dateToCompare) => {
        return date.getTime() === dateToCompare.getTime();
    });
}

const WEEKDAYS: number[] = [0, 1, 2, 3, 4, 5, 6];

export function getOrderedWeekdays(weekStartsOn: number): number[] {
    const weekDays = [...WEEKDAYS];
    const restOfDays = weekDays.splice(weekStartsOn);
    return [...restOfDays, ...weekDays];
}
```

# utilities/debounce.ts

```ts
interface DebounceSettings {
    leading?: boolean;
    maxWait?: number;
    trailing?: boolean;
}

export function debounce<T extends (this: unknown, ...args: any[]) => any>(
    func: T,
    waitArg?: number,
    options?: DebounceSettings,
) {
    let lastArgs: any;
    let lastThis: any;
    let maxWait: number | undefined;
    let result: any;
    let timerId: any;
    let lastCallTime: any;

    let lastInvokeTime = 0;
    let leading = false;
    let maxing = false;
    let trailing = true;

    // Bypass `requestAnimationFrame` by explicitly setting `wait=0`.
    const useRAF = !waitArg && waitArg !== 0;

    if (typeof func !== 'function') {
        throw new TypeError('Expected a function');
    }
    const wait = waitArg || 0;
    if (typeof options === 'object') {
        leading = Boolean(options.leading);
        maxing = 'maxWait' in options;
        maxWait = maxing ? Math.max(Number(options.maxWait) || 0, wait) : undefined;
        trailing = 'trailing' in options ? Boolean(options.trailing) : trailing;
    }

    function invokeFunc(time: number) {
        const args = lastArgs;
        const thisArg = lastThis;

        lastArgs = undefined;
        lastThis = undefined;
        lastInvokeTime = time;
        result = func.apply(thisArg, args);
        return result;
    }

    function startTimer(pendingFunc: any, wait: number) {
        if (useRAF) {
            cancelAnimationFrame(timerId);
            return requestAnimationFrame(pendingFunc);
        }
        return setTimeout(pendingFunc, wait);
    }

    function cancelTimer(id: number) {
        if (useRAF) {
            return cancelAnimationFrame(id);
        }
        clearTimeout(id);
    }

    function leadingEdge(time: number) {
        // Reset any `maxWait` timer.
        lastInvokeTime = time;
        // Start the timer for the trailing edge.
        timerId = startTimer(timerExpired, wait);
        // Invoke the leading edge.
        return leading ? invokeFunc(time) : result;
    }

    function remainingWait(time: number) {
        const timeSinceLastCall = time - lastCallTime;
        const timeSinceLastInvoke = time - lastInvokeTime;
        const timeWaiting = wait - timeSinceLastCall;

        return maxing && maxWait
            ? Math.min(timeWaiting, maxWait - timeSinceLastInvoke)
            : timeWaiting;
    }

    function shouldInvoke(time: number) {
        const timeSinceLastCall = time - lastCallTime;
        const timeSinceLastInvoke = time - lastInvokeTime;

        // Either this is the first call, activity has stopped and we're at the
        // trailing edge, the system time has gone backwards and we're treating
        // it as the trailing edge, or we've hit the `maxWait` limit.
        return (
            lastCallTime === undefined ||
            timeSinceLastCall >= wait ||
            timeSinceLastCall < 0 ||
            (maxing && maxWait && timeSinceLastInvoke >= maxWait)
        );
    }

    function timerExpired() {
        const time = Date.now();
        if (shouldInvoke(time)) {
            return trailingEdge(time);
        }
        // Restart the timer.
        timerId = startTimer(timerExpired, remainingWait(time));
    }

    function trailingEdge(time: number) {
        timerId = undefined;

        // Only invoke if we have `lastArgs` which means `func` has been
        // debounced at least once.
        if (trailing && lastArgs) {
            return invokeFunc(time);
        }
        // eslint-disable-next-line no-multi-assign
        lastArgs = lastThis = undefined;
        return result;
    }

    function cancel() {
        if (timerId !== undefined) {
            cancelTimer(timerId);
        }
        lastInvokeTime = 0;
        // eslint-disable-next-line no-multi-assign
        lastArgs = lastCallTime = lastThis = timerId = undefined;
    }

    function flush() {
        return timerId === undefined ? result : trailingEdge(Date.now());
    }

    function pending() {
        return timerId !== undefined;
    }

    function debounced(this: unknown, ...args: any[]) {
        const time = Date.now();
        const isInvoking = shouldInvoke(time);

        lastArgs = args;
        // eslint-disable-next-line consistent-this, @typescript-eslint/no-this-alias
        lastThis = this;
        lastCallTime = time;

        if (isInvoking) {
            if (timerId === undefined) {
                return leadingEdge(lastCallTime);
            }
            if (maxing) {
                // Handle invocations in a tight loop.
                timerId = startTimer(timerExpired, wait);
                return invokeFunc(lastCallTime);
            }
        }
        if (timerId === undefined) {
            timerId = startTimer(timerExpired, wait);
        }
        return result;
    }
    debounced.cancel = cancel;
    debounced.flush = flush;
    debounced.pending = pending;
    return debounced;
}
```

# utilities/focus.ts

```ts
import {isElementInViewport} from './is-element-in-viewport.js';

type Filter = (element: Element) => void;
export type MouseUpBlurHandler = (
  event: Event,
) => void;

const FOCUSABLE_SELECTOR =
  'a,frame,iframe,input:not([type=hidden]):not(:disabled),select:not(:disabled),textarea:not(:disabled),button:not([aria-disabled="true"]):not([tabindex="-1"]):not(:disabled),*[tabindex]';
const KEYBOARD_FOCUSABLE_SELECTORS =
  'a,frame,iframe,input:not([type=hidden]):not(:disabled),select:not(:disabled),textarea:not(:disabled),button:not([aria-disabled="true"]):not([tabindex="-1"]):not(:disabled),*[tabindex]:not([tabindex="-1"])';
const MENUITEM_FOCUSABLE_SELECTORS =
  'a[role="menuitem"],frame[role="menuitem"],iframe[role="menuitem"],input[role="menuitem"]:not([type=hidden]):not(:disabled),select[role="menuitem"]:not(:disabled),textarea[role="menuitem"]:not(:disabled),button[role="menuitem"]:not(:disabled),*[tabindex]:not([tabindex="-1"])';
export const handleMouseUpByBlurring: MouseUpBlurHandler = ({currentTarget}) => {
  if (currentTarget instanceof HTMLElement) {
    currentTarget?.blur();
  }
};

export function nextFocusableNode(
  node: HTMLElement,
  filter?: Filter,
): HTMLElement | Element | null {
  const allFocusableElements = [
    ...document.querySelectorAll(FOCUSABLE_SELECTOR),
  ];
  const sliceLocation = allFocusableElements.indexOf(node) + 1;
  const focusableElementsAfterNode = allFocusableElements.slice(sliceLocation);

  for (const focusableElement of focusableElementsAfterNode) {
    if (
      isElementInViewport(focusableElement) &&
      (!filter || (filter && filter(focusableElement)))
    ) {
      return focusableElement;
    }
  }

  return null;
}

export function findFirstFocusableNode(
  element: HTMLElement,
  onlyDescendants = true,
): HTMLElement | null {
  if (!onlyDescendants && matches(element, FOCUSABLE_SELECTOR)) {
    return element;
  }

  return element.querySelector(FOCUSABLE_SELECTOR);
}

// Popover needs to be able to find its activator even if it is disabled, which FOCUSABLE_SELECTOR doesn't support.
export function findFirstFocusableNodeIncludingDisabled(
  element: HTMLElement,
): HTMLElement | null {
  const focusableSelector = `a,button,frame,iframe,input:not([type=hidden]),select,textarea,*[tabindex]`;

  if (matches(element, focusableSelector)) {
    return element;
  }

  return element.querySelector(focusableSelector);
}

export function focusFirstFocusableNode(
  element: HTMLElement,
  onlyDescendants = true,
) {
  findFirstFocusableNode(element, onlyDescendants)?.focus();
}

export function focusNextFocusableNode(node: HTMLElement, filter?: Filter) {
  const nextFocusable = nextFocusableNode(node, filter);
  if (nextFocusable && nextFocusable instanceof HTMLElement) {
    nextFocusable.focus();
    return true;
  }

  return false;
}

export function findFirstKeyboardFocusableNode(
  element: HTMLElement,
  onlyDescendants = true,
): HTMLElement | null {
  if (!onlyDescendants && matches(element, KEYBOARD_FOCUSABLE_SELECTORS)) {
    return element;
  }
  return element.querySelector(KEYBOARD_FOCUSABLE_SELECTORS);
}

export function focusFirstKeyboardFocusableNode(
  element: HTMLElement,
  onlyDescendants = true,
) {
  const firstFocusable = findFirstKeyboardFocusableNode(
    element,
    onlyDescendants,
  );
  if (firstFocusable) {
    firstFocusable.focus();
    return true;
  }

  return false;
}

export function findLastKeyboardFocusableNode(
  element: HTMLElement,
  onlyDescendants = true,
) {
  if (!onlyDescendants && matches(element, KEYBOARD_FOCUSABLE_SELECTORS)) {
    return element;
  }
  const allFocusable = element.querySelectorAll(KEYBOARD_FOCUSABLE_SELECTORS);
  return allFocusable[allFocusable.length - 1] as HTMLElement | null;
}

export function focusLastKeyboardFocusableNode(
  element: HTMLElement,
  onlyDescendants = true,
) {
  const lastFocusable = findLastKeyboardFocusableNode(element, onlyDescendants);
  if (lastFocusable) {
    lastFocusable.focus();
    return true;
  }

  return false;
}

export function wrapFocusPreviousFocusableMenuItem(
  parentElement: HTMLElement,
  currentFocusedElement: HTMLElement,
) {
  const allFocusableChildren = getMenuFocusableDescendants(parentElement);
  const currentItemIdx = getCurrentFocusedElementIndex(
    allFocusableChildren,
    currentFocusedElement,
  );
  if (currentItemIdx === -1) {
    allFocusableChildren[0].focus();
  } else {
    allFocusableChildren[
      (currentItemIdx - 1 + allFocusableChildren.length) %
        allFocusableChildren.length
    ].focus();
  }
}

export function wrapFocusNextFocusableMenuItem(
  parentElement: HTMLElement,
  currentFocusedElement: HTMLElement,
) {
  const allFocusableChildren = getMenuFocusableDescendants(parentElement);
  const currentItemIdx = getCurrentFocusedElementIndex(
    allFocusableChildren,
    currentFocusedElement,
  );
  if (currentItemIdx === -1) {
    allFocusableChildren[0].focus();
  } else {
    allFocusableChildren[
      (currentItemIdx + 1) % allFocusableChildren.length
    ].focus();
  }
}

function getMenuFocusableDescendants(
  element: HTMLElement,
): NodeListOf<HTMLElement> {
  return element.querySelectorAll(
    MENUITEM_FOCUSABLE_SELECTORS,
  ) as NodeListOf<HTMLElement>;
}

function getCurrentFocusedElementIndex(
  allFocusableChildren: NodeListOf<HTMLElement>,
  currentFocusedElement: HTMLElement,
): number {
  let currentItemIdx = 0;

  for (const focusableChild of allFocusableChildren) {
    if (focusableChild === currentFocusedElement) {
      break;
    }
    currentItemIdx++;
  }
  return currentItemIdx === allFocusableChildren.length ? -1 : currentItemIdx;
}

function matches(node: HTMLElement, selector: string) {
  if (node.matches) {
    return node.matches(selector);
  }

  const matches = (node.ownerDocument || document).querySelectorAll(selector);
  let i = matches.length;
  while (--i >= 0 && matches.item(i) !== node) return i > -1;
}
```

# utilities/geometry.ts

```ts
import type { Snippet } from "svelte";

interface RectConfig {
    top?: number;
    left?: number;
    width?: number;
    height?: number;
}

interface Point {
    x: number;
    y: number;
}

export class Rect {
    static get zero(): Rect {
        return new Rect();
    }

    top: number;
    left: number;
    width: number;
    height: number;

    constructor({ top = 0, left = 0, width = 0, height = 0 }: RectConfig = {}) {
        this.top = top;
        this.left = left;
        this.width = width;
        this.height = height;
    }

    get center(): Point {
        return {
            x: this.left + this.width / 2,
            y: this.top + this.height / 2,
        };
    }
}

export function getRectForNode(
    node: Element | Snippet | Window | Document,
): Rect {
    /**
     * NOTE: We cannot do node instanceof Element because it will fail when inside of an iframe.
     * Technically we can do `node instanceof node.ownerDocument.defaultView.Element`but this will
     * fail when node isn't an Element. We might as well try to run `getBoundingClientRect` and then
     * have a fallback for when that breaks.
     */
    try {
        const rect = (node as Element).getBoundingClientRect();

        return new Rect({
            top: rect.top,
            left: rect.left,
            width: rect.width,
            height: rect.height,
        });
    } catch (_) {
        return new Rect({
            width: window.innerWidth,
            height: window.innerHeight,
        });
    }
}
```

# utilities/get.ts

```ts
const OBJECT_NOTATION_MATCHER = /\[(.*?)\]|(\w+)/g;

export function get<T>(
    obj: { [key: string]: any } | undefined,
    keypath: string | string[],
    defaultValue?: T,
): T | any {
    if (obj == null) return undefined;

    const keys = Array.isArray(keypath) ? keypath : getKeypath(keypath);
    let acc = obj;
    // eslint-disable-next-line @typescript-eslint/prefer-for-of
    for (let i = 0; i < keys.length; i++) {
        const val = acc[keys[i]];
        if (val === undefined) return defaultValue;
        acc = val;
    }

    return acc;
}

function getKeypath(str: string) {
    const path = [];
    let result: RegExpExecArray | null;
    while ((result = OBJECT_NOTATION_MATCHER.exec(str))) {
        const [, first, second] = result;
        path.push(first || second);
    }

    return path;
}
```

# utilities/i18n/i18n.ts

```ts
import { get } from '../get.js';
import { merge } from '../merge.js';

const REPLACE_REGEX = /{([^}]*)}/g;

interface TranslationDictionary {
    [key: string]: string | TranslationDictionary;
}

export class I18n {
    private translation: TranslationDictionary = {};

    /**
     * @param translation A locale object or array of locale objects that overrides default translations. If specifying an array then your desired language dictionary should come first, followed by your fallback language dictionaries
     */
    constructor(translation: TranslationDictionary | TranslationDictionary[]) {
        // slice the array to make a shallow copy of it, so we don't accidentally
        // modify the original translation array
        this.translation = Array.isArray(translation)
            ? merge(...translation.slice().reverse())
            : translation;
    }

    translate(
        id: string,
        replacements?: { [key: string]: string | number },
    ): string {
        const text: string = get(this.translation, id, '');

        if (!text) {
            return '';
        }

        if (replacements) {
            return text.replace(REPLACE_REGEX, (match: string) => {
                const replacement: string = match.substring(1, match.length - 1)!;

                if (replacements[replacement] === undefined) {
                    const replacementData = JSON.stringify(replacements);

                    throw new Error(
                        `Error in translation for key '${id}'. No replacement found for key '${replacement}'. The following replacements were passed: '${replacementData}'`,
                    );
                }

                // This could be a string or a number, but JS doesn't mind which it gets
                // and can handle that cast internally. So let it, to save us calling
                // toString() on what's already a string in 90% of cases.
                return replacements[replacement] as string;
            });
        }

        return text;
    }

    translationKeyExists(path: string): boolean {
        return Boolean(get(this.translation, path));
    }
}
```

# utilities/index-provider/context.ts

```ts

import type {SELECT_ALL_ITEMS} from './types.js';

export interface IndexContextType {
  loading?: boolean;
  bulkSelectState?: boolean;
  resourceName: {
    singular: string;
    plural: string;
  };
  selectedItemsCount: typeof SELECT_ALL_ITEMS | number;
  bulkActionsAccessibilityLabel?: string;
  selectMode: boolean;
  paginatedSelectAllText?: string;
  itemCount: number;
  selectable?: boolean;
  hasMoreItems?: boolean;
  condensed?: boolean;
}

export interface IndexRowContextType {
  selectable: boolean;
  selectMode: boolean;
  condensed?: boolean;
}

```

# utilities/index-provider/hooks.ts

```ts
import { useContext } from '$utilities/contexts.js';
import type { IndexContextType, IndexRowContextType } from './context.js';
import { SELECT_ALL_ITEMS } from './types.js';
import type {
  HandleSelectionChange,
  BulkSelectionDataOptions,
} from './types.js';

export const INDEX_SELECTION_CHANGE_CONTEXT_KEY = 'IndexSelectionChangeContext';
export const INDEX_ROW_CONTEXT_KEY = 'IndexRowContext';
export const INDEX_CONTEXT_KEY = 'IndexContext';

/* export function useIndexSelectionChange() {
  const onSelectionChange = useContext<HandleSelectionChange>(INDEX_SELECTION_CHANGE_CONTEXT_KEY);
  if (!onSelectionChange) {
    throw new Error(`Missing IndexProvider context`);
  }
  return onSelectionChange;
} */

/* export function useIndexRow() {
  const indexRow = useContext<IndexRowContextType>(INDEX_ROW_CONTEXT_KEY);
  if (!indexRow) {
    throw new Error(`Missing IndexProvider context`);
  }
  return indexRow;
} */

/* export function useIndexValue() {
  const index = useContext<IndexContextType>(INDEX_CONTEXT_KEY);
  if (!index) {
    throw new Error(`Missing IndexProvider context`);
  }
  return index;
} */

export function useBulkSelectionData({
  selectedItemsCount,
  itemCount,
  hasMoreItems,
  resourceName: passedResourceName,
  defaultPaginatedSelectAllText,
}: BulkSelectionDataOptions) {
  const selectable = Boolean(selectedItemsCount);
  const selectMode = selectedItemsCount === 'All' || selectedItemsCount > 0;

  const defaultResourceName = {
    singular: "Item",
    plural: "Items",
  };

  const resourceName = passedResourceName
    ? passedResourceName
    : defaultResourceName;

  const paginatedSelectAllText = getPaginatedSelectAllText();

  const bulkActionsLabel = getBulkActionsLabel();
  const bulkActionsAccessibilityLabel = getBulkActionsAccessibilityLabel();

  let bulkSelectState: boolean | undefined = undefined;
  if (!selectedItemsCount || selectedItemsCount === 0) {
    bulkSelectState = undefined;
  } else if (
    selectedItemsCount === SELECT_ALL_ITEMS ||
    selectedItemsCount === itemCount
  ) {
    bulkSelectState = true;
  }

  return {
    paginatedSelectAllText,
    bulkActionsLabel,
    bulkActionsAccessibilityLabel,
    resourceName,
    selectMode,
    bulkSelectState,
    selectable,
  };

  function getPaginatedSelectAllText() {
    if (!selectable || !hasMoreItems) {
      return;
    }

    if (selectedItemsCount === SELECT_ALL_ITEMS) {
      if (defaultPaginatedSelectAllText) {
        return defaultPaginatedSelectAllText;
      }
      return `All ${itemCount}+ ${resourceName.plural} are selected`;
    }
  }

  function getBulkActionsLabel() {
    const selectedItemsCountLabel =
      selectedItemsCount === SELECT_ALL_ITEMS
        ? `${itemCount}+`
        : selectedItemsCount;

    return `${selectedItemsCount} selected`;
  }

  function getBulkActionsAccessibilityLabel() {
    const totalItemsCount = itemCount;
    const allSelected = selectedItemsCount === totalItemsCount;

    if (totalItemsCount === 1 && allSelected) {
      return `Deselect ${resourceName.singular}`;
    } else if (totalItemsCount === 1) {
      return `Select ${resourceName.singular}`;
    } else if (allSelected) {
      return `Deselect all ${resourceName.plural}`;
    } else {
      return `Select all ${resourceName.plural}`;
    }
  }
}
```

# utilities/index-provider/types.ts

```ts
import type { Snippet } from "svelte";
import type { Range } from "../../use/use-index-resource-state.svelte.js";

export type IndexSelectedItems = string[] | 'All';

export const SELECT_ALL_ITEMS = 'All';

export enum SelectionType {
    All = 'all',
    Page = 'page',
    Multi = 'multi',
    Single = 'single',
    Range = 'range',
}

//export type Range = [number, number];

export interface IndexProviderProps {
    children?: Snippet;
    selectable?: boolean;
    itemCount: number;
    selectedItemsCount?: typeof SELECT_ALL_ITEMS | number;
    resourceName?: {
        singular: string;
        plural: string;
    };
    loading?: boolean;
    hasMoreItems?: boolean;
    condensed?: boolean;
    onSelectionChange?(
        selectionType: SelectionType,
        toggleType: boolean,
        selection?: string | Range,
        position?: number,
    ): void;
    paginatedSelectAllText?: string;
}

export type HandleSelectionChange = (
    selectionType: SelectionType,
    toggleType: boolean,
    selection?: string | Range,
    sortOrder?: number,
) => void;

export interface BulkSelectionDataOptions {
    selectedItemsCount: number | typeof SELECT_ALL_ITEMS;
    itemCount: number;
    hasMoreItems?: boolean;
    resourceName?: {
        singular: string;
        plural: string;
    };
    defaultPaginatedSelectAllText?: string;
}

export interface HandleBulkSelectionOptions {
    onSelectionChange?(
        selectionType: SelectionType,
        toggleType: boolean,
        selection?: string | Range,
    ): void;
}
```

# utilities/index-table/context.ts

```ts

export interface RowContextType {
  itemId?: string;
  selected?: boolean;
  disabled?: boolean;
  position?: number;
  onInteraction?: (event: MouseEvent | KeyboardEvent) => void;
}

export const ROW_CONTEXT_KEY = 'RowContext';
export const ROW_HOVERED_CONTEXT_KEY = 'RowHoveredContext';
export const SCROLL_CONTEXT_KEY = 'ScrollContext';

export interface ScrollContextType {
  scrollableContainer: HTMLDivElement | null;
  canScrollLeft: boolean;
  canScrollRight: boolean;
}

export const scrollDefaultContext = {
  scrollableContainer: null,
  canScrollLeft: false,
  canScrollRight: false,
};

```

# utilities/index-table/hooks.ts

```ts
import { useContext } from "$utilities/contexts.js";
import { ROW_CONTEXT_KEY, ROW_HOVERED_CONTEXT_KEY, SCROLL_CONTEXT_KEY, type RowContextType, type ScrollContextType } from "./context.js";

/* export function useRowHovered() {
  const hovered = useContext<boolean | undefined>(ROW_HOVERED_CONTEXT_KEY);
  return hovered;
} */

/* export function useContainerScroll() {
  const scrolledContainerRef = useContext<ScrollContextType>(SCROLL_CONTEXT_KEY);
  return scrolledContainerRef;
} */
```

# utilities/is-element-in-viewport.ts

```ts
export function isElementInViewport(element: Element) {
    const { top, left, bottom, right } = element.getBoundingClientRect();
    const window = element.ownerDocument.defaultView || globalThis.window;

    return (
        top >= 0 &&
        right <= window.innerWidth &&
        bottom <= window.innerHeight &&
        left >= 0
    );
}
```

# utilities/is-input-focused.ts

```ts
enum EditableTarget {
    Input = 'INPUT',
    Textarea = 'TEXTAREA',
    Select = 'SELECT',
    ContentEditable = 'contenteditable',
}

export function isInputFocused() {
    if (document == null || document.activeElement == null) {
        return false;
    }

    const { tagName } = document.activeElement;
    return (
        tagName === EditableTarget.Input ||
        tagName === EditableTarget.Textarea ||
        tagName === EditableTarget.Select ||
        document.activeElement.hasAttribute(EditableTarget.ContentEditable)
    );
}
```

# utilities/is-interface.ts

```ts
import type { Component, Snippet } from "svelte";

export function isInterface<T extends object>(
    x: T | Component | Snippet<any> | string | number | boolean | null | undefined
): x is T {
    // Check if x is an object, not null.
    // Functions are objects in JS, but `typeof x === 'function'` would be true for them.
    // This check correctly identifies plain objects.
    if (typeof x === 'object' && x !== null) {
        return true; // It's a non-null object, so it matches `T extends object`.
    }
    return false;
}
```

# utilities/is-object.ts

```ts
export function isObject(value: any) {
    const type = typeof value;
    return value != null && (type === 'object' || type === 'function');
}
```

# utilities/link/types.ts

```ts
import type { Target } from "$utilities/types.js";
import type { Component, Snippet } from "svelte";

export interface LinkLikeComponentProps {
  /** The url to link to */
  url: string;
  /**	The content to display inside the link */
  children?: Snippet;
  /** Makes the link open in a new tab */
  external?: boolean;
  /** Where to display the url */
  target?: Target;
  /** Makes the browser download the url instead of opening it. Provides a hint for the downloaded filename if it is a string value. */
  download?: string | boolean;
  [key: string]: any;
}

export type LinkLikeComponent = Component<LinkLikeComponentProps>;

```

# utilities/listbox/hooks.ts

```ts
import { useContext } from "$utilities/contexts.js";
import { LISTBOX_CONTEXT_KEY, type ListboxContextType } from "./types.js";

export function useListbox() {
    const listbox = useContext<ListboxContextType>(LISTBOX_CONTEXT_KEY);

    if (!listbox) {
        throw new Error(
            'No Listbox was provided. Listbox components must be wrapped in a Listbox',
        );
    }

    return listbox;
}
```

# utilities/listbox/types.ts

```ts
export interface NavigableOption {
    domId: string;
    value: string;
    element: HTMLElement;
    disabled: boolean;
    isAction?: boolean;
    index?: number;
}

export const LISTBOX_CONTEXT_KEY = 'ListboxContext';
export const WITHIN_LISTBOX_CONTEXT_KEY = 'WithinListboxContext';
export const ACTION_CONTEXT_KEY = 'ActionContext';
export const MAPPED_ACTION_CONTEXT_KEY = 'MappedActionContext';

export interface MappedActionContextType {
    role?: string;
    url?: string;
    external?: boolean;
    onAction?(): void;
    destructive?: boolean;
}

export interface ListboxContextType {
    onOptionSelect(option: NavigableOption): void;
    setLoading(label?: string): void;
}
```

# utilities/listbox/utilities.ts

```ts
export function scrollOptionIntoView(
    option: HTMLElement,
    scrollable: HTMLElement,
) {
    const listTop = scrollable.scrollTop;
    const listBottom = listTop + scrollable.clientHeight;
    const { offsetHeight: optionHeight } = option;
    const { offsetTop: optionTop } = option;
    const optionBottom = optionTop + optionHeight;
    const isVisible = optionTop > listTop && optionBottom < listBottom;

    if (!isVisible) {
        let top = 0;
        if (optionBottom > listBottom) {
            top = optionBottom + optionHeight * 0.85 - listBottom;
        } else if (optionTop < listTop) {
            top = optionTop - optionHeight * 0.15 - listTop;
        }

        requestAnimationFrame(() => {
            scrollable.scrollBy({ top, behavior: 'auto' });
        });
    }
}
```

# utilities/math.ts

```ts
import { Rect } from './geometry.js';

export type PreferredPosition = 'above' | 'below' | 'mostSpace' | 'cover';

export type PreferredAlignment = 'left' | 'center' | 'right';

export interface Margins {
    activator: number;
    container: number;
    horizontal: number;
}

export function calculateVerticalPosition(
    activatorRect: Rect,
    overlayRect: Rect,
    overlayMargins: Margins,
    scrollableContainerRect: Rect,
    containerRect: Rect,
    preferredPosition: PreferredPosition,
    fixed: boolean | undefined,
    topBarOffset = 0,
) {
    const activatorTop = activatorRect.top;
    const activatorBottom = activatorTop + activatorRect.height;
    const spaceAbove = activatorRect.top - topBarOffset;
    const spaceBelow =
        containerRect.height - activatorRect.top - activatorRect.height;

    const desiredHeight = overlayRect.height;
    const verticalMargins = overlayMargins.activator + overlayMargins.container;
    const minimumSpaceToScroll = overlayMargins.container;
    const distanceToTopScroll =
        activatorRect.top - Math.max(scrollableContainerRect.top, 0);
    const distanceToBottomScroll =
        containerRect.top +
        Math.min(
            containerRect.height,
            scrollableContainerRect.top + scrollableContainerRect.height,
        ) -
        (activatorRect.top + activatorRect.height);
    const enoughSpaceFromTopScroll = distanceToTopScroll >= minimumSpaceToScroll;
    const enoughSpaceFromBottomScroll =
        distanceToBottomScroll >= minimumSpaceToScroll;
    const heightIfAbove = Math.min(spaceAbove, desiredHeight);
    const heightIfBelow = Math.min(spaceBelow, desiredHeight);
    const heightIfAboveCover = Math.min(
        spaceAbove + activatorRect.height,
        desiredHeight,
    );
    const heightIfBelowCover = Math.min(
        spaceBelow + activatorRect.height,
        desiredHeight,
    );
    const containerRectTop = fixed ? 0 : containerRect.top;

    const positionIfAbove = {
        height: heightIfAbove - verticalMargins,
        top: activatorTop + containerRectTop - heightIfAbove,
        positioning: 'above',
    };

    const positionIfBelow = {
        height: heightIfBelow - verticalMargins,
        top: activatorBottom + containerRectTop,
        positioning: 'below',
    };

    const positionIfCoverBelow = {
        height: heightIfBelowCover - verticalMargins,
        top: activatorTop + containerRectTop,
        positioning: 'cover',
    };

    const positionIfCoverAbove = {
        height: heightIfAboveCover - verticalMargins,
        top:
            activatorTop +
            containerRectTop -
            heightIfAbove +
            activatorRect.height +
            verticalMargins,
        positioning: 'cover',
    };

    if (preferredPosition === 'above') {
        return (enoughSpaceFromTopScroll ||
            (distanceToTopScroll >= distanceToBottomScroll &&
                !enoughSpaceFromBottomScroll)) &&
            (spaceAbove > desiredHeight || spaceAbove > spaceBelow)
            ? positionIfAbove
            : positionIfBelow;
    }

    if (preferredPosition === 'below') {
        return (enoughSpaceFromBottomScroll ||
            (distanceToBottomScroll >= distanceToTopScroll &&
                !enoughSpaceFromTopScroll)) &&
            (spaceBelow > desiredHeight || spaceBelow > spaceAbove)
            ? positionIfBelow
            : positionIfAbove;
    }

    if (preferredPosition === 'cover') {
        return (enoughSpaceFromBottomScroll ||
            (distanceToBottomScroll >= distanceToTopScroll &&
                !enoughSpaceFromTopScroll)) &&
            (spaceBelow + activatorRect.height > desiredHeight ||
                spaceBelow > spaceAbove)
            ? positionIfCoverBelow
            : positionIfCoverAbove;
    }

    if (enoughSpaceFromTopScroll && enoughSpaceFromBottomScroll) {
        return spaceAbove > spaceBelow ? positionIfAbove : positionIfBelow;
    }

    return distanceToTopScroll > minimumSpaceToScroll
        ? positionIfAbove
        : positionIfBelow;
}

export function calculateHorizontalPosition(
    activatorRect: Rect,
    overlayRect: Rect,
    containerRect: Rect,
    overlayMargins: Margins,
    preferredAlignment: PreferredAlignment,
) {
    const maximum = containerRect.width - overlayRect.width;

    if (preferredAlignment === 'left') {
        return Math.min(
            maximum,
            Math.max(0, activatorRect.left - overlayMargins.horizontal),
        );
    } else if (preferredAlignment === 'right') {
        const activatorRight =
            containerRect.width - (activatorRect.left + activatorRect.width);

        return Math.min(
            maximum,
            Math.max(0, activatorRight - overlayMargins.horizontal),
        );
    }

    return Math.min(
        maximum,
        Math.max(0, activatorRect.center.x - overlayRect.width / 2),
    );
}

export function rectIsOutsideOfRect(inner: Rect, outer: Rect) {
    const { center } = inner;

    return center.y < outer.top || center.y > outer.top + outer.height;
}

export function intersectionWithViewport(
    rect: Rect,
    viewport: Rect = windowRect(),
) {
    const top = Math.max(rect.top, 0);
    const left = Math.max(rect.left, 0);
    const bottom = Math.min(rect.top + rect.height, viewport.height);
    const right = Math.min(rect.left + rect.width, viewport.width);

    return new Rect({
        top,
        left,
        height: bottom - top,
        width: right - left,
    });
}

export function windowRect(node?: HTMLElement) {
    const document = node?.ownerDocument || globalThis.document;
    const window = document.defaultView || globalThis.window;

    return new Rect({
        top: window.scrollY,
        left: window.scrollX,
        height: window.innerHeight,
        width: document.body.clientWidth,
    });
}
```

# utilities/merge.ts

```ts
// Unfortunately, this is how we have to type this at the moment.
// There is currently a proposal to support variadic kinds.
// https://github.com/Microsoft/TypeScript/issues/5453
export function merge<TSource1, TSource2>(
    source1: TSource1,
    source2: TSource2,
): TSource1 & TSource2;
export function merge<TSource1, TSource2, TSource3>(
    source1: TSource1,
    source2: TSource2,
    source3: TSource3,
): TSource1 & TSource2 & TSource3;
export function merge<TSource1, TSource2, TSource3, TSource4>(
    source1: TSource1,
    source2: TSource2,
    source3: TSource3,
    source4: TSource4,
): TSource1 & TSource2 & TSource3 & TSource4;
export function merge<TSource1, TSource2, TSource3, TSource4, TSource5>(
    source1: TSource1,
    source2: TSource2,
    source3: TSource3,
    source4: TSource4,
    source5: TSource5,
): TSource1 & TSource2 & TSource3 & TSource4 & TSource5;
export function merge<TResult>(...objs: any[]): TResult;
export function merge<TSource1, TSource2, TSource3, TSource4, TSource5>(
    ...objs: (TSource1 | TSource2 | TSource3 | TSource4 | TSource5)[]
) {
    let final = {};

    for (const obj of objs) {
        final = mergeRecursively(final, obj as any);
    }

    return final;
}

interface GeneralObject {
    [key: string]: any;
}

function mergeRecursively(inputObjA: GeneralObject, objB: GeneralObject) {
    const objA: GeneralObject = Array.isArray(inputObjA)
        ? [...inputObjA]
        : { ...inputObjA };
    for (const key in objB) {
        if (!Object.prototype.hasOwnProperty.call(objB, key)) {
            continue;
        } else if (isMergeableValue(objB[key]) && isMergeableValue(objA[key])) {
            objA[key] = mergeRecursively(objA[key], objB[key]);
        } else {
            objA[key] = objB[key];
        }
    }

    return objA;
}

function isMergeableValue(value: any) {
    return value !== null && typeof value === 'object';
}
```

# utilities/noop.ts

```ts
export function noop() {}
```

# utilities/options.ts

```ts
import type {Descriptor, SectionDescriptor} from './types.js';

export function isSection(arr: Descriptor[]): arr is SectionDescriptor[] {
  return (
    typeof arr[0] === 'object' &&
    Object.prototype.hasOwnProperty.call(arr[0], 'options')
  );
}

```

# utilities/portals/types.ts

```ts
import type { PortalsContainerElement } from "$utilities/contexts.js";

export interface PortalsManager {
    container: PortalsContainerElement;
}

export const PORTALS_MANAGER_CONTEXT_KEY = 'PortalsManager';
```

# utilities/props-with-children.ts

```ts
import type { Snippet } from "svelte";

export type PropsWithChildren<P = unknown> = P & { children?: Snippet | undefined };
```

# utilities/roundNumberToDecimalPlaces.ts

```ts
// Because everything is a float in JS, Number.toFixed sometimes rounds in the
// "wrong" direction because of float imprecision. For instance:
// `(1.005).toFixed(2)` is `1.00`, NOT `1.01` because 1.005 in floating point is
// actually 1.004999995. By using exponentiation tricks here we can work around
// this imprecision, so `roundNumberToDecimalPlaces(1.005)` returns the expected
// value of `1.01`
// See https://www.jacklmoore.com/notes/rounding-in-javascript/
export function roundNumberToDecimalPlaces(value: number, decimals: number) {
  const exponent = Number(`${value}e${decimals}`);
  const roundedExponent = Math.round(exponent);
  const numberWithDecimalPlaces = Number(`${roundedExponent}e-${decimals}`);
  return numberWithDecimalPlaces;
}

```

# utilities/set-root-property.ts

```ts
export function setRootProperty(
    name: string,
    value: string,
    node?: HTMLElement,
) {
    if (!document) return;

    const element = node || document.documentElement;
    element.style.setProperty(name, value);
}
```

# utilities/shared.ts

```ts
export const scrollable = {
    props: { 'data-polaris-scrollable': true },
    selector: '[data-polaris-scrollable]',
};

export const overlay = {
    props: { 'data-polaris-overlay': true },
    selector: '[data-polaris-overlay]',
};

export const layer = {
    props: { 'data-polaris-layer': true },
    selector: '[data-polaris-layer]',
};

export const unstyled = {
    props: { 'data-polaris-unstyled': true },
    selector: '[data-polaris-unstyled]',
};

export const dataPolarisTopBar = {
    props: { 'data-polaris-top-bar': true },
    selector: '[data-polaris-top-bar]',
};

export const headerCell = {
    props: { 'data-polaris-header-cell': true },
    selector: '[data-polaris-header-cell]',
};

export const portal = {
    props: ['data-portal-id'],
    selector: '[data-portal-id]',
};

export const DATA_ATTRIBUTE = {
    overlay,
    layer,
};
```

# utilities/sticky-manager/context.ts

```ts
export const STICKY_MANAGER_CONTEXT_KEY = 'StickyManagerContext';
```

# utilities/sticky-manager/hooks.ts

```ts
import { useContext } from "$utilities/contexts.js";
import { STICKY_MANAGER_CONTEXT_KEY } from "./context.js";
import type { StickyManager } from "./sticky-manager.js";

/* export function useStickyManager() {
    const stickyManager = useContext<StickyManager>(STICKY_MANAGER_CONTEXT_KEY);

    if (!stickyManager) {
        throw new Error('No StickyManager was provided.');
    }

    return stickyManager;
} */
```

# utilities/sticky-manager/sticky-manager.ts

```ts
import { themeDefault } from '@shopify/polaris-tokens';
import { getRectForNode } from '../geometry.js';
import type { Rect } from '../geometry.js';
import { debounce } from '$utilities/debounce.js';
import { stackedContent } from '$lib/use/use-breakpoints.svelte.js';
import { dataPolarisTopBar, scrollable } from '$utilities/shared.js';

interface StickyItem {
    /** Node of the sticky element */
    stickyNode: HTMLElement;
    /** Placeholder element */
    placeHolderNode: HTMLElement;
    /** Element outlining the fixed position boundaries */
    boundingElement?: HTMLElement | null;
    /** Offset vertical spacing from the top of the scrollable container */
    offset: boolean;
    /** Should the element remain in a fixed position when the layout is stacked (smaller screens)  */
    disableWhenStacked: boolean;
    /** Method to handle positioning */
    handlePositioning(
        stick: boolean,
        top?: number,
        left?: number,
        width?: string | number,
    ): void;
}

const SIXTY_FPS = 1000 / 60;


export class StickyManager {
    private stickyItems: StickyItem[] = [];
    private stuckItems: StickyItem[] = [];
    private container: Document | HTMLElement | null = null;
    private topBarOffset = 0;

    private handleResize = debounce(
        () => {
            this.manageStickyItems();
        },
        SIXTY_FPS,
        { leading: true, trailing: true, maxWait: SIXTY_FPS },
    );

    private handleScroll = debounce(
        () => {
            this.manageStickyItems();
        },
        SIXTY_FPS,
        { leading: true, trailing: true, maxWait: SIXTY_FPS },
    );

    constructor(container?: Document | HTMLElement) {
        if (container) {
            this.setContainer(container);
        }
    }

    registerStickyItem(stickyItem: StickyItem): void {
        this.stickyItems.push(stickyItem);
    }

    unregisterStickyItem(nodeToRemove: HTMLElement) {
        const nodeIndex = this.stickyItems.findIndex(
            ({ stickyNode }) => nodeToRemove === stickyNode,
        );
        this.stickyItems.splice(nodeIndex, 1);
    }

    getStickyItem(node: HTMLElement) {
        return this.stickyItems.find(({ stickyNode }) => node === stickyNode);
    }

    setContainer(el: Document | HTMLElement) {
        this.container = el;
        if (isDocument(el)) {
            this.setTopBarOffset(el);
        }
        this.container.addEventListener('scroll', this.handleScroll);
        window.addEventListener('resize', this.handleResize);
        this.manageStickyItems();
    }

    removeScrollListener() {
        if (this.container) {
            this.container.removeEventListener('scroll', this.handleScroll);
            window.removeEventListener('resize', this.handleResize);
        }
    }

    private manageStickyItems() {
        if (this.stickyItems.length <= 0) {
            return;
        }
        if (!this.container) {
            return;
        }

        const scrollTop = this.container ? scrollTopFor(this.container) : 0;
        const containerTop = getRectForNode(this.container).top + this.topBarOffset;

        this.stickyItems.forEach((stickyItem) => {
            const { handlePositioning } = stickyItem;

            const { sticky, top, left, width } = this.evaluateStickyItem(
                stickyItem,
                scrollTop,
                containerTop,
            );

            this.updateStuckItems(stickyItem, sticky);

            handlePositioning(sticky, top, left, width);
        });
    }

    private evaluateStickyItem(
        stickyItem: StickyItem,
        scrollTop: number,
        containerTop: number,
    ): {
        sticky: boolean;
        top: number;
        left: number;
        width: string | number;
    } {
        const {
            stickyNode,
            placeHolderNode,
            boundingElement,
            offset,
            disableWhenStacked,
        } = stickyItem;

        if (disableWhenStacked && stackedContent().matches) {
            return {
                sticky: false,
                top: 0,
                left: 0,
                width: 'auto',
            };
        }

        const stickyOffset = offset
            ? this.getOffset(stickyNode) +
            parseInt(
                // Important: This will not update when the active theme changes.
                // Update this to `useTheme` once converted to a function component.
                themeDefault.space['space-500'],
                10,
            )
            : this.getOffset(stickyNode);

        const scrollPosition = scrollTop + stickyOffset;
        const placeHolderNodeCurrentTop =
            placeHolderNode.getBoundingClientRect().top - containerTop + scrollTop;
        const top = containerTop + stickyOffset;
        const width = placeHolderNode.getBoundingClientRect().width;
        const left = placeHolderNode.getBoundingClientRect().left;

        let sticky: boolean;

        if (boundingElement == null) {
            sticky = scrollPosition >= placeHolderNodeCurrentTop;
        } else {
            const stickyItemHeight =
                stickyNode.getBoundingClientRect().height ||
                stickyNode.firstElementChild?.getBoundingClientRect().height ||
                0;
            const stickyItemBottomPosition =
                boundingElement.getBoundingClientRect().bottom -
                stickyItemHeight +
                scrollTop -
                containerTop;

            sticky =
                scrollPosition >= placeHolderNodeCurrentTop &&
                scrollPosition < stickyItemBottomPosition;
        }

        return {
            sticky,
            top,
            left,
            width,
        };
    }

    private updateStuckItems(item: StickyItem, sticky: boolean) {
        const { stickyNode } = item;
        if (sticky && !this.isNodeStuck(stickyNode)) {
            this.addStuckItem(item);
        } else if (!sticky && this.isNodeStuck(stickyNode)) {
            this.removeStuckItem(item);
        }
    }

    private addStuckItem(stickyItem: StickyItem) {
        this.stuckItems.push(stickyItem);
    }

    private removeStuckItem(stickyItem: StickyItem) {
        const { stickyNode: nodeToRemove } = stickyItem;
        const nodeIndex = this.stuckItems.findIndex(
            ({ stickyNode }) => nodeToRemove === stickyNode,
        );
        this.stuckItems.splice(nodeIndex, 1);
    }

    private getOffset(node: HTMLElement) {
        if (this.stuckItems.length === 0) {
            return 0;
        }

        let offset = 0;
        let count = 0;
        const stuckNodesLength = this.stuckItems.length;
        const nodeRect = getRectForNode(node);

        while (count < stuckNodesLength) {
            const stuckNode = this.stuckItems[count].stickyNode;
            if (stuckNode !== node) {
                const stuckNodeRect = getRectForNode(stuckNode);
                if (!horizontallyOverlaps(nodeRect, stuckNodeRect)) {
                    offset += getRectForNode(stuckNode).height;
                }
            } else {
                break;
            }
            count++;
        }

        return offset;
    }

    private isNodeStuck(node: HTMLElement): boolean {
        const nodeFound = this.stuckItems.findIndex(
            ({ stickyNode }) => node === stickyNode,
        );

        return nodeFound >= 0;
    }

    private setTopBarOffset(container: Document) {
        const topbarElement = container.querySelector(
            `:not(${scrollable.selector}) ${dataPolarisTopBar.selector}`,
        );
        this.topBarOffset = topbarElement ? topbarElement.clientHeight : 0;
    }
}

function isDocument(node: HTMLElement | Document): node is Document {
    return node === document;
}

function scrollTopFor(container: HTMLElement | Document) {
    return isDocument(container)
        ? document.body.scrollTop || document.documentElement.scrollTop
        : container.scrollTop;
}

function horizontallyOverlaps(rect1: Rect, rect2: Rect) {
    const rect1Left = rect1.left;
    const rect1Right = rect1.left + rect1.width;
    const rect2Left = rect2.left;
    const rect2Right = rect2.left + rect2.width;

    return rect2Right < rect1Left || rect1Right < rect2Left;
}
```

# utilities/types.ts

```ts
import type { Component, Snippet } from 'svelte';
export type Target = '_blank' | '_self' | '_parent' | '_top';

export type IconSource = Component;

export type VueNode = string | number | boolean | Snippet | Element | Function | null | undefined;

export type NonEmptyArray<T> = [T, ...T[]];

export interface BaseButton {
  /** A unique identifier for the button */
  id?: string;
  /** A destination to link to, rendered in the href attribute of a link */
  url?: string;
  /** Forces url to open in a new tab */
  external?: boolean;
  /** Where to display the url */
  target?: Target;
  /** Tells the browser to download the url instead of opening it. Provides a hint for the downloaded filename if it is a string value */
  download?: string | boolean;
  /** Allows the button to submit a form */
  submit?: boolean;
  /** Disables the button, disallowing merchant interaction */
  disabled?: boolean;
  /** Replaces button text with a spinner while a background action is being performed */
  loading?: boolean;
  /** Sets the button in a pressed state */
  pressed?: boolean;
  /** Visually hidden text for screen readers */
  accessibilityLabel?: string;
  /** A valid WAI-ARIA role to define the semantic value of this element */
  role?: string;
  /** Id of the element the button controls */
  ariaControls?: string;
  /** Tells screen reader the controlled element is expanded */
  ariaExpanded?: boolean;
  /** Indicates the ID of the element that describes the button */
  ariaDescribedBy?: string;
  /** Indicates the current checked state of the button when acting as a toggle or switch */
  ariaChecked?: 'false' | 'true';
  /** Callback when clicked */
  onClick?(): unknown;
  /** Callback when button becomes focused */
  onFocus?(): void;
  /** Callback when focus leaves button */
  onBlur?(): void;
  /** Callback when a keypress event is registered on the button */
  onKeyPress?(event: KeyboardEvent): void;
  /** Callback when a keyup event is registered on the button */
  onKeyUp?(event: KeyboardEvent): void;
  /** Callback when a keydown event is registered on the button */
  onKeyDown?(event: KeyboardEvent): void;
  /** Callback when mouse enter */
  onMouseEnter?(): void;
  /** Callback when element is touched */
  onTouchStart?(): void;
  /** Callback when pointerdown event is being triggered */
  onPointerDown?(event: PointerEvent): void;
  tiggerProps?: any
}

export interface Action {
  /** A unique identifier for the action */
  id?: string;
  /** Content the action displays */
  content?: string;
  /** Visually hidden text for screen readers */
  accessibilityLabel?: string;
  /** A destination to link to, rendered in the action */
  url?: string;
  /** Forces url to open in a new tab */
  external?: boolean;
  /** Where to display the url */
  target?: Target;
  /** Callback when an action takes place */
  onAction?(): void;
  /** Callback when mouse enter */
  onMouseEnter?(): void;
  /** Callback when element is touched */
  onTouchStart?(): void;
}

export type Error = string | Element | (string | Element)[];

export enum Key {
  Backspace = 8,
  Tab = 9,
  Enter = 13,
  Shift = 16,
  Ctrl = 17,
  Alt = 18,
  Pause = 19,
  CapsLock = 20,
  Escape = 27,
  Space = 32,
  PageUp = 33,
  PageDown = 34,
  End = 35,
  Home = 36,
  LeftArrow = 37,
  UpArrow = 38,
  RightArrow = 39,
  DownArrow = 40,
  Insert = 45,
  Delete = 46,
  Key0 = 48,
  Key1 = 49,
  Key2 = 50,
  Key3 = 51,
  Key4 = 52,
  Key5 = 53,
  Key6 = 54,
  Key7 = 55,
  Key8 = 56,
  Key9 = 57,
  KeyA = 65,
  KeyB = 66,
  KeyC = 67,
  KeyD = 68,
  KeyE = 69,
  KeyF = 70,
  KeyG = 71,
  KeyH = 72,
  KeyI = 73,
  KeyJ = 74,
  KeyK = 75,
  KeyL = 76,
  KeyM = 77,
  KeyN = 78,
  KeyO = 79,
  KeyP = 80,
  KeyQ = 81,
  KeyR = 82,
  KeyS = 83,
  KeyT = 84,
  KeyU = 85,
  KeyV = 86,
  KeyW = 87,
  KeyX = 88,
  KeyY = 89,
  KeyZ = 90,
  LeftMeta = 91,
  RightMeta = 92,
  Select = 93,
  Numpad0 = 96,
  Numpad1 = 97,
  Numpad2 = 98,
  Numpad3 = 99,
  Numpad4 = 100,
  Numpad5 = 101,
  Numpad6 = 102,
  Numpad7 = 103,
  Numpad8 = 104,
  Numpad9 = 105,
  Multiply = 106,
  Add = 107,
  Subtract = 109,
  Decimal = 110,
  Divide = 111,
  F1 = 112,
  F2 = 113,
  F3 = 114,
  F4 = 115,
  F5 = 116,
  F6 = 117,
  F7 = 118,
  F8 = 119,
  F9 = 120,
  F10 = 121,
  F11 = 122,
  F12 = 123,
  NumLock = 144,
  ScrollLock = 145,
  Semicolon = 186,
  Equals = 187,
  Comma = 188,
  Dash = 189,
  Period = 190,
  ForwardSlash = 191,
  GraveAccent = 192,
  OpenBracket = 219,
  BackSlash = 220,
  CloseBracket = 221,
  SingleQuote = 222,
}

export interface DisableableAction extends Action {
  /** Whether or not the action is disabled */
  disabled?: boolean;
}

export interface BadgeAction {
  badge?: {
    tone: 'new';
    content: string;
  };
}

export interface DestructableAction extends Action {
  /** Destructive action */
  destructive?: boolean;
}

export interface IconableAction extends Action {
  /** Source of the icon */
  icon?: IconSource;
}

export interface TooltipAction {
  /** Text content to render in a tooltip */
  helpText?: VueNode;
}

export interface LoadableAction extends Action {
  /** Should a spinner be displayed */
  loading?: boolean;
}

export interface OutlineableAction extends Action {
  /** Should action be displayed as an outlined button */
  outline?: boolean;
}

export interface PlainAction extends Action {
  /** Should action be displayed as a plain link */
  plain?: boolean;
}

export interface ComplexAction
  extends Action,
    DisableableAction,
    DestructableAction,
    IconableAction,
    OutlineableAction,
    LoadableAction,
    PlainAction {}

export interface MenuActionDescriptor extends ComplexAction, TooltipAction {
  /** Zero-indexed numerical position. Overrides the action's order in the menu */
  index?: number;
}

export interface MenuGroupDescriptor extends BadgeAction {
  /** Menu group title */
  title: string;
  /** List of actions */
  actions: ActionListItemDescriptor[];
  /** Icon to display */
  icon?: IconableAction['icon'];
  /** Action details */
  details?: VueNode;
  /** Disables action button */
  disabled?: boolean;
  /** Zero-indexed numerical position. Overrides the group's order in the menu. */
  index?: number;
  /** Callback when any action takes place */
  onActionAnyItem?: ActionListItemDescriptor['onAction'];
  /** Callback when the menu is clicked */
  onClick?(openActions: () => void): void;
}

export interface LinkAction {
  /** A unique identifier for the action */
  id?: string;
  /** Content the action displays */
  content?: string;
  /** Visually hidden text for screen readers */
  accessibilityLabel?: string;
  /** A destination to link to */
  url: string;
}

export interface BaseCallbackAction {
  /** A unique identifier for the action */
  id?: string;
  /** Content the action displays */
  content?: string;
  /** Visually hidden text for screen readers */
  accessibilityLabel?: string;
  /** Callback when an action takes place */
  onAction(): void;
}

export interface CallbackAction extends BaseCallbackAction {}

export interface ActionListItemDescriptor
  extends DisableableAction,
    DestructableAction {
  /** Visually hidden text for screen readers */
  accessibilityLabel?: string;
  /** @deprecated Badge component */
  badge?: {
    tone: 'new';
    content: string;
  };
  /** Prefix source */
  prefix?: VueNode;
  /** Suffix source */
  suffix?: VueNode;
  /** Additional hint text to display with item */
  helpText?: string;
  /** @deprecated Source of the icon */
  icon?: IconSource;
  /** @deprecated Image source */
  image?: string;
  /** @deprecated Add an ellipsis suffix to action content. ellipsis appends `...` without truncating. Use truncate instead. */
  ellipsis?: boolean;
  /** Truncate the action content either at the beginning or at the end */
  truncate?: boolean;
  /** Whether the action is active or not */
  active?: boolean;
  /** The item variations */
  variant?: 'default' | 'menu' | 'indented';
  /** Defines a role for the action */
  role?: string;
}

export interface ActionListSection {
  /** Section title */
  title?: string;
  /** Collection of action items for the list */
  items: ActionListItemDescriptor[];
}

export interface MenuActionDescriptor extends ComplexAction {
  /** Zero-indexed numerical position. Overrides the action's order in the menu */
  index?: number;
}

export interface MenuGroupDescriptor extends BadgeAction {
  /** Menu group title */
  title: string;
  /** List of actions */
  actions: ActionListItemDescriptor[];
  /** Icon to display */
  icon?: IconableAction['icon'];
  /** Disables action button */
  disabled?: boolean;
  /** Zero-indexed numerical position. Overrides the group's order in the menu. */
  index?: number;
}

export interface CheckboxHandles {
  focus(): void;
}

export interface ResourceListContextType {
  selectMode?: boolean;
  selectable?: boolean;
  selectedItems?: ResourceListSelectedItems;
  resourceName?: {
    singular: string;
    plural: string;
  };
  hasBulkActions?: boolean;
  loading?: boolean;
  onSelectionChange?(
    selected: boolean,
    id: string,
    sortNumber: number | undefined,
    shiftKey: boolean,
  ): void;
}

export type ResourceListSelectedItems = string[] | 'All';
export type CheckableButtonKey = 'plain' | 'bulkSm' | 'bulkLg';
export type CheckableButtons = Map<CheckableButtonKey, CheckboxHandles>;
export interface OptionDescriptor {
  /** Value of the option */
  value: string;
  /** Whether the option is disabled or not */
  disabled?: boolean;
  /** Whether the option is active or not */
  active?: boolean;
  /** Unique identifier for the option */
  id?: string;
  /** Display label for the option */
  label: string,
  /** Media to display to the left of the option content */
  media?: VueNode;
}

export interface SectionDescriptor {
  /** Collection of options within the section */
  options: OptionDescriptor[];
  /** Section title */
  title?: string;
}

export type Descriptor = SectionDescriptor | OptionDescriptor;
export interface NavigableOption {
  domId: string;
  value: string;
  element: HTMLElement;
  disabled: boolean;
  isAction?: boolean;
  index?: number;
}

export interface ListboxContextType {
  onOptionSelect(option: NavigableOption): void;
  setLoading(label?: string): void;
}

export interface ComboboxListboxOptionType {
  // Whether the option should visually support multiple selection
  allowMultiple?: boolean;
}

export interface ComboboxListboxType {
  // Value of the Texfields ID for listbox aria-labelledby
  textFieldLabelId?: string | undefined;
  // Enables/disables keyboard control
  textFieldFocused?: boolean;
  // Unique ID to set on the listbox. Used to set the Combobox aria-owns and TextField aria-controls attributes.
  listboxId?: string | undefined;
  // Whether or not more options are available to lazy load. Use the hasMoreResults boolean provided by the GraphQL API of the paginated data. */
  willLoadMoreOptions?: boolean;
  // Sets the value for the TextField aria-activedescendant attribute.
  setActiveOptionId?(id: string): void;
  // Callback to set a generated listbox ID.
  setListboxId?(id: string): void;
  // Callback fired when an option is selected.
  onOptionSelected?(): void;
  // Callback fired when keyboard user navigates to the last item. Use to lazy load when listbox option data is paginated.
  onKeyToBottom?(): void;
}

export interface AppliedFilterInterface {
  /** A unique key used to identify the applied filter */
  key: string;
  /** A label for the applied filter */
  label: string;
  unsavedChanges?: boolean;
  /** Callback when the remove button is pressed */
  onRemove(key: string): void;
}


export interface FilterInterface {
  /** A unique key used to identify the filter */
  key: string;
  /** The label for the filter */
  label: string;
  /** The markup for the given filter */
  filter: VueNode;
  /** Whether or not the filter should have a shortcut popover displayed */
  shortcut?: boolean;
  /** Whether or not the filter should be pinned, permanently displaying the filter */
  pinned?: boolean;
  /** Whether or not the filter is disabled */
  disabled?: boolean;
  /**
   * @default false
   * Whether or not the clear button is displayed
   */
  hideClearButton?: boolean;
  /** Optional callback when filter is pressed */
  onAction?: () => void;
  /** Suffix source */
  suffix?: VueNode;
  /** Optional section heading that this filter will go under  */
  section?: string;
  /** Optional: hides the filter from the dropdown  */
  hidden?: boolean;
}
```

# utilities/use-theme.ts

```ts
export const THEME_CONTEXT_KEY = "ThemeContext";
export const THEME_NAME_CONTEXT_KEY = "ThemeNameContext";
```

